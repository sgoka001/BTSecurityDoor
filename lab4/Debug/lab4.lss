
lab4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b2  00800100  00001a30  00001ac4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a30  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000840  008001b2  008001b2  00001b76  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001b76  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001ba8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000258  00000000  00000000  00001be8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003766  00000000  00000000  00001e40  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001107  00000000  00000000  000055a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002154  00000000  00000000  000066ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000062c  00000000  00000000  00008804  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000fb7  00000000  00000000  00008e30  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000201c  00000000  00000000  00009de7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000270  00000000  00000000  0000be03  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	42 c1       	rjmp	.+644    	; 0x286 <__ctors_end>
       2:	00 00       	nop
       4:	5e c1       	rjmp	.+700    	; 0x2c2 <__bad_interrupt>
       6:	00 00       	nop
       8:	5c c1       	rjmp	.+696    	; 0x2c2 <__bad_interrupt>
       a:	00 00       	nop
       c:	5a c1       	rjmp	.+692    	; 0x2c2 <__bad_interrupt>
       e:	00 00       	nop
      10:	58 c1       	rjmp	.+688    	; 0x2c2 <__bad_interrupt>
      12:	00 00       	nop
      14:	56 c1       	rjmp	.+684    	; 0x2c2 <__bad_interrupt>
      16:	00 00       	nop
      18:	54 c1       	rjmp	.+680    	; 0x2c2 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	52 c1       	rjmp	.+676    	; 0x2c2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	50 c1       	rjmp	.+672    	; 0x2c2 <__bad_interrupt>
      22:	00 00       	nop
      24:	4e c1       	rjmp	.+668    	; 0x2c2 <__bad_interrupt>
      26:	00 00       	nop
      28:	4c c1       	rjmp	.+664    	; 0x2c2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4a c1       	rjmp	.+660    	; 0x2c2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	48 c1       	rjmp	.+656    	; 0x2c2 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 7b 09 	jmp	0x12f6	; 0x12f6 <__vector_13>
      38:	44 c1       	rjmp	.+648    	; 0x2c2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	42 c1       	rjmp	.+644    	; 0x2c2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	40 c1       	rjmp	.+640    	; 0x2c2 <__bad_interrupt>
      42:	00 00       	nop
      44:	3e c1       	rjmp	.+636    	; 0x2c2 <__bad_interrupt>
      46:	00 00       	nop
      48:	3c c1       	rjmp	.+632    	; 0x2c2 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	3a c1       	rjmp	.+628    	; 0x2c2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	38 c1       	rjmp	.+624    	; 0x2c2 <__bad_interrupt>
      52:	00 00       	nop
      54:	36 c1       	rjmp	.+620    	; 0x2c2 <__bad_interrupt>
      56:	00 00       	nop
      58:	34 c1       	rjmp	.+616    	; 0x2c2 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	32 c1       	rjmp	.+612    	; 0x2c2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	30 c1       	rjmp	.+608    	; 0x2c2 <__bad_interrupt>
      62:	00 00       	nop
      64:	2e c1       	rjmp	.+604    	; 0x2c2 <__bad_interrupt>
      66:	00 00       	nop
      68:	2c c1       	rjmp	.+600    	; 0x2c2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2a c1       	rjmp	.+596    	; 0x2c2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	28 c1       	rjmp	.+592    	; 0x2c2 <__bad_interrupt>
      72:	00 00       	nop
      74:	26 c1       	rjmp	.+588    	; 0x2c2 <__bad_interrupt>
      76:	00 00       	nop
      78:	24 c1       	rjmp	.+584    	; 0x2c2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	22 c1       	rjmp	.+580    	; 0x2c2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	20 c1       	rjmp	.+576    	; 0x2c2 <__bad_interrupt>
      82:	00 00       	nop
      84:	1e c1       	rjmp	.+572    	; 0x2c2 <__bad_interrupt>
      86:	00 00       	nop
      88:	1c c1       	rjmp	.+568    	; 0x2c2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	47 04       	cpc	r4, r7
      8e:	4e 04       	cpc	r4, r14
      90:	63 04       	cpc	r6, r3
      92:	71 04       	cpc	r7, r1
      94:	8b 04       	cpc	r8, r11
      96:	99 04       	cpc	r9, r9
      98:	a7 04       	cpc	r10, r7
      9a:	b5 04       	cpc	r11, r5
      9c:	cf 04       	cpc	r12, r15
      9e:	dd 04       	cpc	r13, r13
      a0:	f7 04       	cpc	r15, r7
      a2:	13 05       	cpc	r17, r3
      a4:	00 05       	cpc	r16, r0

000000a6 <CHARSET>:
      a6:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
      b6:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
      c6:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
      d6:	1c 00 14 08 3e 08 14 08 08 3e 08 08 00 50 30 00     ....>....>...P0.
      e6:	00 08 08 08 08 08 00 60 60 00 00 20 10 08 04 02     .......``.. ....
      f6:	3e 51 49 45 3e 00 42 7f 40 00 42 61 51 49 46 21     >QIE>.B.@.BaQIF!
     106:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
     116:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
     126:	29 1e 00 36 36 00 00 00 56 36 00 00 08 14 22 41     )..66...V6...."A
     136:	00 14 14 14 14 14 00 41 22 14 08 02 01 51 09 06     .......A"....Q..
     146:	32 49 79 41 3e 7e 11 11 11 7e 7f 49 49 49 36 3e     2IyA>~...~.III6>
     156:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
     166:	09 09 01 3e 41 49 49 7a 7f 08 08 08 7f 00 41 7f     ...>AIIz......A.
     176:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     186:	40 7f 02 0c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     196:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
     1a6:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
     1b6:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 07 08 70     @ .?@8@?c...c..p
     1c6:	08 07 61 51 49 45 43 00 7f 41 41 00 02 04 08 10     ..aQIEC..AA.....
     1d6:	20 00 41 41 7f 00 04 02 01 02 04 40 40 40 40 40      .AA.......@@@@@
     1e6:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
     1f6:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
     206:	09 01 02 0c 52 52 52 3e 7f 08 04 04 78 00 44 7d     ....RRR>....x.D}
     216:	40 00 20 40 44 3d 00 7f 10 28 44 00 00 41 7f 40     @. @D=...(D..A.@
     226:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
     236:	7c 14 14 14 08 08 14 14 18 7c 7c 08 04 04 08 48     |........||....H
     246:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
     256:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
     266:	50 3c 44 64 54 4c 44 00 08 36 41 00 00 00 7f 00     P<DdTLD..6A.....
     276:	00 00 41 36 08 00 10 08 08 10 08 00 00 00 00 00     ..A6............

00000286 <__ctors_end>:
     286:	11 24       	eor	r1, r1
     288:	1f be       	out	0x3f, r1	; 63
     28a:	cf ef       	ldi	r28, 0xFF	; 255
     28c:	d0 e4       	ldi	r29, 0x40	; 64
     28e:	de bf       	out	0x3e, r29	; 62
     290:	cd bf       	out	0x3d, r28	; 61

00000292 <__do_copy_data>:
     292:	11 e0       	ldi	r17, 0x01	; 1
     294:	a0 e0       	ldi	r26, 0x00	; 0
     296:	b1 e0       	ldi	r27, 0x01	; 1
     298:	e0 e3       	ldi	r30, 0x30	; 48
     29a:	fa e1       	ldi	r31, 0x1A	; 26
     29c:	00 e0       	ldi	r16, 0x00	; 0
     29e:	0b bf       	out	0x3b, r16	; 59
     2a0:	02 c0       	rjmp	.+4      	; 0x2a6 <__do_copy_data+0x14>
     2a2:	07 90       	elpm	r0, Z+
     2a4:	0d 92       	st	X+, r0
     2a6:	a2 3b       	cpi	r26, 0xB2	; 178
     2a8:	b1 07       	cpc	r27, r17
     2aa:	d9 f7       	brne	.-10     	; 0x2a2 <__do_copy_data+0x10>

000002ac <__do_clear_bss>:
     2ac:	29 e0       	ldi	r18, 0x09	; 9
     2ae:	a2 eb       	ldi	r26, 0xB2	; 178
     2b0:	b1 e0       	ldi	r27, 0x01	; 1
     2b2:	01 c0       	rjmp	.+2      	; 0x2b6 <.do_clear_bss_start>

000002b4 <.do_clear_bss_loop>:
     2b4:	1d 92       	st	X+, r1

000002b6 <.do_clear_bss_start>:
     2b6:	a2 3f       	cpi	r26, 0xF2	; 242
     2b8:	b2 07       	cpc	r27, r18
     2ba:	e1 f7       	brne	.-8      	; 0x2b4 <.do_clear_bss_loop>
     2bc:	ad d6       	rcall	.+3418   	; 0x1018 <main>
     2be:	0c 94 16 0d 	jmp	0x1a2c	; 0x1a2c <_exit>

000002c2 <__bad_interrupt>:
     2c2:	9e ce       	rjmp	.-708    	; 0x0 <__vectors>

000002c4 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
     2c8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     2ca:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     2ce:	20 91 b2 01 	lds	r18, 0x01B2	; 0x8001b2 <__data_end>
     2d2:	30 91 b3 01 	lds	r19, 0x01B3	; 0x8001b3 <__data_end+0x1>
     2d6:	c9 01       	movw	r24, r18
     2d8:	8c 0f       	add	r24, r28
     2da:	9d 1f       	adc	r25, r29
     2dc:	8c 3d       	cpi	r24, 0xDC	; 220
     2de:	45 e0       	ldi	r20, 0x05	; 5
     2e0:	94 07       	cpc	r25, r20
     2e2:	58 f4       	brcc	.+22     	; 0x2fa <pvPortMalloc+0x36>
     2e4:	28 17       	cp	r18, r24
     2e6:	39 07       	cpc	r19, r25
     2e8:	58 f4       	brcc	.+22     	; 0x300 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     2ea:	e9 01       	movw	r28, r18
     2ec:	cc 54       	subi	r28, 0x4C	; 76
     2ee:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
     2f0:	90 93 b3 01 	sts	0x01B3, r25	; 0x8001b3 <__data_end+0x1>
     2f4:	80 93 b2 01 	sts	0x01B2, r24	; 0x8001b2 <__data_end>
     2f8:	05 c0       	rjmp	.+10     	; 0x304 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     2fa:	c0 e0       	ldi	r28, 0x00	; 0
     2fc:	d0 e0       	ldi	r29, 0x00	; 0
     2fe:	02 c0       	rjmp	.+4      	; 0x304 <pvPortMalloc+0x40>
     300:	c0 e0       	ldi	r28, 0x00	; 0
     302:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     304:	0e 94 a6 0b 	call	0x174c	; 0x174c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     308:	ce 01       	movw	r24, r28
     30a:	df 91       	pop	r29
     30c:	cf 91       	pop	r28
     30e:	08 95       	ret

00000310 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     310:	08 95       	ret

00000312 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     312:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     314:	03 96       	adiw	r24, 0x03	; 3
     316:	92 83       	std	Z+2, r25	; 0x02
     318:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     31a:	2f ef       	ldi	r18, 0xFF	; 255
     31c:	3f ef       	ldi	r19, 0xFF	; 255
     31e:	34 83       	std	Z+4, r19	; 0x04
     320:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     322:	96 83       	std	Z+6, r25	; 0x06
     324:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     326:	90 87       	std	Z+8, r25	; 0x08
     328:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     32a:	10 82       	st	Z, r1
     32c:	08 95       	ret

0000032e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     32e:	fc 01       	movw	r30, r24
     330:	11 86       	std	Z+9, r1	; 0x09
     332:	10 86       	std	Z+8, r1	; 0x08
     334:	08 95       	ret

00000336 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     336:	cf 93       	push	r28
     338:	df 93       	push	r29
     33a:	fc 01       	movw	r30, r24
     33c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     33e:	21 81       	ldd	r18, Z+1	; 0x01
     340:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     342:	e9 01       	movw	r28, r18
     344:	8a 81       	ldd	r24, Y+2	; 0x02
     346:	9b 81       	ldd	r25, Y+3	; 0x03
     348:	13 96       	adiw	r26, 0x03	; 3
     34a:	9c 93       	st	X, r25
     34c:	8e 93       	st	-X, r24
     34e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     350:	81 81       	ldd	r24, Z+1	; 0x01
     352:	92 81       	ldd	r25, Z+2	; 0x02
     354:	15 96       	adiw	r26, 0x05	; 5
     356:	9c 93       	st	X, r25
     358:	8e 93       	st	-X, r24
     35a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     35c:	8a 81       	ldd	r24, Y+2	; 0x02
     35e:	9b 81       	ldd	r25, Y+3	; 0x03
     360:	ec 01       	movw	r28, r24
     362:	7d 83       	std	Y+5, r23	; 0x05
     364:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     366:	e9 01       	movw	r28, r18
     368:	7b 83       	std	Y+3, r23	; 0x03
     36a:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     36c:	72 83       	std	Z+2, r23	; 0x02
     36e:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     370:	19 96       	adiw	r26, 0x09	; 9
     372:	fc 93       	st	X, r31
     374:	ee 93       	st	-X, r30
     376:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     378:	80 81       	ld	r24, Z
     37a:	8f 5f       	subi	r24, 0xFF	; 255
     37c:	80 83       	st	Z, r24
}
     37e:	df 91       	pop	r29
     380:	cf 91       	pop	r28
     382:	08 95       	ret

00000384 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     384:	cf 93       	push	r28
     386:	df 93       	push	r29
     388:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     38a:	48 81       	ld	r20, Y
     38c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     38e:	4f 3f       	cpi	r20, 0xFF	; 255
     390:	2f ef       	ldi	r18, 0xFF	; 255
     392:	52 07       	cpc	r21, r18
     394:	31 f4       	brne	.+12     	; 0x3a2 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     396:	dc 01       	movw	r26, r24
     398:	17 96       	adiw	r26, 0x07	; 7
     39a:	ed 91       	ld	r30, X+
     39c:	fc 91       	ld	r31, X
     39e:	18 97       	sbiw	r26, 0x08	; 8
     3a0:	17 c0       	rjmp	.+46     	; 0x3d0 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     3a2:	fc 01       	movw	r30, r24
     3a4:	33 96       	adiw	r30, 0x03	; 3
     3a6:	dc 01       	movw	r26, r24
     3a8:	15 96       	adiw	r26, 0x05	; 5
     3aa:	2d 91       	ld	r18, X+
     3ac:	3c 91       	ld	r19, X
     3ae:	16 97       	sbiw	r26, 0x06	; 6
     3b0:	d9 01       	movw	r26, r18
     3b2:	2d 91       	ld	r18, X+
     3b4:	3c 91       	ld	r19, X
     3b6:	42 17       	cp	r20, r18
     3b8:	53 07       	cpc	r21, r19
     3ba:	50 f0       	brcs	.+20     	; 0x3d0 <vListInsert+0x4c>
     3bc:	02 80       	ldd	r0, Z+2	; 0x02
     3be:	f3 81       	ldd	r31, Z+3	; 0x03
     3c0:	e0 2d       	mov	r30, r0
     3c2:	a2 81       	ldd	r26, Z+2	; 0x02
     3c4:	b3 81       	ldd	r27, Z+3	; 0x03
     3c6:	2d 91       	ld	r18, X+
     3c8:	3c 91       	ld	r19, X
     3ca:	42 17       	cp	r20, r18
     3cc:	53 07       	cpc	r21, r19
     3ce:	b0 f7       	brcc	.-20     	; 0x3bc <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     3d0:	a2 81       	ldd	r26, Z+2	; 0x02
     3d2:	b3 81       	ldd	r27, Z+3	; 0x03
     3d4:	bb 83       	std	Y+3, r27	; 0x03
     3d6:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     3d8:	15 96       	adiw	r26, 0x05	; 5
     3da:	dc 93       	st	X, r29
     3dc:	ce 93       	st	-X, r28
     3de:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     3e0:	fd 83       	std	Y+5, r31	; 0x05
     3e2:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     3e4:	d3 83       	std	Z+3, r29	; 0x03
     3e6:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3e8:	99 87       	std	Y+9, r25	; 0x09
     3ea:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3ec:	fc 01       	movw	r30, r24
     3ee:	20 81       	ld	r18, Z
     3f0:	2f 5f       	subi	r18, 0xFF	; 255
     3f2:	20 83       	st	Z, r18
}
     3f4:	df 91       	pop	r29
     3f6:	cf 91       	pop	r28
     3f8:	08 95       	ret

000003fa <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     3fa:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3fc:	a2 81       	ldd	r26, Z+2	; 0x02
     3fe:	b3 81       	ldd	r27, Z+3	; 0x03
     400:	84 81       	ldd	r24, Z+4	; 0x04
     402:	95 81       	ldd	r25, Z+5	; 0x05
     404:	15 96       	adiw	r26, 0x05	; 5
     406:	9c 93       	st	X, r25
     408:	8e 93       	st	-X, r24
     40a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     40c:	a4 81       	ldd	r26, Z+4	; 0x04
     40e:	b5 81       	ldd	r27, Z+5	; 0x05
     410:	82 81       	ldd	r24, Z+2	; 0x02
     412:	93 81       	ldd	r25, Z+3	; 0x03
     414:	13 96       	adiw	r26, 0x03	; 3
     416:	9c 93       	st	X, r25
     418:	8e 93       	st	-X, r24
     41a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     41c:	a0 85       	ldd	r26, Z+8	; 0x08
     41e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     420:	11 96       	adiw	r26, 0x01	; 1
     422:	8d 91       	ld	r24, X+
     424:	9c 91       	ld	r25, X
     426:	12 97       	sbiw	r26, 0x02	; 2
     428:	e8 17       	cp	r30, r24
     42a:	f9 07       	cpc	r31, r25
     42c:	31 f4       	brne	.+12     	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     42e:	84 81       	ldd	r24, Z+4	; 0x04
     430:	95 81       	ldd	r25, Z+5	; 0x05
     432:	12 96       	adiw	r26, 0x02	; 2
     434:	9c 93       	st	X, r25
     436:	8e 93       	st	-X, r24
     438:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     43a:	11 86       	std	Z+9, r1	; 0x09
     43c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     43e:	8c 91       	ld	r24, X
     440:	81 50       	subi	r24, 0x01	; 1
     442:	8c 93       	st	X, r24
     444:	08 95       	ret

00000446 <write>:
//////////////////////////////////////////////////////////////////////// LOCAL VARIABLES ////////////////////////////////////////////////////////////////////////

enum MotorState {READ_MOTION, MENU, READ_KEY_WAIT, READ_KEY_INIT, CURRENT_PASS, CHANGE_PASS, READ_KEY_WAIT_2, READ_KEY_INIT_2, READ_KEY_WAIT_3, READ_KEY_INIT_3, READ_KEY, LOCK, UNLOCK} motor_state;

void Motor_Init(){
	motor_state = READ_MOTION;
     446:	28 98       	cbi	0x05, 0	; 5
     448:	66 23       	and	r22, r22
     44a:	11 f0       	breq	.+4      	; 0x450 <write+0xa>
     44c:	2a 9a       	sbi	0x05, 2	; 5
     44e:	15 c0       	rjmp	.+42     	; 0x47a <write+0x34>
     450:	2a 98       	cbi	0x05, 2	; 5
     452:	13 c0       	rjmp	.+38     	; 0x47a <write+0x34>
     454:	ac 01       	movw	r20, r24
     456:	02 2e       	mov	r0, r18
     458:	02 c0       	rjmp	.+4      	; 0x45e <write+0x18>
     45a:	55 95       	asr	r21
     45c:	47 95       	ror	r20
     45e:	0a 94       	dec	r0
     460:	e2 f7       	brpl	.-8      	; 0x45a <write+0x14>
     462:	40 ff       	sbrs	r20, 0
     464:	02 c0       	rjmp	.+4      	; 0x46a <write+0x24>
     466:	2b 9a       	sbi	0x05, 3	; 5
     468:	01 c0       	rjmp	.+2      	; 0x46c <write+0x26>
     46a:	2b 98       	cbi	0x05, 3	; 5
     46c:	2c 9a       	sbi	0x05, 4	; 5
     46e:	2c 98       	cbi	0x05, 4	; 5
     470:	21 50       	subi	r18, 0x01	; 1
     472:	31 09       	sbc	r19, r1
     474:	78 f7       	brcc	.-34     	; 0x454 <write+0xe>
     476:	28 9a       	sbi	0x05, 0	; 5
     478:	08 95       	ret
     47a:	27 e0       	ldi	r18, 0x07	; 7
     47c:	30 e0       	ldi	r19, 0x00	; 0
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	e9 cf       	rjmp	.-46     	; 0x454 <write+0xe>

00000482 <write_cmd>:
     482:	60 e0       	ldi	r22, 0x00	; 0
     484:	e0 cf       	rjmp	.-64     	; 0x446 <write>
     486:	08 95       	ret

00000488 <GetKeypadKey>:
     488:	8f ee       	ldi	r24, 0xEF	; 239
     48a:	88 b9       	out	0x08, r24	; 8
     48c:	00 00       	nop
     48e:	30 9b       	sbis	0x06, 0	; 6
     490:	29 c0       	rjmp	.+82     	; 0x4e4 <GetKeypadKey+0x5c>
     492:	31 9b       	sbis	0x06, 1	; 6
     494:	29 c0       	rjmp	.+82     	; 0x4e8 <GetKeypadKey+0x60>
     496:	32 9b       	sbis	0x06, 2	; 6
     498:	29 c0       	rjmp	.+82     	; 0x4ec <GetKeypadKey+0x64>
     49a:	33 9b       	sbis	0x06, 3	; 6
     49c:	29 c0       	rjmp	.+82     	; 0x4f0 <GetKeypadKey+0x68>
     49e:	8f ed       	ldi	r24, 0xDF	; 223
     4a0:	88 b9       	out	0x08, r24	; 8
     4a2:	00 00       	nop
     4a4:	30 9b       	sbis	0x06, 0	; 6
     4a6:	26 c0       	rjmp	.+76     	; 0x4f4 <GetKeypadKey+0x6c>
     4a8:	31 9b       	sbis	0x06, 1	; 6
     4aa:	26 c0       	rjmp	.+76     	; 0x4f8 <GetKeypadKey+0x70>
     4ac:	32 9b       	sbis	0x06, 2	; 6
     4ae:	26 c0       	rjmp	.+76     	; 0x4fc <GetKeypadKey+0x74>
     4b0:	33 9b       	sbis	0x06, 3	; 6
     4b2:	26 c0       	rjmp	.+76     	; 0x500 <GetKeypadKey+0x78>
     4b4:	8f eb       	ldi	r24, 0xBF	; 191
     4b6:	88 b9       	out	0x08, r24	; 8
     4b8:	00 00       	nop
     4ba:	30 9b       	sbis	0x06, 0	; 6
     4bc:	23 c0       	rjmp	.+70     	; 0x504 <GetKeypadKey+0x7c>
     4be:	31 9b       	sbis	0x06, 1	; 6
     4c0:	23 c0       	rjmp	.+70     	; 0x508 <GetKeypadKey+0x80>
     4c2:	32 9b       	sbis	0x06, 2	; 6
     4c4:	23 c0       	rjmp	.+70     	; 0x50c <GetKeypadKey+0x84>
     4c6:	33 9b       	sbis	0x06, 3	; 6
     4c8:	23 c0       	rjmp	.+70     	; 0x510 <GetKeypadKey+0x88>
     4ca:	8f e7       	ldi	r24, 0x7F	; 127
     4cc:	88 b9       	out	0x08, r24	; 8
     4ce:	00 00       	nop
     4d0:	30 9b       	sbis	0x06, 0	; 6
     4d2:	20 c0       	rjmp	.+64     	; 0x514 <GetKeypadKey+0x8c>
     4d4:	31 9b       	sbis	0x06, 1	; 6
     4d6:	20 c0       	rjmp	.+64     	; 0x518 <GetKeypadKey+0x90>
     4d8:	32 9b       	sbis	0x06, 2	; 6
     4da:	20 c0       	rjmp	.+64     	; 0x51c <GetKeypadKey+0x94>
     4dc:	33 9b       	sbis	0x06, 3	; 6
     4de:	20 c0       	rjmp	.+64     	; 0x520 <GetKeypadKey+0x98>
     4e0:	80 e0       	ldi	r24, 0x00	; 0
     4e2:	08 95       	ret
     4e4:	81 e3       	ldi	r24, 0x31	; 49
     4e6:	08 95       	ret
     4e8:	84 e3       	ldi	r24, 0x34	; 52
     4ea:	08 95       	ret
     4ec:	87 e3       	ldi	r24, 0x37	; 55
     4ee:	08 95       	ret
     4f0:	8a e2       	ldi	r24, 0x2A	; 42
     4f2:	08 95       	ret
     4f4:	82 e3       	ldi	r24, 0x32	; 50
     4f6:	08 95       	ret
     4f8:	85 e3       	ldi	r24, 0x35	; 53
     4fa:	08 95       	ret
     4fc:	88 e3       	ldi	r24, 0x38	; 56
     4fe:	08 95       	ret
     500:	80 e3       	ldi	r24, 0x30	; 48
     502:	08 95       	ret
     504:	83 e3       	ldi	r24, 0x33	; 51
     506:	08 95       	ret
     508:	86 e3       	ldi	r24, 0x36	; 54
     50a:	08 95       	ret
     50c:	89 e3       	ldi	r24, 0x39	; 57
     50e:	08 95       	ret
     510:	83 e2       	ldi	r24, 0x23	; 35
     512:	08 95       	ret
     514:	81 e4       	ldi	r24, 0x41	; 65
     516:	08 95       	ret
     518:	82 e4       	ldi	r24, 0x42	; 66
     51a:	08 95       	ret
     51c:	83 e4       	ldi	r24, 0x43	; 67
     51e:	08 95       	ret
     520:	84 e4       	ldi	r24, 0x44	; 68
     522:	08 95       	ret

00000524 <nokia_lcd_init>:
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	20 9a       	sbi	0x04, 0	; 4
     52a:	21 9a       	sbi	0x04, 1	; 4
     52c:	22 9a       	sbi	0x04, 2	; 4
     52e:	23 9a       	sbi	0x04, 3	; 4
     530:	24 9a       	sbi	0x04, 4	; 4
     532:	29 9a       	sbi	0x05, 1	; 5
     534:	28 9a       	sbi	0x05, 0	; 5
     536:	83 ec       	ldi	r24, 0xC3	; 195
     538:	99 e0       	ldi	r25, 0x09	; 9
     53a:	01 97       	sbiw	r24, 0x01	; 1
     53c:	f1 f7       	brne	.-4      	; 0x53a <nokia_lcd_init+0x16>
     53e:	00 c0       	rjmp	.+0      	; 0x540 <nokia_lcd_init+0x1c>
     540:	00 00       	nop
     542:	29 98       	cbi	0x05, 1	; 5
     544:	8b e5       	ldi	r24, 0x5B	; 91
     546:	94 e4       	ldi	r25, 0x44	; 68
     548:	01 97       	sbiw	r24, 0x01	; 1
     54a:	f1 f7       	brne	.-4      	; 0x548 <nokia_lcd_init+0x24>
     54c:	00 c0       	rjmp	.+0      	; 0x54e <nokia_lcd_init+0x2a>
     54e:	00 00       	nop
     550:	29 9a       	sbi	0x05, 1	; 5
     552:	28 98       	cbi	0x05, 0	; 5
     554:	81 e2       	ldi	r24, 0x21	; 33
     556:	95 df       	rcall	.-214    	; 0x482 <write_cmd>
     558:	83 e1       	ldi	r24, 0x13	; 19
     55a:	93 df       	rcall	.-218    	; 0x482 <write_cmd>
     55c:	86 e0       	ldi	r24, 0x06	; 6
     55e:	91 df       	rcall	.-222    	; 0x482 <write_cmd>
     560:	82 ec       	ldi	r24, 0xC2	; 194
     562:	8f df       	rcall	.-226    	; 0x482 <write_cmd>
     564:	80 e2       	ldi	r24, 0x20	; 32
     566:	8d df       	rcall	.-230    	; 0x482 <write_cmd>
     568:	89 e0       	ldi	r24, 0x09	; 9
     56a:	8b df       	rcall	.-234    	; 0x482 <write_cmd>
     56c:	80 e8       	ldi	r24, 0x80	; 128
     56e:	89 df       	rcall	.-238    	; 0x482 <write_cmd>
     570:	80 e4       	ldi	r24, 0x40	; 64
     572:	87 df       	rcall	.-242    	; 0x482 <write_cmd>
     574:	c8 ef       	ldi	r28, 0xF8	; 248
     576:	d1 e0       	ldi	r29, 0x01	; 1
     578:	61 e0       	ldi	r22, 0x01	; 1
     57a:	80 e0       	ldi	r24, 0x00	; 0
     57c:	64 df       	rcall	.-312    	; 0x446 <write>
     57e:	21 97       	sbiw	r28, 0x01	; 1
     580:	d9 f7       	brne	.-10     	; 0x578 <nokia_lcd_init+0x54>
     582:	88 e0       	ldi	r24, 0x08	; 8
     584:	7e df       	rcall	.-260    	; 0x482 <write_cmd>
     586:	8c e0       	ldi	r24, 0x0C	; 12
     588:	7c df       	rcall	.-264    	; 0x482 <write_cmd>
     58a:	df 91       	pop	r29
     58c:	cf 91       	pop	r28
     58e:	08 95       	ret

00000590 <nokia_lcd_clear>:
     590:	80 e8       	ldi	r24, 0x80	; 128
     592:	77 df       	rcall	.-274    	; 0x482 <write_cmd>
     594:	80 e4       	ldi	r24, 0x40	; 64
     596:	75 df       	rcall	.-278    	; 0x482 <write_cmd>
     598:	10 92 91 09 	sts	0x0991, r1	; 0x800991 <nokia_lcd+0x1f8>
     59c:	10 92 92 09 	sts	0x0992, r1	; 0x800992 <nokia_lcd+0x1f9>
     5a0:	e9 e9       	ldi	r30, 0x99	; 153
     5a2:	f7 e0       	ldi	r31, 0x07	; 7
     5a4:	81 e9       	ldi	r24, 0x91	; 145
     5a6:	99 e0       	ldi	r25, 0x09	; 9
     5a8:	11 92       	st	Z+, r1
     5aa:	e8 17       	cp	r30, r24
     5ac:	f9 07       	cpc	r31, r25
     5ae:	e1 f7       	brne	.-8      	; 0x5a8 <nokia_lcd_clear+0x18>
     5b0:	08 95       	ret

000005b2 <nokia_lcd_set_pixel>:
     5b2:	26 2f       	mov	r18, r22
     5b4:	26 95       	lsr	r18
     5b6:	26 95       	lsr	r18
     5b8:	26 95       	lsr	r18
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	34 e5       	ldi	r19, 0x54	; 84
     5be:	23 9f       	mul	r18, r19
     5c0:	80 0d       	add	r24, r0
     5c2:	91 1d       	adc	r25, r1
     5c4:	11 24       	eor	r1, r1
     5c6:	44 23       	and	r20, r20
     5c8:	79 f0       	breq	.+30     	; 0x5e8 <nokia_lcd_set_pixel+0x36>
     5ca:	fc 01       	movw	r30, r24
     5cc:	e7 56       	subi	r30, 0x67	; 103
     5ce:	f8 4f       	sbci	r31, 0xF8	; 248
     5d0:	67 70       	andi	r22, 0x07	; 7
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	02 c0       	rjmp	.+4      	; 0x5dc <nokia_lcd_set_pixel+0x2a>
     5d8:	88 0f       	add	r24, r24
     5da:	99 1f       	adc	r25, r25
     5dc:	6a 95       	dec	r22
     5de:	e2 f7       	brpl	.-8      	; 0x5d8 <nokia_lcd_set_pixel+0x26>
     5e0:	90 81       	ld	r25, Z
     5e2:	89 2b       	or	r24, r25
     5e4:	80 83       	st	Z, r24
     5e6:	08 95       	ret
     5e8:	fc 01       	movw	r30, r24
     5ea:	e7 56       	subi	r30, 0x67	; 103
     5ec:	f8 4f       	sbci	r31, 0xF8	; 248
     5ee:	67 70       	andi	r22, 0x07	; 7
     5f0:	81 e0       	ldi	r24, 0x01	; 1
     5f2:	90 e0       	ldi	r25, 0x00	; 0
     5f4:	02 c0       	rjmp	.+4      	; 0x5fa <nokia_lcd_set_pixel+0x48>
     5f6:	88 0f       	add	r24, r24
     5f8:	99 1f       	adc	r25, r25
     5fa:	6a 95       	dec	r22
     5fc:	e2 f7       	brpl	.-8      	; 0x5f6 <nokia_lcd_set_pixel+0x44>
     5fe:	80 95       	com	r24
     600:	90 81       	ld	r25, Z
     602:	89 23       	and	r24, r25
     604:	80 83       	st	Z, r24
     606:	08 95       	ret

00000608 <nokia_lcd_write_char>:
     608:	5f 92       	push	r5
     60a:	6f 92       	push	r6
     60c:	7f 92       	push	r7
     60e:	8f 92       	push	r8
     610:	9f 92       	push	r9
     612:	af 92       	push	r10
     614:	bf 92       	push	r11
     616:	cf 92       	push	r12
     618:	df 92       	push	r13
     61a:	ef 92       	push	r14
     61c:	ff 92       	push	r15
     61e:	0f 93       	push	r16
     620:	1f 93       	push	r17
     622:	cf 93       	push	r28
     624:	df 93       	push	r29
     626:	56 2e       	mov	r5, r22
     628:	26 2f       	mov	r18, r22
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	49 01       	movw	r8, r18
     62e:	88 0c       	add	r8, r8
     630:	99 1c       	adc	r9, r9
     632:	88 0c       	add	r8, r8
     634:	99 1c       	adc	r9, r9
     636:	82 0e       	add	r8, r18
     638:	93 1e       	adc	r9, r19
     63a:	18 14       	cp	r1, r8
     63c:	19 04       	cpc	r1, r9
     63e:	0c f0       	brlt	.+2      	; 0x642 <nokia_lcd_write_char+0x3a>
     640:	5b c0       	rjmp	.+182    	; 0x6f8 <nokia_lcd_write_char+0xf0>
     642:	89 01       	movw	r16, r18
     644:	00 0f       	add	r16, r16
     646:	11 1f       	adc	r17, r17
     648:	00 0f       	add	r16, r16
     64a:	11 1f       	adc	r17, r17
     64c:	00 0f       	add	r16, r16
     64e:	11 1f       	adc	r17, r17
     650:	02 1b       	sub	r16, r18
     652:	13 0b       	sbc	r17, r19
     654:	61 2c       	mov	r6, r1
     656:	a8 2e       	mov	r10, r24
     658:	b1 2c       	mov	r11, r1
     65a:	c5 01       	movw	r24, r10
     65c:	80 97       	sbiw	r24, 0x20	; 32
     65e:	5c 01       	movw	r10, r24
     660:	aa 0c       	add	r10, r10
     662:	bb 1c       	adc	r11, r11
     664:	aa 0c       	add	r10, r10
     666:	bb 1c       	adc	r11, r11
     668:	a8 0e       	add	r10, r24
     66a:	b9 1e       	adc	r11, r25
     66c:	0f 2e       	mov	r0, r31
     66e:	f2 e9       	ldi	r31, 0x92	; 146
     670:	cf 2e       	mov	r12, r31
     672:	f9 e0       	ldi	r31, 0x09	; 9
     674:	df 2e       	mov	r13, r31
     676:	f0 2d       	mov	r31, r0
     678:	0f 2e       	mov	r0, r31
     67a:	f1 e9       	ldi	r31, 0x91	; 145
     67c:	ef 2e       	mov	r14, r31
     67e:	f9 e0       	ldi	r31, 0x09	; 9
     680:	ff 2e       	mov	r15, r31
     682:	f0 2d       	mov	r31, r0
     684:	2b c0       	rjmp	.+86     	; 0x6dc <nokia_lcd_write_char+0xd4>
     686:	fe 01       	movw	r30, r28
     688:	24 91       	lpm	r18, Z
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	87 2d       	mov	r24, r7
     68e:	65 2d       	mov	r22, r5
     690:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <__udivmodqi4>
     694:	02 c0       	rjmp	.+4      	; 0x69a <nokia_lcd_write_char+0x92>
     696:	35 95       	asr	r19
     698:	27 95       	ror	r18
     69a:	8a 95       	dec	r24
     69c:	e2 f7       	brpl	.-8      	; 0x696 <nokia_lcd_write_char+0x8e>
     69e:	20 ff       	sbrs	r18, 0
     6a0:	09 c0       	rjmp	.+18     	; 0x6b4 <nokia_lcd_write_char+0xac>
     6a2:	f6 01       	movw	r30, r12
     6a4:	60 81       	ld	r22, Z
     6a6:	67 0d       	add	r22, r7
     6a8:	f7 01       	movw	r30, r14
     6aa:	80 81       	ld	r24, Z
     6ac:	41 e0       	ldi	r20, 0x01	; 1
     6ae:	86 0d       	add	r24, r6
     6b0:	80 df       	rcall	.-256    	; 0x5b2 <nokia_lcd_set_pixel>
     6b2:	08 c0       	rjmp	.+16     	; 0x6c4 <nokia_lcd_write_char+0xbc>
     6b4:	f6 01       	movw	r30, r12
     6b6:	60 81       	ld	r22, Z
     6b8:	67 0d       	add	r22, r7
     6ba:	f7 01       	movw	r30, r14
     6bc:	80 81       	ld	r24, Z
     6be:	40 e0       	ldi	r20, 0x00	; 0
     6c0:	86 0d       	add	r24, r6
     6c2:	77 df       	rcall	.-274    	; 0x5b2 <nokia_lcd_set_pixel>
     6c4:	73 94       	inc	r7
     6c6:	87 2d       	mov	r24, r7
     6c8:	90 e0       	ldi	r25, 0x00	; 0
     6ca:	80 17       	cp	r24, r16
     6cc:	91 07       	cpc	r25, r17
     6ce:	dc f2       	brlt	.-74     	; 0x686 <nokia_lcd_write_char+0x7e>
     6d0:	63 94       	inc	r6
     6d2:	86 2d       	mov	r24, r6
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	88 15       	cp	r24, r8
     6d8:	99 05       	cpc	r25, r9
     6da:	74 f4       	brge	.+28     	; 0x6f8 <nokia_lcd_write_char+0xf0>
     6dc:	10 16       	cp	r1, r16
     6de:	11 06       	cpc	r1, r17
     6e0:	bc f7       	brge	.-18     	; 0x6d0 <nokia_lcd_write_char+0xc8>
     6e2:	86 2d       	mov	r24, r6
     6e4:	65 2d       	mov	r22, r5
     6e6:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <__udivmodqi4>
     6ea:	e5 01       	movw	r28, r10
     6ec:	c8 0f       	add	r28, r24
     6ee:	d1 1d       	adc	r29, r1
     6f0:	ca 55       	subi	r28, 0x5A	; 90
     6f2:	df 4f       	sbci	r29, 0xFF	; 255
     6f4:	71 2c       	mov	r7, r1
     6f6:	c7 cf       	rjmp	.-114    	; 0x686 <nokia_lcd_write_char+0x7e>
     6f8:	80 91 91 09 	lds	r24, 0x0991	; 0x800991 <nokia_lcd+0x1f8>
     6fc:	91 e0       	ldi	r25, 0x01	; 1
     6fe:	98 0f       	add	r25, r24
     700:	85 2d       	mov	r24, r5
     702:	88 0f       	add	r24, r24
     704:	88 0f       	add	r24, r24
     706:	85 0d       	add	r24, r5
     708:	89 0f       	add	r24, r25
     70a:	84 35       	cpi	r24, 0x54	; 84
     70c:	18 f4       	brcc	.+6      	; 0x714 <nokia_lcd_write_char+0x10c>
     70e:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <nokia_lcd+0x1f8>
     712:	0e c0       	rjmp	.+28     	; 0x730 <nokia_lcd_write_char+0x128>
     714:	10 92 91 09 	sts	0x0991, r1	; 0x800991 <nokia_lcd+0x1f8>
     718:	e2 e9       	ldi	r30, 0x92	; 146
     71a:	f9 e0       	ldi	r31, 0x09	; 9
     71c:	80 81       	ld	r24, Z
     71e:	91 e0       	ldi	r25, 0x01	; 1
     720:	98 0f       	add	r25, r24
     722:	85 2d       	mov	r24, r5
     724:	88 0f       	add	r24, r24
     726:	88 0f       	add	r24, r24
     728:	88 0f       	add	r24, r24
     72a:	85 19       	sub	r24, r5
     72c:	89 0f       	add	r24, r25
     72e:	80 83       	st	Z, r24
     730:	80 91 92 09 	lds	r24, 0x0992	; 0x800992 <nokia_lcd+0x1f9>
     734:	80 33       	cpi	r24, 0x30	; 48
     736:	20 f0       	brcs	.+8      	; 0x740 <nokia_lcd_write_char+0x138>
     738:	10 92 91 09 	sts	0x0991, r1	; 0x800991 <nokia_lcd+0x1f8>
     73c:	10 92 92 09 	sts	0x0992, r1	; 0x800992 <nokia_lcd+0x1f9>
     740:	df 91       	pop	r29
     742:	cf 91       	pop	r28
     744:	1f 91       	pop	r17
     746:	0f 91       	pop	r16
     748:	ff 90       	pop	r15
     74a:	ef 90       	pop	r14
     74c:	df 90       	pop	r13
     74e:	cf 90       	pop	r12
     750:	bf 90       	pop	r11
     752:	af 90       	pop	r10
     754:	9f 90       	pop	r9
     756:	8f 90       	pop	r8
     758:	7f 90       	pop	r7
     75a:	6f 90       	pop	r6
     75c:	5f 90       	pop	r5
     75e:	08 95       	ret

00000760 <nokia_lcd_write_string>:
     760:	1f 93       	push	r17
     762:	cf 93       	push	r28
     764:	df 93       	push	r29
     766:	ec 01       	movw	r28, r24
     768:	88 81       	ld	r24, Y
     76a:	88 23       	and	r24, r24
     76c:	39 f0       	breq	.+14     	; 0x77c <nokia_lcd_write_string+0x1c>
     76e:	16 2f       	mov	r17, r22
     770:	21 96       	adiw	r28, 0x01	; 1
     772:	61 2f       	mov	r22, r17
     774:	49 df       	rcall	.-366    	; 0x608 <nokia_lcd_write_char>
     776:	89 91       	ld	r24, Y+
     778:	81 11       	cpse	r24, r1
     77a:	fb cf       	rjmp	.-10     	; 0x772 <nokia_lcd_write_string+0x12>
     77c:	df 91       	pop	r29
     77e:	cf 91       	pop	r28
     780:	1f 91       	pop	r17
     782:	08 95       	ret

00000784 <nokia_lcd_render>:
     784:	0f 93       	push	r16
     786:	1f 93       	push	r17
     788:	cf 93       	push	r28
     78a:	df 93       	push	r29
     78c:	80 e8       	ldi	r24, 0x80	; 128
     78e:	79 de       	rcall	.-782    	; 0x482 <write_cmd>
     790:	80 e4       	ldi	r24, 0x40	; 64
     792:	77 de       	rcall	.-786    	; 0x482 <write_cmd>
     794:	c9 e9       	ldi	r28, 0x99	; 153
     796:	d7 e0       	ldi	r29, 0x07	; 7
     798:	01 e9       	ldi	r16, 0x91	; 145
     79a:	19 e0       	ldi	r17, 0x09	; 9
     79c:	61 e0       	ldi	r22, 0x01	; 1
     79e:	89 91       	ld	r24, Y+
     7a0:	52 de       	rcall	.-860    	; 0x446 <write>
     7a2:	c0 17       	cp	r28, r16
     7a4:	d1 07       	cpc	r29, r17
     7a6:	d1 f7       	brne	.-12     	; 0x79c <nokia_lcd_render+0x18>
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	1f 91       	pop	r17
     7ae:	0f 91       	pop	r16
     7b0:	08 95       	ret

000007b2 <initUSART>:
     7b2:	81 30       	cpi	r24, 0x01	; 1
     7b4:	81 f0       	breq	.+32     	; 0x7d6 <initUSART+0x24>
     7b6:	e1 ec       	ldi	r30, 0xC1	; 193
     7b8:	f0 e0       	ldi	r31, 0x00	; 0
     7ba:	80 81       	ld	r24, Z
     7bc:	88 61       	ori	r24, 0x18	; 24
     7be:	80 83       	st	Z, r24
     7c0:	e2 ec       	ldi	r30, 0xC2	; 194
     7c2:	f0 e0       	ldi	r31, 0x00	; 0
     7c4:	80 81       	ld	r24, Z
     7c6:	86 60       	ori	r24, 0x06	; 6
     7c8:	80 83       	st	Z, r24
     7ca:	85 e0       	ldi	r24, 0x05	; 5
     7cc:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     7d0:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     7d4:	08 95       	ret
     7d6:	e9 ec       	ldi	r30, 0xC9	; 201
     7d8:	f0 e0       	ldi	r31, 0x00	; 0
     7da:	80 81       	ld	r24, Z
     7dc:	88 61       	ori	r24, 0x18	; 24
     7de:	80 83       	st	Z, r24
     7e0:	ea ec       	ldi	r30, 0xCA	; 202
     7e2:	f0 e0       	ldi	r31, 0x00	; 0
     7e4:	80 81       	ld	r24, Z
     7e6:	86 60       	ori	r24, 0x06	; 6
     7e8:	80 83       	st	Z, r24
     7ea:	85 e0       	ldi	r24, 0x05	; 5
     7ec:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
     7f0:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
     7f4:	08 95       	ret

000007f6 <USART_Flush>:
     7f6:	81 30       	cpi	r24, 0x01	; 1
     7f8:	29 f4       	brne	.+10     	; 0x804 <USART_Flush+0xe>
     7fa:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
     7fe:	88 23       	and	r24, r24
     800:	74 f0       	brlt	.+28     	; 0x81e <USART_Flush+0x28>
     802:	08 95       	ret
     804:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     808:	88 23       	and	r24, r24
     80a:	8c f4       	brge	.+34     	; 0x82e <USART_Flush+0x38>
     80c:	a6 ec       	ldi	r26, 0xC6	; 198
     80e:	b0 e0       	ldi	r27, 0x00	; 0
     810:	e0 ec       	ldi	r30, 0xC0	; 192
     812:	f0 e0       	ldi	r31, 0x00	; 0
     814:	8c 91       	ld	r24, X
     816:	80 81       	ld	r24, Z
     818:	88 23       	and	r24, r24
     81a:	e4 f3       	brlt	.-8      	; 0x814 <USART_Flush+0x1e>
     81c:	08 95       	ret
     81e:	ae ec       	ldi	r26, 0xCE	; 206
     820:	b0 e0       	ldi	r27, 0x00	; 0
     822:	e8 ec       	ldi	r30, 0xC8	; 200
     824:	f0 e0       	ldi	r31, 0x00	; 0
     826:	8c 91       	ld	r24, X
     828:	80 81       	ld	r24, Z
     82a:	88 23       	and	r24, r24
     82c:	e4 f3       	brlt	.-8      	; 0x826 <USART_Flush+0x30>
     82e:	08 95       	ret

00000830 <USART_Receive>:
     830:	81 30       	cpi	r24, 0x01	; 1
     832:	41 f0       	breq	.+16     	; 0x844 <USART_Receive+0x14>
     834:	e0 ec       	ldi	r30, 0xC0	; 192
     836:	f0 e0       	ldi	r31, 0x00	; 0
     838:	80 81       	ld	r24, Z
     83a:	88 23       	and	r24, r24
     83c:	ec f7       	brge	.-6      	; 0x838 <USART_Receive+0x8>
     83e:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     842:	08 95       	ret
     844:	e8 ec       	ldi	r30, 0xC8	; 200
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	80 81       	ld	r24, Z
     84a:	88 23       	and	r24, r24
     84c:	ec f7       	brge	.-6      	; 0x848 <USART_Receive+0x18>
     84e:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     852:	08 95       	ret

00000854 <Motor_Tick>:
}

void Motor_Tick()
{
     854:	cf 92       	push	r12
     856:	df 92       	push	r13
     858:	ef 92       	push	r14
     85a:	ff 92       	push	r15
     85c:	0f 93       	push	r16
     85e:	1f 93       	push	r17
     860:	cf 93       	push	r28
     862:	df 93       	push	r29
	char garage_button = (GetBit(~PIND, 3)); //if button is pressed then = 8
     864:	89 b1       	in	r24, 0x09	; 9
	return (bin_value ? pin | (0x01 << number) : pin & ~(0x01 << number));
}

unsigned char GetBit(unsigned char port, unsigned char number)
{
	return ( port & (0x01 << number) );
     866:	80 95       	com	r24
     868:	38 2f       	mov	r19, r24
     86a:	38 70       	andi	r19, 0x08	; 8
	char motion_sensor = (GetBit(~PIND, 2)); //if motion is sensed then = 4
     86c:	89 b1       	in	r24, 0x09	; 9
     86e:	80 95       	com	r24
     870:	28 2f       	mov	r18, r24
     872:	24 70       	andi	r18, 0x04	; 4
	switch(motor_state)
     874:	e0 91 ed 09 	lds	r30, 0x09ED	; 0x8009ed <motor_state>
     878:	8e 2f       	mov	r24, r30
     87a:	90 e0       	ldi	r25, 0x00	; 0
     87c:	8d 30       	cpi	r24, 0x0D	; 13
     87e:	91 05       	cpc	r25, r1
     880:	08 f0       	brcs	.+2      	; 0x884 <Motor_Tick+0x30>
     882:	e1 c0       	rjmp	.+450    	; 0xa46 <Motor_Tick+0x1f2>
     884:	fc 01       	movw	r30, r24
     886:	ea 5b       	subi	r30, 0xBA	; 186
     888:	ff 4f       	sbci	r31, 0xFF	; 255
     88a:	0c 94 f7 0c 	jmp	0x19ee	; 0x19ee <__tablejump2__>
	{	
		case READ_MOTION:
			if(motion_sensor == 4){motor_state = MENU;}
     88e:	24 30       	cpi	r18, 0x04	; 4
     890:	09 f0       	breq	.+2      	; 0x894 <Motor_Tick+0x40>
     892:	3d c3       	rjmp	.+1658   	; 0xf0e <Motor_Tick+0x6ba>
     894:	81 e0       	ldi	r24, 0x01	; 1
     896:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     89a:	45 c3       	rjmp	.+1674   	; 0xf26 <Motor_Tick+0x6d2>
			else if(motion_sensor == 0){motor_state = READ_MOTION;}
			break;
		
		case MENU:
			if(menu_check == 1){motor_state = READ_KEY_WAIT;}
     89c:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <menu_check>
     8a0:	81 30       	cpi	r24, 0x01	; 1
     8a2:	21 f4       	brne	.+8      	; 0x8ac <Motor_Tick+0x58>
     8a4:	82 e0       	ldi	r24, 0x02	; 2
     8a6:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     8aa:	87 c3       	rjmp	.+1806   	; 0xfba <Motor_Tick+0x766>
			else if(menu_check == 2){motor_state = CHANGE_PASS;}
     8ac:	82 30       	cpi	r24, 0x02	; 2
     8ae:	21 f4       	brne	.+8      	; 0x8b8 <Motor_Tick+0x64>
     8b0:	85 e0       	ldi	r24, 0x05	; 5
     8b2:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     8b6:	6f c3       	rjmp	.+1758   	; 0xf96 <Motor_Tick+0x742>
			else if(menu_check == 3){motor_state = CURRENT_PASS;}
     8b8:	83 30       	cpi	r24, 0x03	; 3
     8ba:	09 f0       	breq	.+2      	; 0x8be <Motor_Tick+0x6a>
     8bc:	34 c3       	rjmp	.+1640   	; 0xf26 <Motor_Tick+0x6d2>
     8be:	84 e0       	ldi	r24, 0x04	; 4
     8c0:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     8c4:	37 c3       	rjmp	.+1646   	; 0xf34 <Motor_Tick+0x6e0>
			else if(menu_check == 0){motor_state = MENU;}
			break;
			
		case READ_KEY_WAIT:
			if(cnt > 100){motor_state = READ_KEY_INIT; cnt = 0;}
     8c6:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <cnt>
     8ca:	85 36       	cpi	r24, 0x65	; 101
     8cc:	30 f0       	brcs	.+12     	; 0x8da <Motor_Tick+0x86>
     8ce:	83 e0       	ldi	r24, 0x03	; 3
     8d0:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     8d4:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <cnt>
     8d8:	02 c1       	rjmp	.+516    	; 0xade <Motor_Tick+0x28a>
			else{motor_state = READ_KEY_WAIT; cnt = cnt + 1;}
     8da:	8f 5f       	subi	r24, 0xFF	; 255
     8dc:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <cnt>
     8e0:	6c c3       	rjmp	.+1752   	; 0xfba <Motor_Tick+0x766>
			break;
			
		case READ_KEY_INIT:
			if((checker == 1) && (bt_check == 0)){motor_state = READ_KEY_WAIT_2;}
     8e2:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <checker>
     8e6:	81 30       	cpi	r24, 0x01	; 1
     8e8:	41 f4       	brne	.+16     	; 0x8fa <Motor_Tick+0xa6>
     8ea:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <bt_check>
     8ee:	81 11       	cpse	r24, r1
     8f0:	f6 c0       	rjmp	.+492    	; 0xade <Motor_Tick+0x28a>
     8f2:	86 e0       	ldi	r24, 0x06	; 6
     8f4:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     8f8:	60 c3       	rjmp	.+1728   	; 0xfba <Motor_Tick+0x766>
			else if((checker == 0) && (bt_check == 1)){motor_state = UNLOCK; lr = 2;}
     8fa:	81 11       	cpse	r24, r1
     8fc:	f0 c0       	rjmp	.+480    	; 0xade <Motor_Tick+0x28a>
     8fe:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <bt_check>
     902:	81 30       	cpi	r24, 0x01	; 1
     904:	09 f0       	breq	.+2      	; 0x908 <Motor_Tick+0xb4>
     906:	eb c0       	rjmp	.+470    	; 0xade <Motor_Tick+0x28a>
     908:	8c e0       	ldi	r24, 0x0C	; 12
     90a:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     90e:	82 e0       	ldi	r24, 0x02	; 2
     910:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <lr>
     914:	0f c2       	rjmp	.+1054   	; 0xd34 <Motor_Tick+0x4e0>
			else if((checker == 0) && (bt_check == 0)){motor_state = READ_KEY_INIT;}
			break;
			
		case CURRENT_PASS:
			if(cnt > 100){motor_state = MENU; cnt = 0;}
     916:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <cnt>
     91a:	85 36       	cpi	r24, 0x65	; 101
     91c:	30 f0       	brcs	.+12     	; 0x92a <Motor_Tick+0xd6>
     91e:	81 e0       	ldi	r24, 0x01	; 1
     920:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     924:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <cnt>
     928:	fe c2       	rjmp	.+1532   	; 0xf26 <Motor_Tick+0x6d2>
			else{motor_state = CURRENT_PASS; cnt = cnt + 1;}
     92a:	8f 5f       	subi	r24, 0xFF	; 255
     92c:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <cnt>
     930:	01 c3       	rjmp	.+1538   	; 0xf34 <Motor_Tick+0x6e0>
			break;
			
		case CHANGE_PASS:
			if(cnt > 100){motor_state = MENU; cnt = 0;}
     932:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <cnt>
     936:	85 36       	cpi	r24, 0x65	; 101
     938:	30 f0       	brcs	.+12     	; 0x946 <Motor_Tick+0xf2>
     93a:	81 e0       	ldi	r24, 0x01	; 1
     93c:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     940:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <cnt>
     944:	f0 c2       	rjmp	.+1504   	; 0xf26 <Motor_Tick+0x6d2>
			else{motor_state = CHANGE_PASS; cnt = cnt + 1;}
     946:	8f 5f       	subi	r24, 0xFF	; 255
     948:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <cnt>
     94c:	24 c3       	rjmp	.+1608   	; 0xf96 <Motor_Tick+0x742>
			break;
			
		case READ_KEY_WAIT_2:
			if(cnt > 200){motor_state = READ_KEY_INIT_2; cnt = 0;}
     94e:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <cnt>
     952:	89 3c       	cpi	r24, 0xC9	; 201
     954:	30 f0       	brcs	.+12     	; 0x962 <Motor_Tick+0x10e>
     956:	87 e0       	ldi	r24, 0x07	; 7
     958:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     95c:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <cnt>
     960:	fc c0       	rjmp	.+504    	; 0xb5a <Motor_Tick+0x306>
			else{motor_state = READ_KEY_WAIT_2; cnt = cnt + 1;}
     962:	8f 5f       	subi	r24, 0xFF	; 255
     964:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <cnt>
     968:	28 c3       	rjmp	.+1616   	; 0xfba <Motor_Tick+0x766>
			break;
			
		case READ_KEY_INIT_2:
			if((checker2 == 1) && (bt_check == 0)){motor_state = READ_KEY_WAIT_3;}
     96a:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <checker2>
     96e:	81 30       	cpi	r24, 0x01	; 1
     970:	41 f4       	brne	.+16     	; 0x982 <Motor_Tick+0x12e>
     972:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <bt_check>
     976:	81 11       	cpse	r24, r1
     978:	f0 c0       	rjmp	.+480    	; 0xb5a <Motor_Tick+0x306>
     97a:	88 e0       	ldi	r24, 0x08	; 8
     97c:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     980:	1c c3       	rjmp	.+1592   	; 0xfba <Motor_Tick+0x766>
			else if((checker2 == 0) && (bt_check == 1)){motor_state = UNLOCK; lr = 2;}
     982:	81 11       	cpse	r24, r1
     984:	ea c0       	rjmp	.+468    	; 0xb5a <Motor_Tick+0x306>
     986:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <bt_check>
     98a:	81 30       	cpi	r24, 0x01	; 1
     98c:	09 f0       	breq	.+2      	; 0x990 <Motor_Tick+0x13c>
     98e:	e5 c0       	rjmp	.+458    	; 0xb5a <Motor_Tick+0x306>
     990:	8c e0       	ldi	r24, 0x0C	; 12
     992:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     996:	82 e0       	ldi	r24, 0x02	; 2
     998:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <lr>
     99c:	cb c1       	rjmp	.+918    	; 0xd34 <Motor_Tick+0x4e0>
			else if((checker2 == 0) && (bt_check == 0)){motor_state = READ_KEY_INIT_2;}
			break;
			
		case READ_KEY_WAIT_3:
			if(cnt > 200){motor_state = READ_KEY_INIT_3; cnt = 0;}
     99e:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <cnt>
     9a2:	89 3c       	cpi	r24, 0xC9	; 201
     9a4:	30 f0       	brcs	.+12     	; 0x9b2 <Motor_Tick+0x15e>
     9a6:	89 e0       	ldi	r24, 0x09	; 9
     9a8:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     9ac:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <cnt>
     9b0:	20 c1       	rjmp	.+576    	; 0xbf2 <Motor_Tick+0x39e>
			else{motor_state = READ_KEY_WAIT_3; cnt = cnt + 1;}
     9b2:	8f 5f       	subi	r24, 0xFF	; 255
     9b4:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <cnt>
     9b8:	00 c3       	rjmp	.+1536   	; 0xfba <Motor_Tick+0x766>
			break;
			
		case READ_KEY_INIT_3:
			if((checker3 == 1) && (bt_check == 0)){motor_state = READ_KEY;}
     9ba:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <checker3>
     9be:	81 30       	cpi	r24, 0x01	; 1
     9c0:	41 f4       	brne	.+16     	; 0x9d2 <Motor_Tick+0x17e>
     9c2:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <bt_check>
     9c6:	81 11       	cpse	r24, r1
     9c8:	14 c1       	rjmp	.+552    	; 0xbf2 <Motor_Tick+0x39e>
     9ca:	8a e0       	ldi	r24, 0x0A	; 10
     9cc:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     9d0:	a2 c2       	rjmp	.+1348   	; 0xf16 <Motor_Tick+0x6c2>
			else if((checker3 == 0) && (bt_check == 1)){motor_state = UNLOCK; lr = 2;}
     9d2:	81 11       	cpse	r24, r1
     9d4:	0e c1       	rjmp	.+540    	; 0xbf2 <Motor_Tick+0x39e>
     9d6:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <bt_check>
     9da:	81 30       	cpi	r24, 0x01	; 1
     9dc:	09 f0       	breq	.+2      	; 0x9e0 <Motor_Tick+0x18c>
     9de:	09 c1       	rjmp	.+530    	; 0xbf2 <Motor_Tick+0x39e>
     9e0:	8c e0       	ldi	r24, 0x0C	; 12
     9e2:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     9e6:	82 e0       	ldi	r24, 0x02	; 2
     9e8:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <lr>
     9ec:	a3 c1       	rjmp	.+838    	; 0xd34 <Motor_Tick+0x4e0>
			else if((checker3 == 0) && (bt_check == 0)){motor_state = READ_KEY_INIT_3;}
			break;
			
		case READ_KEY:
			if (lr == 2){motor_state = UNLOCK;}
     9ee:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <lr>
     9f2:	82 30       	cpi	r24, 0x02	; 2
     9f4:	09 f0       	breq	.+2      	; 0x9f8 <Motor_Tick+0x1a4>
     9f6:	8f c2       	rjmp	.+1310   	; 0xf16 <Motor_Tick+0x6c2>
     9f8:	8c e0       	ldi	r24, 0x0C	; 12
     9fa:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     9fe:	9a c1       	rjmp	.+820    	; 0xd34 <Motor_Tick+0x4e0>
			else {motor_state = READ_KEY;}
			break;
		
		case UNLOCK:
			if(cnt > 200) {motor_state = LOCK; cnt = 0; motion_sensor = 0;}
     a00:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <cnt>
     a04:	89 3c       	cpi	r24, 0xC9	; 201
     a06:	30 f0       	brcs	.+12     	; 0xa14 <Motor_Tick+0x1c0>
     a08:	8b e0       	ldi	r24, 0x0B	; 11
     a0a:	80 93 ed 09 	sts	0x09ED, r24	; 0x8009ed <motor_state>
     a0e:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <cnt>
     a12:	ce c2       	rjmp	.+1436   	; 0xfb0 <Motor_Tick+0x75c>
			else {motor_state = UNLOCK; cnt = cnt + 1;}
     a14:	8f 5f       	subi	r24, 0xFF	; 255
     a16:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <cnt>
			}
			
			break;
		
		case UNLOCK:
			if(lr){
     a1a:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <lr>
     a1e:	88 23       	and	r24, r24
     a20:	09 f4       	brne	.+2      	; 0xa24 <Motor_Tick+0x1d0>
     a22:	a0 c1       	rjmp	.+832    	; 0xd64 <Motor_Tick+0x510>
     a24:	87 c1       	rjmp	.+782    	; 0xd34 <Motor_Tick+0x4e0>
			if(cnt > 200) {motor_state = LOCK; cnt = 0; motion_sensor = 0;}
			else {motor_state = UNLOCK; cnt = cnt + 1;}
			break;
			
		case LOCK:
			if(cnt > 200) {motor_state = READ_MOTION; cnt = 0; lr = 0; motion_sensor = 0;}
     a26:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <cnt>
     a2a:	89 3c       	cpi	r24, 0xC9	; 201
     a2c:	40 f0       	brcs	.+16     	; 0xa3e <Motor_Tick+0x1ea>
     a2e:	10 92 ed 09 	sts	0x09ED, r1	; 0x8009ed <motor_state>
     a32:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <cnt>
     a36:	10 92 91 07 	sts	0x0791, r1	; 0x800791 <lr>
			
			
	switch(motor_state)
	{
		case READ_MOTION:
			PORTD = SetBit(PORTD,4,0); //GARAGE LIGHT OFF
     a3a:	5c 98       	cbi	0x0b, 4	; 11
     a3c:	07 c0       	rjmp	.+14     	; 0xa4c <Motor_Tick+0x1f8>
			else {motor_state = UNLOCK; cnt = cnt + 1;}
			break;
			
		case LOCK:
			if(cnt > 200) {motor_state = READ_MOTION; cnt = 0; lr = 0; motion_sensor = 0;}
			else {motor_state = LOCK; cnt = cnt + 1;}
     a3e:	8f 5f       	subi	r24, 0xFF	; 255
     a40:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <cnt>
     a44:	b5 c2       	rjmp	.+1386   	; 0xfb0 <Motor_Tick+0x75c>
			break;
		
		default:
			motor_state = READ_MOTION;
     a46:	10 92 ed 09 	sts	0x09ED, r1	; 0x8009ed <motor_state>
	switch(motor_state)
	{
		case READ_MOTION:
			PORTD = SetBit(PORTD,4,0); //GARAGE LIGHT OFF
			if (motion_sensor == 0){
				nokia_lcd_clear();
     a4a:	61 c2       	rjmp	.+1218   	; 0xf0e <Motor_Tick+0x6ba>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     a4c:	a1 dd       	rcall	.-1214   	; 0x590 <nokia_lcd_clear>
     a4e:	01 e9       	ldi	r16, 0x91	; 145
     a50:	19 e0       	ldi	r17, 0x09	; 9
     a52:	83 e2       	ldi	r24, 0x23	; 35
     a54:	f8 01       	movw	r30, r16
    nokia_lcd.cursor_y = y;
     a56:	80 83       	st	Z, r24
     a58:	c2 e9       	ldi	r28, 0x92	; 146
     a5a:	d9 e0       	ldi	r29, 0x09	; 9
				nokia_lcd_set_cursor(35, 0);
				nokia_lcd_write_string("No", 2);
     a5c:	18 82       	st	Y, r1
     a5e:	62 e0       	ldi	r22, 0x02	; 2
     a60:	81 e1       	ldi	r24, 0x11	; 17
     a62:	91 e0       	ldi	r25, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     a64:	7d de       	rcall	.-774    	; 0x760 <nokia_lcd_write_string>
     a66:	8f e0       	ldi	r24, 0x0F	; 15
     a68:	f8 01       	movw	r30, r16
    nokia_lcd.cursor_y = y;
     a6a:	80 83       	st	Z, r24
     a6c:	84 e1       	ldi	r24, 0x14	; 20
				nokia_lcd_set_cursor(15, 20);
				nokia_lcd_write_string("Motion", 2);
     a6e:	88 83       	st	Y, r24
     a70:	62 e0       	ldi	r22, 0x02	; 2
     a72:	84 e1       	ldi	r24, 0x14	; 20
			}
			nokia_lcd_render();
     a74:	91 e0       	ldi	r25, 0x01	; 1
     a76:	74 de       	rcall	.-792    	; 0x760 <nokia_lcd_write_string>
			break;
     a78:	85 de       	rcall	.-758    	; 0x784 <nokia_lcd_render>
			
		case MENU:
			menu_key = GetKeypadKey();
			if ((menu_key == 'A')){
				menu_check = 1;
     a7a:	9f c2       	rjmp	.+1342   	; 0xfba <Motor_Tick+0x766>
     a7c:	81 e0       	ldi	r24, 0x01	; 1
     a7e:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <menu_check>
			}
			else if ((menu_key == 'B')){
     a82:	0e c0       	rjmp	.+28     	; 0xaa0 <Motor_Tick+0x24c>
     a84:	82 34       	cpi	r24, 0x42	; 66
				menu_check = 2;
     a86:	21 f4       	brne	.+8      	; 0xa90 <Motor_Tick+0x23c>
     a88:	82 e0       	ldi	r24, 0x02	; 2
     a8a:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <menu_check>
			}
			else if ((menu_key == 'C')){
     a8e:	08 c0       	rjmp	.+16     	; 0xaa0 <Motor_Tick+0x24c>
     a90:	83 34       	cpi	r24, 0x43	; 67
				menu_check = 3;
     a92:	21 f4       	brne	.+8      	; 0xa9c <Motor_Tick+0x248>
     a94:	83 e0       	ldi	r24, 0x03	; 3
     a96:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <menu_check>
			}
			else{
				menu_check = 0;
     a9a:	02 c0       	rjmp	.+4      	; 0xaa0 <Motor_Tick+0x24c>
			}
			nokia_lcd_clear();
     a9c:	10 92 95 07 	sts	0x0795, r1	; 0x800795 <menu_check>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     aa0:	77 dd       	rcall	.-1298   	; 0x590 <nokia_lcd_clear>
     aa2:	01 e9       	ldi	r16, 0x91	; 145
     aa4:	19 e0       	ldi	r17, 0x09	; 9
     aa6:	f8 01       	movw	r30, r16
    nokia_lcd.cursor_y = y;
     aa8:	10 82       	st	Z, r1
     aaa:	c2 e9       	ldi	r28, 0x92	; 146
     aac:	d9 e0       	ldi	r29, 0x09	; 9
			nokia_lcd_set_cursor(0, 10);
			nokia_lcd_write_string("A-enter code", 1);
     aae:	8a e0       	ldi	r24, 0x0A	; 10
     ab0:	88 83       	st	Y, r24
     ab2:	61 e0       	ldi	r22, 0x01	; 1
     ab4:	8b e1       	ldi	r24, 0x1B	; 27
     ab6:	91 e0       	ldi	r25, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ab8:	53 de       	rcall	.-858    	; 0x760 <nokia_lcd_write_string>
    nokia_lcd.cursor_y = y;
     aba:	f8 01       	movw	r30, r16
     abc:	10 82       	st	Z, r1
			nokia_lcd_set_cursor(0, 20);
			nokia_lcd_write_string("B-change code", 1);
     abe:	84 e1       	ldi	r24, 0x14	; 20
     ac0:	88 83       	st	Y, r24
     ac2:	61 e0       	ldi	r22, 0x01	; 1
     ac4:	88 e2       	ldi	r24, 0x28	; 40
     ac6:	91 e0       	ldi	r25, 0x01	; 1
     ac8:	4b de       	rcall	.-874    	; 0x760 <nokia_lcd_write_string>
			nokia_lcd_set_cursor(0, 30);
			nokia_lcd_write_string("C-check code", 1);
     aca:	f8 01       	movw	r30, r16
     acc:	10 82       	st	Z, r1
     ace:	8e e1       	ldi	r24, 0x1E	; 30
     ad0:	88 83       	st	Y, r24
     ad2:	61 e0       	ldi	r22, 0x01	; 1
			nokia_lcd_render();
     ad4:	86 e3       	ldi	r24, 0x36	; 54
//Functionality - checks if USART has recieved data
//Parameter: usartNum specifies which USART is checked
//Returns: 1 if true else 0
unsigned char USART_HasReceived(unsigned char usartNum)
{
	return (usartNum != 1) ? (UCSR0A & (1 << RXC0)) : (UCSR1A & (1 << RXC1));
     ad6:	91 e0       	ldi	r25, 0x01	; 1
     ad8:	43 de       	rcall	.-890    	; 0x760 <nokia_lcd_write_string>
			
		case READ_KEY_WAIT:
			break;	
			
		case READ_KEY_INIT:
			if((USART_HasReceived(0))){
     ada:	54 de       	rcall	.-856    	; 0x784 <nokia_lcd_render>
				bt_check = 1;
     adc:	6e c2       	rjmp	.+1244   	; 0xfba <Motor_Tick+0x766>
     ade:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
				key = USART_Receive(0);
     ae2:	88 23       	and	r24, r24
     ae4:	54 f4       	brge	.+20     	; 0xafa <Motor_Tick+0x2a6>
     ae6:	81 e0       	ldi	r24, 0x01	; 1
				USART_Flush(0);
     ae8:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <bt_check>
     aec:	80 e0       	ldi	r24, 0x00	; 0
     aee:	a0 de       	rcall	.-704    	; 0x830 <USART_Receive>
			}
			else{
				bt_check = 0;
     af0:	80 93 ee 09 	sts	0x09EE, r24	; 0x8009ee <key>
				key = GetKeypadKey();
     af4:	80 e0       	ldi	r24, 0x00	; 0
     af6:	7f de       	rcall	.-770    	; 0x7f6 <USART_Flush>
				if ((key != '\0')){
     af8:	0d c0       	rjmp	.+26     	; 0xb14 <Motor_Tick+0x2c0>
     afa:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <bt_check>
					checker = 1;
     afe:	c4 dc       	rcall	.-1656   	; 0x488 <GetKeypadKey>
     b00:	80 93 ee 09 	sts	0x09EE, r24	; 0x8009ee <key>
				}
				else{
					checker = 0;
     b04:	88 23       	and	r24, r24
     b06:	21 f0       	breq	.+8      	; 0xb10 <Motor_Tick+0x2bc>
				}
			}
				
			nokia_lcd_clear();
     b08:	81 e0       	ldi	r24, 0x01	; 1
     b0a:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <checker>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     b0e:	02 c0       	rjmp	.+4      	; 0xb14 <Motor_Tick+0x2c0>
     b10:	10 92 94 07 	sts	0x0794, r1	; 0x800794 <checker>
     b14:	3d dd       	rcall	.-1414   	; 0x590 <nokia_lcd_clear>
     b16:	0f 2e       	mov	r0, r31
     b18:	f1 e9       	ldi	r31, 0x91	; 145
     b1a:	ef 2e       	mov	r14, r31
    nokia_lcd.cursor_y = y;
     b1c:	f9 e0       	ldi	r31, 0x09	; 9
     b1e:	ff 2e       	mov	r15, r31
			nokia_lcd_set_cursor(30, 0);
			nokia_lcd_write_string("CODE?", 1);
     b20:	f0 2d       	mov	r31, r0
     b22:	1e e1       	ldi	r17, 0x1E	; 30
     b24:	f7 01       	movw	r30, r14
     b26:	10 83       	st	Z, r17
     b28:	c2 e9       	ldi	r28, 0x92	; 146
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     b2a:	d9 e0       	ldi	r29, 0x09	; 9
    nokia_lcd.cursor_y = y;
     b2c:	18 82       	st	Y, r1
			nokia_lcd_set_cursor(10, 30);
			
			nokia_lcd_write_string("Entry: ", 1);
     b2e:	61 e0       	ldi	r22, 0x01	; 1
     b30:	8f e4       	ldi	r24, 0x4F	; 79
     b32:	91 e0       	ldi	r25, 0x01	; 1
     b34:	15 de       	rcall	.-982    	; 0x760 <nokia_lcd_write_string>
     b36:	8a e0       	ldi	r24, 0x0A	; 10
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     b38:	f7 01       	movw	r30, r14
     b3a:	80 83       	st	Z, r24
			nokia_lcd_set_cursor(50, 30);
			nokia_lcd_write_char(key, 1);
     b3c:	18 83       	st	Y, r17
     b3e:	61 e0       	ldi	r22, 0x01	; 1
     b40:	83 e4       	ldi	r24, 0x43	; 67
     b42:	91 e0       	ldi	r25, 0x01	; 1
			nokia_lcd_render();
     b44:	0d de       	rcall	.-998    	; 0x760 <nokia_lcd_write_string>
     b46:	82 e3       	ldi	r24, 0x32	; 50
			break;
     b48:	f7 01       	movw	r30, r14
     b4a:	80 83       	st	Z, r24
     b4c:	18 83       	st	Y, r17
			
		case READ_KEY_WAIT_2:
			break;
			
		case READ_KEY_INIT_2:
			if((USART_HasReceived(0))){
     b4e:	61 e0       	ldi	r22, 0x01	; 1
				bt_check = 1;
     b50:	80 91 ee 09 	lds	r24, 0x09EE	; 0x8009ee <key>
     b54:	59 dd       	rcall	.-1358   	; 0x608 <nokia_lcd_write_char>
				key2 = USART_Receive(0);
     b56:	16 de       	rcall	.-980    	; 0x784 <nokia_lcd_render>
     b58:	30 c2       	rjmp	.+1120   	; 0xfba <Motor_Tick+0x766>
     b5a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     b5e:	88 23       	and	r24, r24
				USART_Flush(0);
     b60:	54 f4       	brge	.+20     	; 0xb76 <Motor_Tick+0x322>
     b62:	81 e0       	ldi	r24, 0x01	; 1
     b64:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <bt_check>
			}
			else{
				
				if(bt_check == 1){bt_check = 1;}
     b68:	80 e0       	ldi	r24, 0x00	; 0
     b6a:	62 de       	rcall	.-828    	; 0x830 <USART_Receive>
     b6c:	80 93 f0 09 	sts	0x09F0, r24	; 0x8009f0 <key2>
				else{bt_check = 0;}
     b70:	80 e0       	ldi	r24, 0x00	; 0
					
				key2 = GetKeypadKey();
     b72:	41 de       	rcall	.-894    	; 0x7f6 <USART_Flush>
     b74:	11 c0       	rjmp	.+34     	; 0xb98 <Motor_Tick+0x344>
     b76:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <bt_check>
				if ((key2 != '\0')){
     b7a:	81 30       	cpi	r24, 0x01	; 1
     b7c:	11 f0       	breq	.+4      	; 0xb82 <Motor_Tick+0x32e>
					checker2 = 1;
     b7e:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <bt_check>
     b82:	82 dc       	rcall	.-1788   	; 0x488 <GetKeypadKey>
				}
				else{
					checker2 = 0;
     b84:	80 93 f0 09 	sts	0x09F0, r24	; 0x8009f0 <key2>
				}
			}
			
			nokia_lcd_clear();
     b88:	88 23       	and	r24, r24
     b8a:	21 f0       	breq	.+8      	; 0xb94 <Motor_Tick+0x340>
     b8c:	81 e0       	ldi	r24, 0x01	; 1
     b8e:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <checker2>
     b92:	02 c0       	rjmp	.+4      	; 0xb98 <Motor_Tick+0x344>
     b94:	10 92 93 07 	sts	0x0793, r1	; 0x800793 <checker2>
     b98:	fb dc       	rcall	.-1546   	; 0x590 <nokia_lcd_clear>
    nokia_lcd.cursor_y = y;
     b9a:	01 e9       	ldi	r16, 0x91	; 145
     b9c:	19 e0       	ldi	r17, 0x09	; 9
     b9e:	0f 2e       	mov	r0, r31
			nokia_lcd_set_cursor(10, 0);
			nokia_lcd_write_string("PASSCODE?", 1);
     ba0:	fa e0       	ldi	r31, 0x0A	; 10
     ba2:	ff 2e       	mov	r15, r31
     ba4:	f0 2d       	mov	r31, r0
     ba6:	f8 01       	movw	r30, r16
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ba8:	f0 82       	st	Z, r15
     baa:	c2 e9       	ldi	r28, 0x92	; 146
    nokia_lcd.cursor_y = y;
     bac:	d9 e0       	ldi	r29, 0x09	; 9
     bae:	18 82       	st	Y, r1
     bb0:	61 e0       	ldi	r22, 0x01	; 1
			
			nokia_lcd_set_cursor(10, 30);
			nokia_lcd_write_string("Entry: ", 1);
     bb2:	8b e4       	ldi	r24, 0x4B	; 75
     bb4:	91 e0       	ldi	r25, 0x01	; 1
     bb6:	d4 dd       	rcall	.-1112   	; 0x760 <nokia_lcd_write_string>
     bb8:	f8 01       	movw	r30, r16
     bba:	f0 82       	st	Z, r15
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     bbc:	0f 2e       	mov	r0, r31
     bbe:	fe e1       	ldi	r31, 0x1E	; 30
			nokia_lcd_set_cursor(50, 30);
			nokia_lcd_write_char(key, 1);
     bc0:	ff 2e       	mov	r15, r31
     bc2:	f0 2d       	mov	r31, r0
     bc4:	f8 82       	st	Y, r15
     bc6:	61 e0       	ldi	r22, 0x01	; 1
     bc8:	83 e4       	ldi	r24, 0x43	; 67
     bca:	91 e0       	ldi	r25, 0x01	; 1
     bcc:	c9 dd       	rcall	.-1134   	; 0x760 <nokia_lcd_write_string>
    nokia_lcd.cursor_y = y;
     bce:	82 e3       	ldi	r24, 0x32	; 50
			nokia_lcd_set_cursor(60, 30);
			nokia_lcd_write_char(key2, 1);
     bd0:	f8 01       	movw	r30, r16
     bd2:	80 83       	st	Z, r24
     bd4:	f8 82       	st	Y, r15
     bd6:	61 e0       	ldi	r22, 0x01	; 1
			nokia_lcd_render();
     bd8:	80 91 ee 09 	lds	r24, 0x09EE	; 0x8009ee <key>
			break;
     bdc:	15 dd       	rcall	.-1494   	; 0x608 <nokia_lcd_write_char>
     bde:	8c e3       	ldi	r24, 0x3C	; 60
     be0:	f8 01       	movw	r30, r16
			
		case READ_KEY_WAIT_3:
			break;
		
		case READ_KEY_INIT_3:
			if((USART_HasReceived(0))){
     be2:	80 83       	st	Z, r24
     be4:	f8 82       	st	Y, r15
				bt_check = 1;
     be6:	61 e0       	ldi	r22, 0x01	; 1
     be8:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <key2>
				key3 = USART_Receive(0);
     bec:	0d dd       	rcall	.-1510   	; 0x608 <nokia_lcd_write_char>
     bee:	ca dd       	rcall	.-1132   	; 0x784 <nokia_lcd_render>
     bf0:	e4 c1       	rjmp	.+968    	; 0xfba <Motor_Tick+0x766>
     bf2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
				USART_Flush(0);
     bf6:	88 23       	and	r24, r24
     bf8:	54 f4       	brge	.+20     	; 0xc0e <Motor_Tick+0x3ba>
     bfa:	81 e0       	ldi	r24, 0x01	; 1
			}
			else{
			
				if(bt_check == 1){bt_check = 1;}
     bfc:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <bt_check>
     c00:	80 e0       	ldi	r24, 0x00	; 0
				else{bt_check = 0;}
     c02:	16 de       	rcall	.-980    	; 0x830 <USART_Receive>
			
				key3 = GetKeypadKey();
     c04:	80 93 ef 09 	sts	0x09EF, r24	; 0x8009ef <key3>
     c08:	80 e0       	ldi	r24, 0x00	; 0
     c0a:	f5 dd       	rcall	.-1046   	; 0x7f6 <USART_Flush>
				if ((key3 != '\0')){
     c0c:	11 c0       	rjmp	.+34     	; 0xc30 <Motor_Tick+0x3dc>
     c0e:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <bt_check>
					checker3 = 1;
     c12:	81 30       	cpi	r24, 0x01	; 1
     c14:	11 f0       	breq	.+4      	; 0xc1a <Motor_Tick+0x3c6>
				}
				else{
					checker3 = 0;
     c16:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <bt_check>
				}
			}
		
			nokia_lcd_clear();
     c1a:	36 dc       	rcall	.-1940   	; 0x488 <GetKeypadKey>
     c1c:	80 93 ef 09 	sts	0x09EF, r24	; 0x8009ef <key3>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     c20:	88 23       	and	r24, r24
     c22:	21 f0       	breq	.+8      	; 0xc2c <Motor_Tick+0x3d8>
     c24:	81 e0       	ldi	r24, 0x01	; 1
     c26:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <checker3>
     c2a:	02 c0       	rjmp	.+4      	; 0xc30 <Motor_Tick+0x3dc>
    nokia_lcd.cursor_y = y;
     c2c:	10 92 92 07 	sts	0x0792, r1	; 0x800792 <checker3>
			nokia_lcd_set_cursor(10, 0);
			nokia_lcd_write_string("PASSCODE?", 1);
     c30:	af dc       	rcall	.-1698   	; 0x590 <nokia_lcd_clear>
     c32:	01 e9       	ldi	r16, 0x91	; 145
     c34:	19 e0       	ldi	r17, 0x09	; 9
     c36:	0f 2e       	mov	r0, r31
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     c38:	fa e0       	ldi	r31, 0x0A	; 10
     c3a:	ff 2e       	mov	r15, r31
    nokia_lcd.cursor_y = y;
     c3c:	f0 2d       	mov	r31, r0
     c3e:	f8 01       	movw	r30, r16
     c40:	f0 82       	st	Z, r15
		
			nokia_lcd_set_cursor(10, 30);
			nokia_lcd_write_string("Entry: ", 1);
     c42:	c2 e9       	ldi	r28, 0x92	; 146
     c44:	d9 e0       	ldi	r29, 0x09	; 9
     c46:	18 82       	st	Y, r1
     c48:	61 e0       	ldi	r22, 0x01	; 1
     c4a:	8b e4       	ldi	r24, 0x4B	; 75
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     c4c:	91 e0       	ldi	r25, 0x01	; 1
     c4e:	88 dd       	rcall	.-1264   	; 0x760 <nokia_lcd_write_string>
     c50:	f8 01       	movw	r30, r16
    nokia_lcd.cursor_y = y;
     c52:	f0 82       	st	Z, r15
			nokia_lcd_set_cursor(50, 30);
			nokia_lcd_write_char(key, 1);
     c54:	0f 2e       	mov	r0, r31
     c56:	fe e1       	ldi	r31, 0x1E	; 30
     c58:	ff 2e       	mov	r15, r31
     c5a:	f0 2d       	mov	r31, r0
     c5c:	f8 82       	st	Y, r15
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     c5e:	61 e0       	ldi	r22, 0x01	; 1
     c60:	83 e4       	ldi	r24, 0x43	; 67
    nokia_lcd.cursor_y = y;
     c62:	91 e0       	ldi	r25, 0x01	; 1
			nokia_lcd_set_cursor(60, 30);
			nokia_lcd_write_char(key2, 1);
     c64:	7d dd       	rcall	.-1286   	; 0x760 <nokia_lcd_write_string>
     c66:	82 e3       	ldi	r24, 0x32	; 50
     c68:	f8 01       	movw	r30, r16
     c6a:	80 83       	st	Z, r24
     c6c:	f8 82       	st	Y, r15
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     c6e:	61 e0       	ldi	r22, 0x01	; 1
     c70:	80 91 ee 09 	lds	r24, 0x09EE	; 0x8009ee <key>
    nokia_lcd.cursor_y = y;
     c74:	c9 dc       	rcall	.-1646   	; 0x608 <nokia_lcd_write_char>
			nokia_lcd_set_cursor(70, 30);
			nokia_lcd_write_char(key3, 1);
     c76:	8c e3       	ldi	r24, 0x3C	; 60
     c78:	f8 01       	movw	r30, r16
     c7a:	80 83       	st	Z, r24
     c7c:	f8 82       	st	Y, r15
			nokia_lcd_render();
     c7e:	61 e0       	ldi	r22, 0x01	; 1
     c80:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <key2>
			break;
			
			
		case READ_KEY:
			if((key == passwordarray[0]) && (key2 == passwordarray[1]) && (key3 == passwordarray[2])){ //LOCK = 1 2
     c84:	c1 dc       	rcall	.-1662   	; 0x608 <nokia_lcd_write_char>
     c86:	86 e4       	ldi	r24, 0x46	; 70
     c88:	f8 01       	movw	r30, r16
     c8a:	80 83       	st	Z, r24
     c8c:	f8 82       	st	Y, r15
     c8e:	61 e0       	ldi	r22, 0x01	; 1
     c90:	80 91 ef 09 	lds	r24, 0x09EF	; 0x8009ef <key3>
     c94:	b9 dc       	rcall	.-1678   	; 0x608 <nokia_lcd_write_char>
     c96:	76 dd       	rcall	.-1300   	; 0x784 <nokia_lcd_render>
     c98:	90 c1       	rjmp	.+800    	; 0xfba <Motor_Tick+0x766>
				lr = 2;
     c9a:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     c9e:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <key2>
			}
			else{
				nokia_lcd_clear();
     ca2:	98 13       	cpse	r25, r24
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ca4:	0a c0       	rjmp	.+20     	; 0xcba <Motor_Tick+0x466>
     ca6:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__data_start+0x2>
    nokia_lcd.cursor_y = y;
     caa:	80 91 ef 09 	lds	r24, 0x09EF	; 0x8009ef <key3>
     cae:	98 13       	cpse	r25, r24
     cb0:	04 c0       	rjmp	.+8      	; 0xcba <Motor_Tick+0x466>
     cb2:	82 e0       	ldi	r24, 0x02	; 2
     cb4:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <lr>
				nokia_lcd_set_cursor(0, 10);
				nokia_lcd_write_string("WRONG PASSWORD", 1);
     cb8:	80 c1       	rjmp	.+768    	; 0xfba <Motor_Tick+0x766>
     cba:	6a dc       	rcall	.-1836   	; 0x590 <nokia_lcd_clear>
     cbc:	01 e9       	ldi	r16, 0x91	; 145
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     cbe:	19 e0       	ldi	r17, 0x09	; 9
     cc0:	f8 01       	movw	r30, r16
    nokia_lcd.cursor_y = y;
     cc2:	10 82       	st	Z, r1
				nokia_lcd_set_cursor(0, 20);
				nokia_lcd_write_string("RESTART BOARD", 1);
     cc4:	c2 e9       	ldi	r28, 0x92	; 146
     cc6:	d9 e0       	ldi	r29, 0x09	; 9
     cc8:	0f 2e       	mov	r0, r31
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     cca:	fa e0       	ldi	r31, 0x0A	; 10
     ccc:	ff 2e       	mov	r15, r31
    nokia_lcd.cursor_y = y;
     cce:	f0 2d       	mov	r31, r0
     cd0:	f8 82       	st	Y, r15
     cd2:	61 e0       	ldi	r22, 0x01	; 1
     cd4:	85 e5       	ldi	r24, 0x55	; 85
     cd6:	91 e0       	ldi	r25, 0x01	; 1
				nokia_lcd_set_cursor(10, 30);
				nokia_lcd_write_string("Entry: ", 1);
     cd8:	43 dd       	rcall	.-1402   	; 0x760 <nokia_lcd_write_string>
     cda:	f8 01       	movw	r30, r16
     cdc:	10 82       	st	Z, r1
     cde:	84 e1       	ldi	r24, 0x14	; 20
     ce0:	88 83       	st	Y, r24
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ce2:	61 e0       	ldi	r22, 0x01	; 1
     ce4:	84 e6       	ldi	r24, 0x64	; 100
     ce6:	91 e0       	ldi	r25, 0x01	; 1
    nokia_lcd.cursor_y = y;
     ce8:	3b dd       	rcall	.-1418   	; 0x760 <nokia_lcd_write_string>
				nokia_lcd_set_cursor(50, 30);
				nokia_lcd_write_char(key, 1);
     cea:	f8 01       	movw	r30, r16
     cec:	f0 82       	st	Z, r15
     cee:	0f 2e       	mov	r0, r31
     cf0:	fe e1       	ldi	r31, 0x1E	; 30
     cf2:	ff 2e       	mov	r15, r31
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     cf4:	f0 2d       	mov	r31, r0
     cf6:	f8 82       	st	Y, r15
     cf8:	61 e0       	ldi	r22, 0x01	; 1
    nokia_lcd.cursor_y = y;
     cfa:	83 e4       	ldi	r24, 0x43	; 67
				nokia_lcd_set_cursor(60, 30);
				nokia_lcd_write_char(key2, 1);
     cfc:	91 e0       	ldi	r25, 0x01	; 1
     cfe:	30 dd       	rcall	.-1440   	; 0x760 <nokia_lcd_write_string>
     d00:	82 e3       	ldi	r24, 0x32	; 50
     d02:	f8 01       	movw	r30, r16
     d04:	80 83       	st	Z, r24
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     d06:	f8 82       	st	Y, r15
     d08:	61 e0       	ldi	r22, 0x01	; 1
     d0a:	80 91 ee 09 	lds	r24, 0x09EE	; 0x8009ee <key>
				nokia_lcd_set_cursor(70, 30);
				nokia_lcd_write_char(key3, 1);
     d0e:	7c dc       	rcall	.-1800   	; 0x608 <nokia_lcd_write_char>
     d10:	8c e3       	ldi	r24, 0x3C	; 60
     d12:	f8 01       	movw	r30, r16
     d14:	80 83       	st	Z, r24
     d16:	f8 82       	st	Y, r15
				nokia_lcd_render();
     d18:	61 e0       	ldi	r22, 0x01	; 1
     d1a:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <key2>
			
			break;
		
		case UNLOCK:
			if(lr){
				if (temp < 7) {temp = temp + 1;}
     d1e:	74 dc       	rcall	.-1816   	; 0x608 <nokia_lcd_write_char>
     d20:	86 e4       	ldi	r24, 0x46	; 70
     d22:	f8 01       	movw	r30, r16
     d24:	80 83       	st	Z, r24
     d26:	f8 82       	st	Y, r15
     d28:	61 e0       	ldi	r22, 0x01	; 1
     d2a:	80 91 ef 09 	lds	r24, 0x09EF	; 0x8009ef <key3>
				else {temp = 0;}
     d2e:	6c dc       	rcall	.-1832   	; 0x608 <nokia_lcd_write_char>
			
				if((numPhases - 1) == 0)
     d30:	29 dd       	rcall	.-1454   	; 0x784 <nokia_lcd_render>
     d32:	43 c1       	rjmp	.+646    	; 0xfba <Motor_Tick+0x766>
     d34:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <temp>
     d38:	87 30       	cpi	r24, 0x07	; 7
     d3a:	20 f4       	brcc	.+8      	; 0xd44 <Motor_Tick+0x4f0>
     d3c:	8f 5f       	subi	r24, 0xFF	; 255
     d3e:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <temp>
     d42:	02 c0       	rjmp	.+4      	; 0xd48 <Motor_Tick+0x4f4>
     d44:	10 92 98 07 	sts	0x0798, r1	; 0x800798 <temp>
				{
					lr = 0;
     d48:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <numPhases>
				}
			} 
			if(garage_button == 8){PORTA = (loc[temp] << 4); PORTD = ((0x01 << 4) | PORTD); room = 2;}
     d4c:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <numPhases+0x1>
     d50:	a0 91 05 01 	lds	r26, 0x0105	; 0x800105 <numPhases+0x2>
     d54:	b0 91 06 01 	lds	r27, 0x0106	; 0x800106 <numPhases+0x3>
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	a1 05       	cpc	r26, r1
     d5c:	b1 05       	cpc	r27, r1
     d5e:	11 f4       	brne	.+4      	; 0xd64 <Motor_Tick+0x510>
     d60:	10 92 91 07 	sts	0x0791, r1	; 0x800791 <lr>
     d64:	38 30       	cpi	r19, 0x08	; 8
			else{PORTA = loc[temp]; PORTD = SetBit(PORTD,4,0); room = 1;}
     d66:	71 f4       	brne	.+28     	; 0xd84 <Motor_Tick+0x530>
     d68:	e0 91 98 07 	lds	r30, 0x0798	; 0x800798 <temp>
     d6c:	f0 e0       	ldi	r31, 0x00	; 0
     d6e:	e9 5f       	subi	r30, 0xF9	; 249
     d70:	fe 4f       	sbci	r31, 0xFE	; 254
     d72:	80 81       	ld	r24, Z
     d74:	82 95       	swap	r24
     d76:	80 7f       	andi	r24, 0xF0	; 240
     d78:	82 b9       	out	0x02, r24	; 2
				
			nokia_lcd_clear();
     d7a:	5c 9a       	sbi	0x0b, 4	; 11
     d7c:	82 e0       	ldi	r24, 0x02	; 2
     d7e:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <room>
     d82:	0b c0       	rjmp	.+22     	; 0xd9a <Motor_Tick+0x546>
     d84:	e0 91 98 07 	lds	r30, 0x0798	; 0x800798 <temp>
     d88:	f0 e0       	ldi	r31, 0x00	; 0
     d8a:	e9 5f       	subi	r30, 0xF9	; 249
     d8c:	fe 4f       	sbci	r31, 0xFE	; 254
    nokia_lcd.cursor_y = y;
     d8e:	80 81       	ld	r24, Z
     d90:	82 b9       	out	0x02, r24	; 2
     d92:	5c 98       	cbi	0x0b, 4	; 11
			nokia_lcd_set_cursor(10, 10);
			nokia_lcd_write_string("UNLOCKING!", 1);
     d94:	81 e0       	ldi	r24, 0x01	; 1
     d96:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <room>
     d9a:	fa db       	rcall	.-2060   	; 0x590 <nokia_lcd_clear>
     d9c:	0f 2e       	mov	r0, r31
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     d9e:	f1 e9       	ldi	r31, 0x91	; 145
     da0:	ef 2e       	mov	r14, r31
    nokia_lcd.cursor_y = y;
     da2:	f9 e0       	ldi	r31, 0x09	; 9
     da4:	ff 2e       	mov	r15, r31
			nokia_lcd_set_cursor(10, 30);
			nokia_lcd_write_string("Entry: ", 1);
     da6:	f0 2d       	mov	r31, r0
     da8:	ca e0       	ldi	r28, 0x0A	; 10
     daa:	f7 01       	movw	r30, r14
     dac:	c0 83       	st	Z, r28
     dae:	02 e9       	ldi	r16, 0x92	; 146
			if(bt_check == 0){
     db0:	19 e0       	ldi	r17, 0x09	; 9
     db2:	f8 01       	movw	r30, r16
     db4:	c0 83       	st	Z, r28
     db6:	61 e0       	ldi	r22, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     db8:	82 e7       	ldi	r24, 0x72	; 114
     dba:	91 e0       	ldi	r25, 0x01	; 1
     dbc:	d1 dc       	rcall	.-1630   	; 0x760 <nokia_lcd_write_string>
    nokia_lcd.cursor_y = y;
     dbe:	f7 01       	movw	r30, r14
     dc0:	c0 83       	st	Z, r28
				nokia_lcd_set_cursor(50, 30);
				nokia_lcd_write_char(key, 1);
     dc2:	8e e1       	ldi	r24, 0x1E	; 30
     dc4:	f8 01       	movw	r30, r16
     dc6:	80 83       	st	Z, r24
     dc8:	61 e0       	ldi	r22, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     dca:	83 e4       	ldi	r24, 0x43	; 67
     dcc:	91 e0       	ldi	r25, 0x01	; 1
     dce:	c8 dc       	rcall	.-1648   	; 0x760 <nokia_lcd_write_string>
				nokia_lcd_set_cursor(60, 30);
				nokia_lcd_write_char(key2, 1);
     dd0:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <bt_check>
     dd4:	81 11       	cpse	r24, r1
     dd6:	1b c0       	rjmp	.+54     	; 0xe0e <Motor_Tick+0x5ba>
     dd8:	82 e3       	ldi	r24, 0x32	; 50
     dda:	f7 01       	movw	r30, r14
    nokia_lcd.cursor_y = y;
     ddc:	80 83       	st	Z, r24
				nokia_lcd_set_cursor(70, 30);
				nokia_lcd_write_char(key3, 1);
     dde:	e8 01       	movw	r28, r16
     de0:	1e e1       	ldi	r17, 0x1E	; 30
     de2:	18 83       	st	Y, r17
     de4:	61 e0       	ldi	r22, 0x01	; 1
     de6:	80 91 ee 09 	lds	r24, 0x09EE	; 0x8009ee <key>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     dea:	0e dc       	rcall	.-2020   	; 0x608 <nokia_lcd_write_char>
     dec:	8c e3       	ldi	r24, 0x3C	; 60
     dee:	f7 01       	movw	r30, r14
    nokia_lcd.cursor_y = y;
     df0:	80 83       	st	Z, r24
     df2:	18 83       	st	Y, r17
     df4:	61 e0       	ldi	r22, 0x01	; 1
			}
			else{
				nokia_lcd_set_cursor(50, 30);
				nokia_lcd_write_string("Phone", 1);
     df6:	80 91 f0 09 	lds	r24, 0x09F0	; 0x8009f0 <key2>
     dfa:	06 dc       	rcall	.-2036   	; 0x608 <nokia_lcd_write_char>
     dfc:	86 e4       	ldi	r24, 0x46	; 70
     dfe:	f7 01       	movw	r30, r14
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     e00:	80 83       	st	Z, r24
     e02:	18 83       	st	Y, r17
     e04:	61 e0       	ldi	r22, 0x01	; 1
     e06:	80 91 ef 09 	lds	r24, 0x09EF	; 0x8009ef <key3>
     e0a:	fe db       	rcall	.-2052   	; 0x608 <nokia_lcd_write_char>
     e0c:	0a c0       	rjmp	.+20     	; 0xe22 <Motor_Tick+0x5ce>
     e0e:	82 e3       	ldi	r24, 0x32	; 50
     e10:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <nokia_lcd+0x1f8>
    nokia_lcd.cursor_y = y;
     e14:	8e e1       	ldi	r24, 0x1E	; 30
     e16:	80 93 92 09 	sts	0x0992, r24	; 0x800992 <nokia_lcd+0x1f9>
			}
			nokia_lcd_set_cursor(10, 40);
			nokia_lcd_write_string("Room: ", 1);
     e1a:	61 e0       	ldi	r22, 0x01	; 1
     e1c:	8d e7       	ldi	r24, 0x7D	; 125
     e1e:	91 e0       	ldi	r25, 0x01	; 1
     e20:	9f dc       	rcall	.-1730   	; 0x760 <nokia_lcd_write_string>
     e22:	0f 2e       	mov	r0, r31
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     e24:	f1 e9       	ldi	r31, 0x91	; 145
     e26:	ef 2e       	mov	r14, r31
     e28:	f9 e0       	ldi	r31, 0x09	; 9
    nokia_lcd.cursor_y = y;
     e2a:	ff 2e       	mov	r15, r31
			nokia_lcd_set_cursor(65, 40);
			nokia_lcd_write_char(room + '0', 1);
     e2c:	f0 2d       	mov	r31, r0
     e2e:	8a e0       	ldi	r24, 0x0A	; 10
     e30:	f7 01       	movw	r30, r14
     e32:	80 83       	st	Z, r24
     e34:	c2 e9       	ldi	r28, 0x92	; 146
     e36:	d9 e0       	ldi	r29, 0x09	; 9
			nokia_lcd_render();
     e38:	18 e2       	ldi	r17, 0x28	; 40
			break;
     e3a:	18 83       	st	Y, r17
			
		case LOCK:
			if(lr){
				if (temp > 0) {temp = temp - 1;}
     e3c:	61 e0       	ldi	r22, 0x01	; 1
     e3e:	83 e8       	ldi	r24, 0x83	; 131
     e40:	91 e0       	ldi	r25, 0x01	; 1
     e42:	8e dc       	rcall	.-1764   	; 0x760 <nokia_lcd_write_string>
     e44:	81 e4       	ldi	r24, 0x41	; 65
     e46:	f7 01       	movw	r30, r14
     e48:	80 83       	st	Z, r24
     e4a:	18 83       	st	Y, r17
				else {temp = 7;}
     e4c:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <room>
     e50:	61 e0       	ldi	r22, 0x01	; 1
			
				if((numPhases - 1) == 0)
     e52:	80 5d       	subi	r24, 0xD0	; 208
     e54:	d9 db       	rcall	.-2126   	; 0x608 <nokia_lcd_write_char>
     e56:	96 dc       	rcall	.-1748   	; 0x784 <nokia_lcd_render>
     e58:	b0 c0       	rjmp	.+352    	; 0xfba <Motor_Tick+0x766>
     e5a:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <temp>
     e5e:	88 23       	and	r24, r24
     e60:	21 f0       	breq	.+8      	; 0xe6a <Motor_Tick+0x616>
     e62:	81 50       	subi	r24, 0x01	; 1
     e64:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <temp>
				{
					lr = 0;
     e68:	03 c0       	rjmp	.+6      	; 0xe70 <Motor_Tick+0x61c>
				}
				
			}
			if(garage_button == 8){PORTA = (loc[temp] << 4); PORTD = ((0x01 << 4) | PORTD); room = 2;}
     e6a:	87 e0       	ldi	r24, 0x07	; 7
     e6c:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <temp>
     e70:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <numPhases>
     e74:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <numPhases+0x1>
     e78:	a0 91 05 01 	lds	r26, 0x0105	; 0x800105 <numPhases+0x2>
     e7c:	b0 91 06 01 	lds	r27, 0x0106	; 0x800106 <numPhases+0x3>
     e80:	01 97       	sbiw	r24, 0x01	; 1
     e82:	a1 05       	cpc	r26, r1
     e84:	b1 05       	cpc	r27, r1
			else{PORTA = loc[temp]; PORTD = SetBit(PORTD,4,0); room = 1;}
     e86:	11 f4       	brne	.+4      	; 0xe8c <Motor_Tick+0x638>
     e88:	10 92 91 07 	sts	0x0791, r1	; 0x800791 <lr>
     e8c:	38 30       	cpi	r19, 0x08	; 8
     e8e:	71 f4       	brne	.+28     	; 0xeac <Motor_Tick+0x658>
     e90:	e0 91 98 07 	lds	r30, 0x0798	; 0x800798 <temp>
     e94:	f0 e0       	ldi	r31, 0x00	; 0
     e96:	e9 5f       	subi	r30, 0xF9	; 249
     e98:	fe 4f       	sbci	r31, 0xFE	; 254
			
			nokia_lcd_clear();
     e9a:	80 81       	ld	r24, Z
     e9c:	82 95       	swap	r24
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     e9e:	80 7f       	andi	r24, 0xF0	; 240
     ea0:	82 b9       	out	0x02, r24	; 2
     ea2:	5c 9a       	sbi	0x0b, 4	; 11
     ea4:	82 e0       	ldi	r24, 0x02	; 2
     ea6:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <room>
     eaa:	0b c0       	rjmp	.+22     	; 0xec2 <Motor_Tick+0x66e>
    nokia_lcd.cursor_y = y;
     eac:	e0 91 98 07 	lds	r30, 0x0798	; 0x800798 <temp>
     eb0:	f0 e0       	ldi	r31, 0x00	; 0
			nokia_lcd_set_cursor(10, 10);
			nokia_lcd_write_string("LOCKING!", 1);
     eb2:	e9 5f       	subi	r30, 0xF9	; 249
     eb4:	fe 4f       	sbci	r31, 0xFE	; 254
     eb6:	80 81       	ld	r24, Z
     eb8:	82 b9       	out	0x02, r24	; 2
     eba:	5c 98       	cbi	0x0b, 4	; 11
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ebc:	81 e0       	ldi	r24, 0x01	; 1
    nokia_lcd.cursor_y = y;
     ebe:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <room>
     ec2:	66 db       	rcall	.-2356   	; 0x590 <nokia_lcd_clear>
     ec4:	01 e9       	ldi	r16, 0x91	; 145
			nokia_lcd_set_cursor(10, 40);
			nokia_lcd_write_string("Room: ", 1);
     ec6:	19 e0       	ldi	r17, 0x09	; 9
     ec8:	0f 2e       	mov	r0, r31
     eca:	fa e0       	ldi	r31, 0x0A	; 10
     ecc:	ff 2e       	mov	r15, r31
     ece:	f0 2d       	mov	r31, r0
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ed0:	f8 01       	movw	r30, r16
     ed2:	f0 82       	st	Z, r15
     ed4:	c2 e9       	ldi	r28, 0x92	; 146
			nokia_lcd_set_cursor(65, 40);
			nokia_lcd_write_char(room + '0', 1);
     ed6:	d9 e0       	ldi	r29, 0x09	; 9
     ed8:	f8 82       	st	Y, r15
     eda:	61 e0       	ldi	r22, 0x01	; 1
     edc:	84 e7       	ldi	r24, 0x74	; 116
     ede:	91 e0       	ldi	r25, 0x01	; 1
			nokia_lcd_render();
     ee0:	3f dc       	rcall	.-1922   	; 0x760 <nokia_lcd_write_string>
			break;
		
		default:
			break;
	}
}
     ee2:	f8 01       	movw	r30, r16
			
			
	switch(motor_state)
	{
		case READ_MOTION:
			PORTD = SetBit(PORTD,4,0); //GARAGE LIGHT OFF
     ee4:	f0 82       	st	Z, r15
			if (motion_sensor == 0){
     ee6:	0f 2e       	mov	r0, r31
     ee8:	f8 e2       	ldi	r31, 0x28	; 40
     eea:	ff 2e       	mov	r15, r31
			nokia_lcd_render();
			break;
			
			
		case READ_KEY:
			if((key == passwordarray[0]) && (key2 == passwordarray[1]) && (key3 == passwordarray[2])){ //LOCK = 1 2
     eec:	f0 2d       	mov	r31, r0
     eee:	f8 82       	st	Y, r15
     ef0:	61 e0       	ldi	r22, 0x01	; 1
     ef2:	83 e8       	ldi	r24, 0x83	; 131
     ef4:	91 e0       	ldi	r25, 0x01	; 1
			}
			nokia_lcd_render();
			break;
			
		case MENU:
			menu_key = GetKeypadKey();
     ef6:	34 dc       	rcall	.-1944   	; 0x760 <nokia_lcd_write_string>
     ef8:	81 e4       	ldi	r24, 0x41	; 65
     efa:	f8 01       	movw	r30, r16
     efc:	80 83       	st	Z, r24
			if ((menu_key == 'A')){
     efe:	f8 82       	st	Y, r15
     f00:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <room>
     f04:	61 e0       	ldi	r22, 0x01	; 1
     f06:	80 5d       	subi	r24, 0xD0	; 208
     f08:	7f db       	rcall	.-2306   	; 0x608 <nokia_lcd_write_char>
     f0a:	3c dc       	rcall	.-1928   	; 0x784 <nokia_lcd_render>
     f0c:	56 c0       	rjmp	.+172    	; 0xfba <Motor_Tick+0x766>
     f0e:	5c 98       	cbi	0x0b, 4	; 11
     f10:	21 11       	cpse	r18, r1
     f12:	b2 cd       	rjmp	.-1180   	; 0xa78 <Motor_Tick+0x224>
     f14:	9b cd       	rjmp	.-1226   	; 0xa4c <Motor_Tick+0x1f8>
    nokia_lcd.cursor_y = y;
     f16:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
     f1a:	80 91 ee 09 	lds	r24, 0x09EE	; 0x8009ee <key>
			break;
			
		case CURRENT_PASS:
			nokia_lcd_clear();
			nokia_lcd_set_cursor(5, 10);
			nokia_lcd_write_string("Current Code:", 1);
     f1e:	98 17       	cp	r25, r24
     f20:	09 f4       	brne	.+2      	; 0xf24 <Motor_Tick+0x6d0>
     f22:	bb ce       	rjmp	.-650    	; 0xc9a <Motor_Tick+0x446>
     f24:	ca ce       	rjmp	.-620    	; 0xcba <Motor_Tick+0x466>
     f26:	b0 da       	rcall	.-2720   	; 0x488 <GetKeypadKey>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     f28:	80 93 f1 09 	sts	0x09F1, r24	; 0x8009f1 <menu_key>
    nokia_lcd.cursor_y = y;
     f2c:	81 34       	cpi	r24, 0x41	; 65
     f2e:	09 f0       	breq	.+2      	; 0xf32 <Motor_Tick+0x6de>
			nokia_lcd_set_cursor(10, 20);
			nokia_lcd_write_char(passwordarray[0], 1);
     f30:	a9 cd       	rjmp	.-1198   	; 0xa84 <Motor_Tick+0x230>
     f32:	a4 cd       	rjmp	.-1208   	; 0xa7c <Motor_Tick+0x228>
     f34:	2d db       	rcall	.-2470   	; 0x590 <nokia_lcd_clear>
     f36:	0f 2e       	mov	r0, r31
     f38:	f1 e9       	ldi	r31, 0x91	; 145
     f3a:	ef 2e       	mov	r14, r31
     f3c:	f9 e0       	ldi	r31, 0x09	; 9
     f3e:	ff 2e       	mov	r15, r31
     f40:	f0 2d       	mov	r31, r0
     f42:	85 e0       	ldi	r24, 0x05	; 5
     f44:	f7 01       	movw	r30, r14
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     f46:	80 83       	st	Z, r24
     f48:	c2 e9       	ldi	r28, 0x92	; 146
    nokia_lcd.cursor_y = y;
     f4a:	d9 e0       	ldi	r29, 0x09	; 9
			nokia_lcd_set_cursor(20, 20);
			nokia_lcd_write_char(passwordarray[1], 1);
     f4c:	1a e0       	ldi	r17, 0x0A	; 10
     f4e:	18 83       	st	Y, r17
     f50:	61 e0       	ldi	r22, 0x01	; 1
     f52:	8a e8       	ldi	r24, 0x8A	; 138
     f54:	91 e0       	ldi	r25, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     f56:	04 dc       	rcall	.-2040   	; 0x760 <nokia_lcd_write_string>
     f58:	f7 01       	movw	r30, r14
     f5a:	10 83       	st	Z, r17
    nokia_lcd.cursor_y = y;
     f5c:	14 e1       	ldi	r17, 0x14	; 20
			nokia_lcd_set_cursor(30, 20);
			nokia_lcd_write_char(passwordarray[2], 1);
     f5e:	18 83       	st	Y, r17
     f60:	0f 2e       	mov	r0, r31
     f62:	f0 e0       	ldi	r31, 0x00	; 0
     f64:	cf 2e       	mov	r12, r31
     f66:	f1 e0       	ldi	r31, 0x01	; 1
			nokia_lcd_render();
     f68:	df 2e       	mov	r13, r31
     f6a:	f0 2d       	mov	r31, r0
			break;
     f6c:	61 e0       	ldi	r22, 0x01	; 1
			
		case CHANGE_PASS:
			nokia_lcd_clear();
     f6e:	f6 01       	movw	r30, r12
     f70:	80 81       	ld	r24, Z
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     f72:	4a db       	rcall	.-2412   	; 0x608 <nokia_lcd_write_char>
     f74:	f7 01       	movw	r30, r14
     f76:	10 83       	st	Z, r17
    nokia_lcd.cursor_y = y;
     f78:	18 83       	st	Y, r17
     f7a:	61 e0       	ldi	r22, 0x01	; 1
     f7c:	f6 01       	movw	r30, r12
			nokia_lcd_set_cursor(5, 10);
			nokia_lcd_write_string("New Code:", 1);
     f7e:	81 81       	ldd	r24, Z+1	; 0x01
     f80:	43 db       	rcall	.-2426   	; 0x608 <nokia_lcd_write_char>
     f82:	8e e1       	ldi	r24, 0x1E	; 30
     f84:	f7 01       	movw	r30, r14
     f86:	80 83       	st	Z, r24
			nokia_lcd_render();
     f88:	18 83       	st	Y, r17
     f8a:	61 e0       	ldi	r22, 0x01	; 1
			break;
     f8c:	f6 01       	movw	r30, r12
			nokia_lcd_write_char(room + '0', 1);
			nokia_lcd_render();
			break;
			
		case LOCK:
			if(lr){
     f8e:	82 81       	ldd	r24, Z+2	; 0x02
     f90:	3b db       	rcall	.-2442   	; 0x608 <nokia_lcd_write_char>
     f92:	f8 db       	rcall	.-2064   	; 0x784 <nokia_lcd_render>
     f94:	12 c0       	rjmp	.+36     	; 0xfba <Motor_Tick+0x766>
     f96:	fc da       	rcall	.-2568   	; 0x590 <nokia_lcd_clear>
			break;
		
		default:
			break;
	}
}
     f98:	85 e0       	ldi	r24, 0x05	; 5
     f9a:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <nokia_lcd+0x1f8>
     f9e:	8a e0       	ldi	r24, 0x0A	; 10
     fa0:	80 93 92 09 	sts	0x0992, r24	; 0x800992 <nokia_lcd+0x1f9>
     fa4:	61 e0       	ldi	r22, 0x01	; 1
     fa6:	88 e9       	ldi	r24, 0x98	; 152
     fa8:	91 e0       	ldi	r25, 0x01	; 1
     faa:	da db       	rcall	.-2124   	; 0x760 <nokia_lcd_write_string>
     fac:	eb db       	rcall	.-2090   	; 0x784 <nokia_lcd_render>
     fae:	05 c0       	rjmp	.+10     	; 0xfba <Motor_Tick+0x766>
     fb0:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <lr>
     fb4:	81 11       	cpse	r24, r1
     fb6:	51 cf       	rjmp	.-350    	; 0xe5a <Motor_Tick+0x606>
     fb8:	69 cf       	rjmp	.-302    	; 0xe8c <Motor_Tick+0x638>
     fba:	df 91       	pop	r29
     fbc:	cf 91       	pop	r28
     fbe:	1f 91       	pop	r17
     fc0:	0f 91       	pop	r16
     fc2:	ff 90       	pop	r15
     fc4:	ef 90       	pop	r14
     fc6:	df 90       	pop	r13
     fc8:	cf 90       	pop	r12
     fca:	08 95       	ret

00000fcc <MotorTask>:
//////////////////////////////////////////////////////////////////////// LOCAL VARIABLES ////////////////////////////////////////////////////////////////////////

enum MotorState {READ_MOTION, MENU, READ_KEY_WAIT, READ_KEY_INIT, CURRENT_PASS, CHANGE_PASS, READ_KEY_WAIT_2, READ_KEY_INIT_2, READ_KEY_WAIT_3, READ_KEY_INIT_3, READ_KEY, LOCK, UNLOCK} motor_state;

void Motor_Init(){
	motor_state = READ_MOTION;
     fcc:	10 92 ed 09 	sts	0x09ED, r1	; 0x8009ed <motor_state>
{
	Motor_Init();
   for(;;) 
   { 	
	Motor_Tick();
	vTaskDelay(3); 
     fd0:	41 dc       	rcall	.-1918   	; 0x854 <Motor_Tick>
     fd2:	83 e0       	ldi	r24, 0x03	; 3
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	3e d4       	rcall	.+2172   	; 0x1854 <vTaskDelay>
     fd8:	fb cf       	rjmp	.-10     	; 0xfd0 <MotorTask+0x4>

00000fda <StartSecPulse>:
   } 
}

void StartSecPulse(unsigned portBASE_TYPE Priority)
{
     fda:	af 92       	push	r10
     fdc:	bf 92       	push	r11
     fde:	cf 92       	push	r12
     fe0:	df 92       	push	r13
     fe2:	ef 92       	push	r14
     fe4:	ff 92       	push	r15
     fe6:	0f 93       	push	r16
	xTaskCreate(MotorTask, (signed portCHAR *)"MotorTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     fe8:	a1 2c       	mov	r10, r1
     fea:	b1 2c       	mov	r11, r1
     fec:	c1 2c       	mov	r12, r1
     fee:	d1 2c       	mov	r13, r1
     ff0:	e1 2c       	mov	r14, r1
     ff2:	f1 2c       	mov	r15, r1
     ff4:	08 2f       	mov	r16, r24
     ff6:	20 e0       	ldi	r18, 0x00	; 0
     ff8:	30 e0       	ldi	r19, 0x00	; 0
     ffa:	45 e5       	ldi	r20, 0x55	; 85
     ffc:	50 e0       	ldi	r21, 0x00	; 0
     ffe:	62 ea       	ldi	r22, 0xA2	; 162
    1000:	71 e0       	ldi	r23, 0x01	; 1
    1002:	86 ee       	ldi	r24, 0xE6	; 230
    1004:	97 e0       	ldi	r25, 0x07	; 7
    1006:	ae d1       	rcall	.+860    	; 0x1364 <xTaskGenericCreate>
}
    1008:	0f 91       	pop	r16
    100a:	ff 90       	pop	r15
    100c:	ef 90       	pop	r14
    100e:	df 90       	pop	r13
    1010:	cf 90       	pop	r12
    1012:	bf 90       	pop	r11
    1014:	af 90       	pop	r10
    1016:	08 95       	ret

00001018 <main>:
 
int main(void) 
{
   DDRA = 0xFF; PORTA = 0x00; //stepper
    1018:	8f ef       	ldi	r24, 0xFF	; 255
    101a:	81 b9       	out	0x01, r24	; 1
    101c:	12 b8       	out	0x02, r1	; 2
   DDRB = 0xFF; PORTB = 0x00; //NOKIA 5110
    101e:	84 b9       	out	0x04, r24	; 4
    1020:	15 b8       	out	0x05, r1	; 5
   DDRC = 0xF0, PORTC = 0x0F; //calculator
    1022:	80 ef       	ldi	r24, 0xF0	; 240
    1024:	87 b9       	out	0x07, r24	; 7
    1026:	8f e0       	ldi	r24, 0x0F	; 15
    1028:	88 b9       	out	0x08, r24	; 8
   DDRD = 0xF2; PORTD = 0x0D; //D0 (Rx of Bluetooth), D2 (IR sensor), and D3 (button) inputs and rest outputs for lightbulbs and Tx of Bluetooth
    102a:	82 ef       	ldi	r24, 0xF2	; 242
    102c:	8a b9       	out	0x0a, r24	; 10
    102e:	8d e0       	ldi	r24, 0x0D	; 13
        nokia_lcd.screen[i] = 0x00;
}
  
void nokia_lcd_power(uint8_t on)
{
    write_cmd(on ? 0x20 : 0x24);
    1030:	8b b9       	out	0x0b, r24	; 11
   
   nokia_lcd_init();
   nokia_lcd_power(1);
   initUSART(0);
    1032:	78 da       	rcall	.-2832   	; 0x524 <nokia_lcd_init>
   
   //Start Tasks  
   StartSecPulse(1);
    1034:	80 e2       	ldi	r24, 0x20	; 32
    1036:	25 da       	rcall	.-2998   	; 0x482 <write_cmd>
    1038:	80 e0       	ldi	r24, 0x00	; 0
    //RunSchedular 
   vTaskStartScheduler();
    103a:	bb db       	rcall	.-2186   	; 0x7b2 <initUSART>
    103c:	81 e0       	ldi	r24, 0x01	; 1
   eeprom_write_byte(0, password)
   password = eeprom_read_byte(0);
   eeprom_update_byte(0, )
   */
   return 0; 
}
    103e:	cd df       	rcall	.-102    	; 0xfda <StartSecPulse>
    1040:	92 d2       	rcall	.+1316   	; 0x1566 <vTaskStartScheduler>
    1042:	80 e0       	ldi	r24, 0x00	; 0
    1044:	90 e0       	ldi	r25, 0x00	; 0
    1046:	08 95       	ret

00001048 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1048:	31 e1       	ldi	r19, 0x11	; 17
    104a:	fc 01       	movw	r30, r24
    104c:	30 83       	st	Z, r19
    104e:	31 97       	sbiw	r30, 0x01	; 1
    1050:	22 e2       	ldi	r18, 0x22	; 34
    1052:	20 83       	st	Z, r18
    1054:	31 97       	sbiw	r30, 0x01	; 1
    1056:	a3 e3       	ldi	r26, 0x33	; 51
    1058:	a0 83       	st	Z, r26
    105a:	31 97       	sbiw	r30, 0x01	; 1
    105c:	60 83       	st	Z, r22
    105e:	31 97       	sbiw	r30, 0x01	; 1
    1060:	70 83       	st	Z, r23
    1062:	31 97       	sbiw	r30, 0x01	; 1
    1064:	10 82       	st	Z, r1
    1066:	31 97       	sbiw	r30, 0x01	; 1
    1068:	60 e8       	ldi	r22, 0x80	; 128
    106a:	60 83       	st	Z, r22
    106c:	31 97       	sbiw	r30, 0x01	; 1
    106e:	10 82       	st	Z, r1
    1070:	31 97       	sbiw	r30, 0x01	; 1
    1072:	62 e0       	ldi	r22, 0x02	; 2
    1074:	60 83       	st	Z, r22
    1076:	31 97       	sbiw	r30, 0x01	; 1
    1078:	63 e0       	ldi	r22, 0x03	; 3
    107a:	60 83       	st	Z, r22
    107c:	31 97       	sbiw	r30, 0x01	; 1
    107e:	64 e0       	ldi	r22, 0x04	; 4
    1080:	60 83       	st	Z, r22
    1082:	31 97       	sbiw	r30, 0x01	; 1
    1084:	65 e0       	ldi	r22, 0x05	; 5
    1086:	60 83       	st	Z, r22
    1088:	31 97       	sbiw	r30, 0x01	; 1
    108a:	66 e0       	ldi	r22, 0x06	; 6
    108c:	60 83       	st	Z, r22
    108e:	31 97       	sbiw	r30, 0x01	; 1
    1090:	67 e0       	ldi	r22, 0x07	; 7
    1092:	60 83       	st	Z, r22
    1094:	31 97       	sbiw	r30, 0x01	; 1
    1096:	68 e0       	ldi	r22, 0x08	; 8
    1098:	60 83       	st	Z, r22
    109a:	31 97       	sbiw	r30, 0x01	; 1
    109c:	69 e0       	ldi	r22, 0x09	; 9
    109e:	60 83       	st	Z, r22
    10a0:	31 97       	sbiw	r30, 0x01	; 1
    10a2:	60 e1       	ldi	r22, 0x10	; 16
    10a4:	60 83       	st	Z, r22
    10a6:	31 97       	sbiw	r30, 0x01	; 1
    10a8:	30 83       	st	Z, r19
    10aa:	31 97       	sbiw	r30, 0x01	; 1
    10ac:	32 e1       	ldi	r19, 0x12	; 18
    10ae:	30 83       	st	Z, r19
    10b0:	31 97       	sbiw	r30, 0x01	; 1
    10b2:	33 e1       	ldi	r19, 0x13	; 19
    10b4:	30 83       	st	Z, r19
    10b6:	31 97       	sbiw	r30, 0x01	; 1
    10b8:	34 e1       	ldi	r19, 0x14	; 20
    10ba:	30 83       	st	Z, r19
    10bc:	31 97       	sbiw	r30, 0x01	; 1
    10be:	35 e1       	ldi	r19, 0x15	; 21
    10c0:	30 83       	st	Z, r19
    10c2:	31 97       	sbiw	r30, 0x01	; 1
    10c4:	36 e1       	ldi	r19, 0x16	; 22
    10c6:	30 83       	st	Z, r19
    10c8:	31 97       	sbiw	r30, 0x01	; 1
    10ca:	37 e1       	ldi	r19, 0x17	; 23
    10cc:	30 83       	st	Z, r19
    10ce:	31 97       	sbiw	r30, 0x01	; 1
    10d0:	38 e1       	ldi	r19, 0x18	; 24
    10d2:	30 83       	st	Z, r19
    10d4:	31 97       	sbiw	r30, 0x01	; 1
    10d6:	39 e1       	ldi	r19, 0x19	; 25
    10d8:	30 83       	st	Z, r19
    10da:	31 97       	sbiw	r30, 0x01	; 1
    10dc:	30 e2       	ldi	r19, 0x20	; 32
    10de:	30 83       	st	Z, r19
    10e0:	31 97       	sbiw	r30, 0x01	; 1
    10e2:	31 e2       	ldi	r19, 0x21	; 33
    10e4:	30 83       	st	Z, r19
    10e6:	31 97       	sbiw	r30, 0x01	; 1
    10e8:	20 83       	st	Z, r18
    10ea:	31 97       	sbiw	r30, 0x01	; 1
    10ec:	23 e2       	ldi	r18, 0x23	; 35
    10ee:	20 83       	st	Z, r18
    10f0:	31 97       	sbiw	r30, 0x01	; 1
    10f2:	40 83       	st	Z, r20
    10f4:	31 97       	sbiw	r30, 0x01	; 1
    10f6:	50 83       	st	Z, r21
    10f8:	31 97       	sbiw	r30, 0x01	; 1
    10fa:	26 e2       	ldi	r18, 0x26	; 38
    10fc:	20 83       	st	Z, r18
    10fe:	31 97       	sbiw	r30, 0x01	; 1
    1100:	27 e2       	ldi	r18, 0x27	; 39
    1102:	20 83       	st	Z, r18
    1104:	31 97       	sbiw	r30, 0x01	; 1
    1106:	28 e2       	ldi	r18, 0x28	; 40
    1108:	20 83       	st	Z, r18
    110a:	31 97       	sbiw	r30, 0x01	; 1
    110c:	29 e2       	ldi	r18, 0x29	; 41
    110e:	20 83       	st	Z, r18
    1110:	31 97       	sbiw	r30, 0x01	; 1
    1112:	20 e3       	ldi	r18, 0x30	; 48
    1114:	20 83       	st	Z, r18
    1116:	31 97       	sbiw	r30, 0x01	; 1
    1118:	21 e3       	ldi	r18, 0x31	; 49
    111a:	20 83       	st	Z, r18
    111c:	86 97       	sbiw	r24, 0x26	; 38
    111e:	08 95       	ret

00001120 <xPortStartScheduler>:
    1120:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    1124:	8c e7       	ldi	r24, 0x7C	; 124
    1126:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    112a:	8b e0       	ldi	r24, 0x0B	; 11
    112c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    1130:	ef e6       	ldi	r30, 0x6F	; 111
    1132:	f0 e0       	ldi	r31, 0x00	; 0
    1134:	80 81       	ld	r24, Z
    1136:	82 60       	ori	r24, 0x02	; 2
    1138:	80 83       	st	Z, r24
    113a:	a0 91 eb 09 	lds	r26, 0x09EB	; 0x8009eb <pxCurrentTCB>
    113e:	b0 91 ec 09 	lds	r27, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    1142:	cd 91       	ld	r28, X+
    1144:	cd bf       	out	0x3d, r28	; 61
    1146:	dd 91       	ld	r29, X+
    1148:	de bf       	out	0x3e, r29	; 62
    114a:	ff 91       	pop	r31
    114c:	ef 91       	pop	r30
    114e:	df 91       	pop	r29
    1150:	cf 91       	pop	r28
    1152:	bf 91       	pop	r27
    1154:	af 91       	pop	r26
    1156:	9f 91       	pop	r25
    1158:	8f 91       	pop	r24
    115a:	7f 91       	pop	r23
    115c:	6f 91       	pop	r22
    115e:	5f 91       	pop	r21
    1160:	4f 91       	pop	r20
    1162:	3f 91       	pop	r19
    1164:	2f 91       	pop	r18
    1166:	1f 91       	pop	r17
    1168:	0f 91       	pop	r16
    116a:	ff 90       	pop	r15
    116c:	ef 90       	pop	r14
    116e:	df 90       	pop	r13
    1170:	cf 90       	pop	r12
    1172:	bf 90       	pop	r11
    1174:	af 90       	pop	r10
    1176:	9f 90       	pop	r9
    1178:	8f 90       	pop	r8
    117a:	7f 90       	pop	r7
    117c:	6f 90       	pop	r6
    117e:	5f 90       	pop	r5
    1180:	4f 90       	pop	r4
    1182:	3f 90       	pop	r3
    1184:	2f 90       	pop	r2
    1186:	1f 90       	pop	r1
    1188:	0f 90       	pop	r0
    118a:	0f be       	out	0x3f, r0	; 63
    118c:	0f 90       	pop	r0
    118e:	08 95       	ret
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	08 95       	ret

00001194 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1194:	0f 92       	push	r0
    1196:	0f b6       	in	r0, 0x3f	; 63
    1198:	f8 94       	cli
    119a:	0f 92       	push	r0
    119c:	1f 92       	push	r1
    119e:	11 24       	eor	r1, r1
    11a0:	2f 92       	push	r2
    11a2:	3f 92       	push	r3
    11a4:	4f 92       	push	r4
    11a6:	5f 92       	push	r5
    11a8:	6f 92       	push	r6
    11aa:	7f 92       	push	r7
    11ac:	8f 92       	push	r8
    11ae:	9f 92       	push	r9
    11b0:	af 92       	push	r10
    11b2:	bf 92       	push	r11
    11b4:	cf 92       	push	r12
    11b6:	df 92       	push	r13
    11b8:	ef 92       	push	r14
    11ba:	ff 92       	push	r15
    11bc:	0f 93       	push	r16
    11be:	1f 93       	push	r17
    11c0:	2f 93       	push	r18
    11c2:	3f 93       	push	r19
    11c4:	4f 93       	push	r20
    11c6:	5f 93       	push	r21
    11c8:	6f 93       	push	r22
    11ca:	7f 93       	push	r23
    11cc:	8f 93       	push	r24
    11ce:	9f 93       	push	r25
    11d0:	af 93       	push	r26
    11d2:	bf 93       	push	r27
    11d4:	cf 93       	push	r28
    11d6:	df 93       	push	r29
    11d8:	ef 93       	push	r30
    11da:	ff 93       	push	r31
    11dc:	a0 91 eb 09 	lds	r26, 0x09EB	; 0x8009eb <pxCurrentTCB>
    11e0:	b0 91 ec 09 	lds	r27, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    11e4:	0d b6       	in	r0, 0x3d	; 61
    11e6:	0d 92       	st	X+, r0
    11e8:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    11ea:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    11ec:	88 d3       	rcall	.+1808   	; 0x18fe <vTaskSwitchContext>
    11ee:	a0 91 eb 09 	lds	r26, 0x09EB	; 0x8009eb <pxCurrentTCB>
    11f2:	b0 91 ec 09 	lds	r27, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    11f6:	cd 91       	ld	r28, X+
    11f8:	cd bf       	out	0x3d, r28	; 61
    11fa:	dd 91       	ld	r29, X+
    11fc:	de bf       	out	0x3e, r29	; 62
    11fe:	ff 91       	pop	r31
    1200:	ef 91       	pop	r30
    1202:	df 91       	pop	r29
    1204:	cf 91       	pop	r28
    1206:	bf 91       	pop	r27
    1208:	af 91       	pop	r26
    120a:	9f 91       	pop	r25
    120c:	8f 91       	pop	r24
    120e:	7f 91       	pop	r23
    1210:	6f 91       	pop	r22
    1212:	5f 91       	pop	r21
    1214:	4f 91       	pop	r20
    1216:	3f 91       	pop	r19
    1218:	2f 91       	pop	r18
    121a:	1f 91       	pop	r17
    121c:	0f 91       	pop	r16
    121e:	ff 90       	pop	r15
    1220:	ef 90       	pop	r14
    1222:	df 90       	pop	r13
    1224:	cf 90       	pop	r12
    1226:	bf 90       	pop	r11
    1228:	af 90       	pop	r10
    122a:	9f 90       	pop	r9
    122c:	8f 90       	pop	r8
    122e:	7f 90       	pop	r7
    1230:	6f 90       	pop	r6
    1232:	5f 90       	pop	r5
    1234:	4f 90       	pop	r4
    1236:	3f 90       	pop	r3
    1238:	2f 90       	pop	r2
    123a:	1f 90       	pop	r1
    123c:	0f 90       	pop	r0
    123e:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1240:	0f 90       	pop	r0
    1242:	08 95       	ret

00001244 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1244:	0f 92       	push	r0
    1246:	0f b6       	in	r0, 0x3f	; 63
    1248:	f8 94       	cli
    124a:	0f 92       	push	r0
    124c:	1f 92       	push	r1
    124e:	11 24       	eor	r1, r1
    1250:	2f 92       	push	r2
    1252:	3f 92       	push	r3
    1254:	4f 92       	push	r4
    1256:	5f 92       	push	r5
    1258:	6f 92       	push	r6
    125a:	7f 92       	push	r7
    125c:	8f 92       	push	r8
    125e:	9f 92       	push	r9
    1260:	af 92       	push	r10
    1262:	bf 92       	push	r11
    1264:	cf 92       	push	r12
    1266:	df 92       	push	r13
    1268:	ef 92       	push	r14
    126a:	ff 92       	push	r15
    126c:	0f 93       	push	r16
    126e:	1f 93       	push	r17
    1270:	2f 93       	push	r18
    1272:	3f 93       	push	r19
    1274:	4f 93       	push	r20
    1276:	5f 93       	push	r21
    1278:	6f 93       	push	r22
    127a:	7f 93       	push	r23
    127c:	8f 93       	push	r24
    127e:	9f 93       	push	r25
    1280:	af 93       	push	r26
    1282:	bf 93       	push	r27
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	ef 93       	push	r30
    128a:	ff 93       	push	r31
    128c:	a0 91 eb 09 	lds	r26, 0x09EB	; 0x8009eb <pxCurrentTCB>
    1290:	b0 91 ec 09 	lds	r27, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    1294:	0d b6       	in	r0, 0x3d	; 61
    1296:	0d 92       	st	X+, r0
    1298:	0e b6       	in	r0, 0x3e	; 62
	vTaskIncrementTick();
	vTaskSwitchContext();
    129a:	0d 92       	st	X+, r0
    129c:	93 d1       	rcall	.+806    	; 0x15c4 <vTaskIncrementTick>
	portRESTORE_CONTEXT();
    129e:	2f d3       	rcall	.+1630   	; 0x18fe <vTaskSwitchContext>
    12a0:	a0 91 eb 09 	lds	r26, 0x09EB	; 0x8009eb <pxCurrentTCB>
    12a4:	b0 91 ec 09 	lds	r27, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    12a8:	cd 91       	ld	r28, X+
    12aa:	cd bf       	out	0x3d, r28	; 61
    12ac:	dd 91       	ld	r29, X+
    12ae:	de bf       	out	0x3e, r29	; 62
    12b0:	ff 91       	pop	r31
    12b2:	ef 91       	pop	r30
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	bf 91       	pop	r27
    12ba:	af 91       	pop	r26
    12bc:	9f 91       	pop	r25
    12be:	8f 91       	pop	r24
    12c0:	7f 91       	pop	r23
    12c2:	6f 91       	pop	r22
    12c4:	5f 91       	pop	r21
    12c6:	4f 91       	pop	r20
    12c8:	3f 91       	pop	r19
    12ca:	2f 91       	pop	r18
    12cc:	1f 91       	pop	r17
    12ce:	0f 91       	pop	r16
    12d0:	ff 90       	pop	r15
    12d2:	ef 90       	pop	r14
    12d4:	df 90       	pop	r13
    12d6:	cf 90       	pop	r12
    12d8:	bf 90       	pop	r11
    12da:	af 90       	pop	r10
    12dc:	9f 90       	pop	r9
    12de:	8f 90       	pop	r8
    12e0:	7f 90       	pop	r7
    12e2:	6f 90       	pop	r6
    12e4:	5f 90       	pop	r5
    12e6:	4f 90       	pop	r4
    12e8:	3f 90       	pop	r3
    12ea:	2f 90       	pop	r2
    12ec:	1f 90       	pop	r1
    12ee:	0f 90       	pop	r0
    12f0:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    12f2:	0f 90       	pop	r0
    12f4:	08 95       	ret

000012f6 <__vector_13>:
}
    12f6:	a6 df       	rcall	.-180    	; 0x1244 <vPortYieldFromTick>
    12f8:	18 95       	reti

000012fa <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	ec 01       	movw	r28, r24
    1300:	e0 91 eb 09 	lds	r30, 0x09EB	; 0x8009eb <pxCurrentTCB>
    1304:	f0 91 ec 09 	lds	r31, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    1308:	93 83       	std	Z+3, r25	; 0x03
    130a:	82 83       	std	Z+2, r24	; 0x02
    130c:	80 91 9b 09 	lds	r24, 0x099B	; 0x80099b <xTickCount>
    1310:	90 91 9c 09 	lds	r25, 0x099C	; 0x80099c <xTickCount+0x1>
    1314:	c8 17       	cp	r28, r24
    1316:	d9 07       	cpc	r29, r25
    1318:	60 f4       	brcc	.+24     	; 0x1332 <prvAddCurrentTaskToDelayedList+0x38>
    131a:	60 91 eb 09 	lds	r22, 0x09EB	; 0x8009eb <pxCurrentTCB>
    131e:	70 91 ec 09 	lds	r23, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    1322:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <pxOverflowDelayedTaskList>
    1326:	90 91 b2 09 	lds	r25, 0x09B2	; 0x8009b2 <pxOverflowDelayedTaskList+0x1>
    132a:	6e 5f       	subi	r22, 0xFE	; 254
    132c:	7f 4f       	sbci	r23, 0xFF	; 255
    132e:	2a d8       	rcall	.-4012   	; 0x384 <vListInsert>
    1330:	16 c0       	rjmp	.+44     	; 0x135e <prvAddCurrentTaskToDelayedList+0x64>
    1332:	60 91 eb 09 	lds	r22, 0x09EB	; 0x8009eb <pxCurrentTCB>
    1336:	70 91 ec 09 	lds	r23, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    133a:	80 91 b3 09 	lds	r24, 0x09B3	; 0x8009b3 <pxDelayedTaskList>
    133e:	90 91 b4 09 	lds	r25, 0x09B4	; 0x8009b4 <pxDelayedTaskList+0x1>
    1342:	6e 5f       	subi	r22, 0xFE	; 254
    1344:	7f 4f       	sbci	r23, 0xFF	; 255
    1346:	1e d8       	rcall	.-4036   	; 0x384 <vListInsert>
    1348:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <xNextTaskUnblockTime>
    134c:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <xNextTaskUnblockTime+0x1>
    1350:	c8 17       	cp	r28, r24
    1352:	d9 07       	cpc	r29, r25
    1354:	20 f4       	brcc	.+8      	; 0x135e <prvAddCurrentTaskToDelayedList+0x64>
    1356:	d0 93 10 01 	sts	0x0110, r29	; 0x800110 <xNextTaskUnblockTime+0x1>
    135a:	c0 93 0f 01 	sts	0x010F, r28	; 0x80010f <xNextTaskUnblockTime>
    135e:	df 91       	pop	r29
    1360:	cf 91       	pop	r28
    1362:	08 95       	ret

00001364 <xTaskGenericCreate>:
    1364:	4f 92       	push	r4
    1366:	5f 92       	push	r5
    1368:	6f 92       	push	r6
    136a:	7f 92       	push	r7
    136c:	8f 92       	push	r8
    136e:	9f 92       	push	r9
    1370:	af 92       	push	r10
    1372:	bf 92       	push	r11
    1374:	cf 92       	push	r12
    1376:	df 92       	push	r13
    1378:	ef 92       	push	r14
    137a:	ff 92       	push	r15
    137c:	0f 93       	push	r16
    137e:	1f 93       	push	r17
    1380:	cf 93       	push	r28
    1382:	df 93       	push	r29
    1384:	5c 01       	movw	r10, r24
    1386:	4b 01       	movw	r8, r22
    1388:	3a 01       	movw	r6, r20
    138a:	29 01       	movw	r4, r18
    138c:	81 e2       	ldi	r24, 0x21	; 33
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	0e 94 62 01 	call	0x2c4	; 0x2c4 <pvPortMalloc>
    1394:	ec 01       	movw	r28, r24
    1396:	89 2b       	or	r24, r25
    1398:	09 f4       	brne	.+2      	; 0x139c <xTaskGenericCreate+0x38>
    139a:	d3 c0       	rjmp	.+422    	; 0x1542 <xTaskGenericCreate+0x1de>
    139c:	c1 14       	cp	r12, r1
    139e:	d1 04       	cpc	r13, r1
    13a0:	09 f0       	breq	.+2      	; 0x13a4 <xTaskGenericCreate+0x40>
    13a2:	cb c0       	rjmp	.+406    	; 0x153a <xTaskGenericCreate+0x1d6>
    13a4:	c3 01       	movw	r24, r6
    13a6:	0e 94 62 01 	call	0x2c4	; 0x2c4 <pvPortMalloc>
    13aa:	98 8f       	std	Y+24, r25	; 0x18
    13ac:	8f 8b       	std	Y+23, r24	; 0x17
    13ae:	00 97       	sbiw	r24, 0x00	; 0
    13b0:	21 f4       	brne	.+8      	; 0x13ba <xTaskGenericCreate+0x56>
    13b2:	ce 01       	movw	r24, r28
    13b4:	0e 94 88 01 	call	0x310	; 0x310 <vPortFree>
    13b8:	c4 c0       	rjmp	.+392    	; 0x1542 <xTaskGenericCreate+0x1de>
    13ba:	a3 01       	movw	r20, r6
    13bc:	65 ea       	ldi	r22, 0xA5	; 165
    13be:	70 e0       	ldi	r23, 0x00	; 0
    13c0:	1f d3       	rcall	.+1598   	; 0x1a00 <memset>
    13c2:	93 01       	movw	r18, r6
    13c4:	21 50       	subi	r18, 0x01	; 1
    13c6:	31 09       	sbc	r19, r1
    13c8:	8f 89       	ldd	r24, Y+23	; 0x17
    13ca:	98 8d       	ldd	r25, Y+24	; 0x18
    13cc:	3c 01       	movw	r6, r24
    13ce:	62 0e       	add	r6, r18
    13d0:	73 1e       	adc	r7, r19
    13d2:	48 e0       	ldi	r20, 0x08	; 8
    13d4:	50 e0       	ldi	r21, 0x00	; 0
    13d6:	b4 01       	movw	r22, r8
    13d8:	ce 01       	movw	r24, r28
    13da:	49 96       	adiw	r24, 0x19	; 25
    13dc:	18 d3       	rcall	.+1584   	; 0x1a0e <strncpy>
    13de:	18 a2       	std	Y+32, r1	; 0x20
    13e0:	10 2f       	mov	r17, r16
    13e2:	04 30       	cpi	r16, 0x04	; 4
    13e4:	08 f0       	brcs	.+2      	; 0x13e8 <xTaskGenericCreate+0x84>
    13e6:	13 e0       	ldi	r17, 0x03	; 3
    13e8:	1e 8b       	std	Y+22, r17	; 0x16
    13ea:	6e 01       	movw	r12, r28
    13ec:	82 e0       	ldi	r24, 0x02	; 2
    13ee:	c8 0e       	add	r12, r24
    13f0:	d1 1c       	adc	r13, r1
    13f2:	c6 01       	movw	r24, r12
    13f4:	0e 94 97 01 	call	0x32e	; 0x32e <vListInitialiseItem>
    13f8:	ce 01       	movw	r24, r28
    13fa:	0c 96       	adiw	r24, 0x0c	; 12
    13fc:	0e 94 97 01 	call	0x32e	; 0x32e <vListInitialiseItem>
    1400:	d9 87       	std	Y+9, r29	; 0x09
    1402:	c8 87       	std	Y+8, r28	; 0x08
    1404:	84 e0       	ldi	r24, 0x04	; 4
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	81 1b       	sub	r24, r17
    140a:	91 09       	sbc	r25, r1
    140c:	9d 87       	std	Y+13, r25	; 0x0d
    140e:	8c 87       	std	Y+12, r24	; 0x0c
    1410:	db 8b       	std	Y+19, r29	; 0x13
    1412:	ca 8b       	std	Y+18, r28	; 0x12
    1414:	a2 01       	movw	r20, r4
    1416:	b5 01       	movw	r22, r10
    1418:	c3 01       	movw	r24, r6
    141a:	16 de       	rcall	.-980    	; 0x1048 <pxPortInitialiseStack>
    141c:	99 83       	std	Y+1, r25	; 0x01
    141e:	88 83       	st	Y, r24
    1420:	e1 14       	cp	r14, r1
    1422:	f1 04       	cpc	r15, r1
    1424:	19 f0       	breq	.+6      	; 0x142c <xTaskGenericCreate+0xc8>
    1426:	f7 01       	movw	r30, r14
    1428:	d1 83       	std	Z+1, r29	; 0x01
    142a:	c0 83       	st	Z, r28
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	f8 94       	cli
    1430:	0f 92       	push	r0
    1432:	80 91 9d 09 	lds	r24, 0x099D	; 0x80099d <uxCurrentNumberOfTasks>
    1436:	8f 5f       	subi	r24, 0xFF	; 255
    1438:	80 93 9d 09 	sts	0x099D, r24	; 0x80099d <uxCurrentNumberOfTasks>
    143c:	80 91 eb 09 	lds	r24, 0x09EB	; 0x8009eb <pxCurrentTCB>
    1440:	90 91 ec 09 	lds	r25, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    1444:	89 2b       	or	r24, r25
    1446:	a9 f5       	brne	.+106    	; 0x14b2 <xTaskGenericCreate+0x14e>
    1448:	d0 93 ec 09 	sts	0x09EC, r29	; 0x8009ec <pxCurrentTCB+0x1>
    144c:	c0 93 eb 09 	sts	0x09EB, r28	; 0x8009eb <pxCurrentTCB>
    1450:	80 91 9d 09 	lds	r24, 0x099D	; 0x80099d <uxCurrentNumberOfTasks>
    1454:	81 30       	cpi	r24, 0x01	; 1
    1456:	e1 f5       	brne	.+120    	; 0x14d0 <xTaskGenericCreate+0x16c>
    1458:	87 ec       	ldi	r24, 0xC7	; 199
    145a:	99 e0       	ldi	r25, 0x09	; 9
    145c:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1460:	80 ed       	ldi	r24, 0xD0	; 208
    1462:	99 e0       	ldi	r25, 0x09	; 9
    1464:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1468:	89 ed       	ldi	r24, 0xD9	; 217
    146a:	99 e0       	ldi	r25, 0x09	; 9
    146c:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1470:	82 ee       	ldi	r24, 0xE2	; 226
    1472:	99 e0       	ldi	r25, 0x09	; 9
    1474:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1478:	8e eb       	ldi	r24, 0xBE	; 190
    147a:	99 e0       	ldi	r25, 0x09	; 9
    147c:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1480:	85 eb       	ldi	r24, 0xB5	; 181
    1482:	99 e0       	ldi	r25, 0x09	; 9
    1484:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1488:	88 ea       	ldi	r24, 0xA8	; 168
    148a:	99 e0       	ldi	r25, 0x09	; 9
    148c:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1490:	8f e9       	ldi	r24, 0x9F	; 159
    1492:	99 e0       	ldi	r25, 0x09	; 9
    1494:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1498:	8e eb       	ldi	r24, 0xBE	; 190
    149a:	99 e0       	ldi	r25, 0x09	; 9
    149c:	90 93 b4 09 	sts	0x09B4, r25	; 0x8009b4 <pxDelayedTaskList+0x1>
    14a0:	80 93 b3 09 	sts	0x09B3, r24	; 0x8009b3 <pxDelayedTaskList>
    14a4:	85 eb       	ldi	r24, 0xB5	; 181
    14a6:	99 e0       	ldi	r25, 0x09	; 9
    14a8:	90 93 b2 09 	sts	0x09B2, r25	; 0x8009b2 <pxOverflowDelayedTaskList+0x1>
    14ac:	80 93 b1 09 	sts	0x09B1, r24	; 0x8009b1 <pxOverflowDelayedTaskList>
    14b0:	0f c0       	rjmp	.+30     	; 0x14d0 <xTaskGenericCreate+0x16c>
    14b2:	80 91 98 09 	lds	r24, 0x0998	; 0x800998 <xSchedulerRunning>
    14b6:	81 11       	cpse	r24, r1
    14b8:	0b c0       	rjmp	.+22     	; 0x14d0 <xTaskGenericCreate+0x16c>
    14ba:	e0 91 eb 09 	lds	r30, 0x09EB	; 0x8009eb <pxCurrentTCB>
    14be:	f0 91 ec 09 	lds	r31, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    14c2:	86 89       	ldd	r24, Z+22	; 0x16
    14c4:	08 17       	cp	r16, r24
    14c6:	20 f0       	brcs	.+8      	; 0x14d0 <xTaskGenericCreate+0x16c>
    14c8:	d0 93 ec 09 	sts	0x09EC, r29	; 0x8009ec <pxCurrentTCB+0x1>
    14cc:	c0 93 eb 09 	sts	0x09EB, r28	; 0x8009eb <pxCurrentTCB>
    14d0:	8e 89       	ldd	r24, Y+22	; 0x16
    14d2:	90 91 9a 09 	lds	r25, 0x099A	; 0x80099a <uxTopUsedPriority>
    14d6:	98 17       	cp	r25, r24
    14d8:	10 f4       	brcc	.+4      	; 0x14de <xTaskGenericCreate+0x17a>
    14da:	80 93 9a 09 	sts	0x099A, r24	; 0x80099a <uxTopUsedPriority>
    14de:	90 91 93 09 	lds	r25, 0x0993	; 0x800993 <uxTaskNumber>
    14e2:	9f 5f       	subi	r25, 0xFF	; 255
    14e4:	90 93 93 09 	sts	0x0993, r25	; 0x800993 <uxTaskNumber>
    14e8:	90 91 99 09 	lds	r25, 0x0999	; 0x800999 <uxTopReadyPriority>
    14ec:	98 17       	cp	r25, r24
    14ee:	10 f4       	brcc	.+4      	; 0x14f4 <xTaskGenericCreate+0x190>
    14f0:	80 93 99 09 	sts	0x0999, r24	; 0x800999 <uxTopReadyPriority>
    14f4:	90 e0       	ldi	r25, 0x00	; 0
    14f6:	9c 01       	movw	r18, r24
    14f8:	22 0f       	add	r18, r18
    14fa:	33 1f       	adc	r19, r19
    14fc:	22 0f       	add	r18, r18
    14fe:	33 1f       	adc	r19, r19
    1500:	22 0f       	add	r18, r18
    1502:	33 1f       	adc	r19, r19
    1504:	82 0f       	add	r24, r18
    1506:	93 1f       	adc	r25, r19
    1508:	b6 01       	movw	r22, r12
    150a:	89 53       	subi	r24, 0x39	; 57
    150c:	96 4f       	sbci	r25, 0xF6	; 246
    150e:	0e 94 9b 01 	call	0x336	; 0x336 <vListInsertEnd>
    1512:	0f 90       	pop	r0
    1514:	0f be       	out	0x3f, r0	; 63
    1516:	80 91 98 09 	lds	r24, 0x0998	; 0x800998 <xSchedulerRunning>
    151a:	88 23       	and	r24, r24
    151c:	51 f0       	breq	.+20     	; 0x1532 <xTaskGenericCreate+0x1ce>
    151e:	e0 91 eb 09 	lds	r30, 0x09EB	; 0x8009eb <pxCurrentTCB>
    1522:	f0 91 ec 09 	lds	r31, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    1526:	86 89       	ldd	r24, Z+22	; 0x16
    1528:	80 17       	cp	r24, r16
    152a:	28 f4       	brcc	.+10     	; 0x1536 <xTaskGenericCreate+0x1d2>
    152c:	33 de       	rcall	.-922    	; 0x1194 <vPortYield>
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	09 c0       	rjmp	.+18     	; 0x1544 <xTaskGenericCreate+0x1e0>
    1532:	81 e0       	ldi	r24, 0x01	; 1
    1534:	07 c0       	rjmp	.+14     	; 0x1544 <xTaskGenericCreate+0x1e0>
    1536:	81 e0       	ldi	r24, 0x01	; 1
    1538:	05 c0       	rjmp	.+10     	; 0x1544 <xTaskGenericCreate+0x1e0>
    153a:	d8 8e       	std	Y+24, r13	; 0x18
    153c:	cf 8a       	std	Y+23, r12	; 0x17
    153e:	c6 01       	movw	r24, r12
    1540:	3c cf       	rjmp	.-392    	; 0x13ba <xTaskGenericCreate+0x56>
    1542:	8f ef       	ldi	r24, 0xFF	; 255
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	1f 91       	pop	r17
    154a:	0f 91       	pop	r16
    154c:	ff 90       	pop	r15
    154e:	ef 90       	pop	r14
    1550:	df 90       	pop	r13
    1552:	cf 90       	pop	r12
    1554:	bf 90       	pop	r11
    1556:	af 90       	pop	r10
    1558:	9f 90       	pop	r9
    155a:	8f 90       	pop	r8
    155c:	7f 90       	pop	r7
    155e:	6f 90       	pop	r6
    1560:	5f 90       	pop	r5
    1562:	4f 90       	pop	r4
    1564:	08 95       	ret

00001566 <vTaskStartScheduler>:
    1566:	af 92       	push	r10
    1568:	bf 92       	push	r11
    156a:	cf 92       	push	r12
    156c:	df 92       	push	r13
    156e:	ef 92       	push	r14
    1570:	ff 92       	push	r15
    1572:	0f 93       	push	r16
    1574:	a1 2c       	mov	r10, r1
    1576:	b1 2c       	mov	r11, r1
    1578:	c1 2c       	mov	r12, r1
    157a:	d1 2c       	mov	r13, r1
    157c:	e1 2c       	mov	r14, r1
    157e:	f1 2c       	mov	r15, r1
    1580:	00 e0       	ldi	r16, 0x00	; 0
    1582:	20 e0       	ldi	r18, 0x00	; 0
    1584:	30 e0       	ldi	r19, 0x00	; 0
    1586:	45 e5       	ldi	r20, 0x55	; 85
    1588:	50 e0       	ldi	r21, 0x00	; 0
    158a:	6c ea       	ldi	r22, 0xAC	; 172
    158c:	71 e0       	ldi	r23, 0x01	; 1
    158e:	86 e4       	ldi	r24, 0x46	; 70
    1590:	9c e0       	ldi	r25, 0x0C	; 12
    1592:	e8 de       	rcall	.-560    	; 0x1364 <xTaskGenericCreate>
    1594:	81 30       	cpi	r24, 0x01	; 1
    1596:	41 f4       	brne	.+16     	; 0x15a8 <vTaskStartScheduler+0x42>
    1598:	f8 94       	cli
    159a:	80 93 98 09 	sts	0x0998, r24	; 0x800998 <xSchedulerRunning>
    159e:	10 92 9c 09 	sts	0x099C, r1	; 0x80099c <xTickCount+0x1>
    15a2:	10 92 9b 09 	sts	0x099B, r1	; 0x80099b <xTickCount>
    15a6:	bc dd       	rcall	.-1160   	; 0x1120 <xPortStartScheduler>
    15a8:	0f 91       	pop	r16
    15aa:	ff 90       	pop	r15
    15ac:	ef 90       	pop	r14
    15ae:	df 90       	pop	r13
    15b0:	cf 90       	pop	r12
    15b2:	bf 90       	pop	r11
    15b4:	af 90       	pop	r10
    15b6:	08 95       	ret

000015b8 <vTaskSuspendAll>:
    15b8:	80 91 97 09 	lds	r24, 0x0997	; 0x800997 <uxSchedulerSuspended>
    15bc:	8f 5f       	subi	r24, 0xFF	; 255
    15be:	80 93 97 09 	sts	0x0997, r24	; 0x800997 <uxSchedulerSuspended>
    15c2:	08 95       	ret

000015c4 <vTaskIncrementTick>:
    15c4:	0f 93       	push	r16
    15c6:	1f 93       	push	r17
    15c8:	cf 93       	push	r28
    15ca:	df 93       	push	r29
    15cc:	80 91 97 09 	lds	r24, 0x0997	; 0x800997 <uxSchedulerSuspended>
    15d0:	81 11       	cpse	r24, r1
    15d2:	b2 c0       	rjmp	.+356    	; 0x1738 <vTaskIncrementTick+0x174>
    15d4:	80 91 9b 09 	lds	r24, 0x099B	; 0x80099b <xTickCount>
    15d8:	90 91 9c 09 	lds	r25, 0x099C	; 0x80099c <xTickCount+0x1>
    15dc:	01 96       	adiw	r24, 0x01	; 1
    15de:	90 93 9c 09 	sts	0x099C, r25	; 0x80099c <xTickCount+0x1>
    15e2:	80 93 9b 09 	sts	0x099B, r24	; 0x80099b <xTickCount>
    15e6:	80 91 9b 09 	lds	r24, 0x099B	; 0x80099b <xTickCount>
    15ea:	90 91 9c 09 	lds	r25, 0x099C	; 0x80099c <xTickCount+0x1>
    15ee:	89 2b       	or	r24, r25
    15f0:	99 f5       	brne	.+102    	; 0x1658 <vTaskIncrementTick+0x94>
    15f2:	80 91 b3 09 	lds	r24, 0x09B3	; 0x8009b3 <pxDelayedTaskList>
    15f6:	90 91 b4 09 	lds	r25, 0x09B4	; 0x8009b4 <pxDelayedTaskList+0x1>
    15fa:	20 91 b1 09 	lds	r18, 0x09B1	; 0x8009b1 <pxOverflowDelayedTaskList>
    15fe:	30 91 b2 09 	lds	r19, 0x09B2	; 0x8009b2 <pxOverflowDelayedTaskList+0x1>
    1602:	30 93 b4 09 	sts	0x09B4, r19	; 0x8009b4 <pxDelayedTaskList+0x1>
    1606:	20 93 b3 09 	sts	0x09B3, r18	; 0x8009b3 <pxDelayedTaskList>
    160a:	90 93 b2 09 	sts	0x09B2, r25	; 0x8009b2 <pxOverflowDelayedTaskList+0x1>
    160e:	80 93 b1 09 	sts	0x09B1, r24	; 0x8009b1 <pxOverflowDelayedTaskList>
    1612:	80 91 94 09 	lds	r24, 0x0994	; 0x800994 <xNumOfOverflows>
    1616:	8f 5f       	subi	r24, 0xFF	; 255
    1618:	80 93 94 09 	sts	0x0994, r24	; 0x800994 <xNumOfOverflows>
    161c:	e0 91 b3 09 	lds	r30, 0x09B3	; 0x8009b3 <pxDelayedTaskList>
    1620:	f0 91 b4 09 	lds	r31, 0x09B4	; 0x8009b4 <pxDelayedTaskList+0x1>
    1624:	80 81       	ld	r24, Z
    1626:	81 11       	cpse	r24, r1
    1628:	07 c0       	rjmp	.+14     	; 0x1638 <vTaskIncrementTick+0x74>
    162a:	8f ef       	ldi	r24, 0xFF	; 255
    162c:	9f ef       	ldi	r25, 0xFF	; 255
    162e:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <xNextTaskUnblockTime+0x1>
    1632:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <xNextTaskUnblockTime>
    1636:	10 c0       	rjmp	.+32     	; 0x1658 <vTaskIncrementTick+0x94>
    1638:	e0 91 b3 09 	lds	r30, 0x09B3	; 0x8009b3 <pxDelayedTaskList>
    163c:	f0 91 b4 09 	lds	r31, 0x09B4	; 0x8009b4 <pxDelayedTaskList+0x1>
    1640:	05 80       	ldd	r0, Z+5	; 0x05
    1642:	f6 81       	ldd	r31, Z+6	; 0x06
    1644:	e0 2d       	mov	r30, r0
    1646:	06 80       	ldd	r0, Z+6	; 0x06
    1648:	f7 81       	ldd	r31, Z+7	; 0x07
    164a:	e0 2d       	mov	r30, r0
    164c:	82 81       	ldd	r24, Z+2	; 0x02
    164e:	93 81       	ldd	r25, Z+3	; 0x03
    1650:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <xNextTaskUnblockTime+0x1>
    1654:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <xNextTaskUnblockTime>
    1658:	20 91 9b 09 	lds	r18, 0x099B	; 0x80099b <xTickCount>
    165c:	30 91 9c 09 	lds	r19, 0x099C	; 0x80099c <xTickCount+0x1>
    1660:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <xNextTaskUnblockTime>
    1664:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <xNextTaskUnblockTime+0x1>
    1668:	28 17       	cp	r18, r24
    166a:	39 07       	cpc	r19, r25
    166c:	08 f4       	brcc	.+2      	; 0x1670 <vTaskIncrementTick+0xac>
    166e:	69 c0       	rjmp	.+210    	; 0x1742 <vTaskIncrementTick+0x17e>
    1670:	e0 91 b3 09 	lds	r30, 0x09B3	; 0x8009b3 <pxDelayedTaskList>
    1674:	f0 91 b4 09 	lds	r31, 0x09B4	; 0x8009b4 <pxDelayedTaskList+0x1>
    1678:	80 81       	ld	r24, Z
    167a:	88 23       	and	r24, r24
    167c:	99 f0       	breq	.+38     	; 0x16a4 <vTaskIncrementTick+0xe0>
    167e:	e0 91 b3 09 	lds	r30, 0x09B3	; 0x8009b3 <pxDelayedTaskList>
    1682:	f0 91 b4 09 	lds	r31, 0x09B4	; 0x8009b4 <pxDelayedTaskList+0x1>
    1686:	05 80       	ldd	r0, Z+5	; 0x05
    1688:	f6 81       	ldd	r31, Z+6	; 0x06
    168a:	e0 2d       	mov	r30, r0
    168c:	c6 81       	ldd	r28, Z+6	; 0x06
    168e:	d7 81       	ldd	r29, Z+7	; 0x07
    1690:	8a 81       	ldd	r24, Y+2	; 0x02
    1692:	9b 81       	ldd	r25, Y+3	; 0x03
    1694:	20 91 9b 09 	lds	r18, 0x099B	; 0x80099b <xTickCount>
    1698:	30 91 9c 09 	lds	r19, 0x099C	; 0x80099c <xTickCount+0x1>
    169c:	28 17       	cp	r18, r24
    169e:	39 07       	cpc	r19, r25
    16a0:	f8 f4       	brcc	.+62     	; 0x16e0 <vTaskIncrementTick+0x11c>
    16a2:	19 c0       	rjmp	.+50     	; 0x16d6 <vTaskIncrementTick+0x112>
    16a4:	8f ef       	ldi	r24, 0xFF	; 255
    16a6:	9f ef       	ldi	r25, 0xFF	; 255
    16a8:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <xNextTaskUnblockTime+0x1>
    16ac:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <xNextTaskUnblockTime>
    16b0:	48 c0       	rjmp	.+144    	; 0x1742 <vTaskIncrementTick+0x17e>
    16b2:	e0 91 b3 09 	lds	r30, 0x09B3	; 0x8009b3 <pxDelayedTaskList>
    16b6:	f0 91 b4 09 	lds	r31, 0x09B4	; 0x8009b4 <pxDelayedTaskList+0x1>
    16ba:	05 80       	ldd	r0, Z+5	; 0x05
    16bc:	f6 81       	ldd	r31, Z+6	; 0x06
    16be:	e0 2d       	mov	r30, r0
    16c0:	c6 81       	ldd	r28, Z+6	; 0x06
    16c2:	d7 81       	ldd	r29, Z+7	; 0x07
    16c4:	8a 81       	ldd	r24, Y+2	; 0x02
    16c6:	9b 81       	ldd	r25, Y+3	; 0x03
    16c8:	20 91 9b 09 	lds	r18, 0x099B	; 0x80099b <xTickCount>
    16cc:	30 91 9c 09 	lds	r19, 0x099C	; 0x80099c <xTickCount+0x1>
    16d0:	28 17       	cp	r18, r24
    16d2:	39 07       	cpc	r19, r25
    16d4:	28 f4       	brcc	.+10     	; 0x16e0 <vTaskIncrementTick+0x11c>
    16d6:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <xNextTaskUnblockTime+0x1>
    16da:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <xNextTaskUnblockTime>
    16de:	31 c0       	rjmp	.+98     	; 0x1742 <vTaskIncrementTick+0x17e>
    16e0:	8e 01       	movw	r16, r28
    16e2:	0e 5f       	subi	r16, 0xFE	; 254
    16e4:	1f 4f       	sbci	r17, 0xFF	; 255
    16e6:	c8 01       	movw	r24, r16
    16e8:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
    16ec:	8c 89       	ldd	r24, Y+20	; 0x14
    16ee:	9d 89       	ldd	r25, Y+21	; 0x15
    16f0:	89 2b       	or	r24, r25
    16f2:	21 f0       	breq	.+8      	; 0x16fc <vTaskIncrementTick+0x138>
    16f4:	ce 01       	movw	r24, r28
    16f6:	0c 96       	adiw	r24, 0x0c	; 12
    16f8:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
    16fc:	8e 89       	ldd	r24, Y+22	; 0x16
    16fe:	90 91 99 09 	lds	r25, 0x0999	; 0x800999 <uxTopReadyPriority>
    1702:	98 17       	cp	r25, r24
    1704:	10 f4       	brcc	.+4      	; 0x170a <vTaskIncrementTick+0x146>
    1706:	80 93 99 09 	sts	0x0999, r24	; 0x800999 <uxTopReadyPriority>
    170a:	90 e0       	ldi	r25, 0x00	; 0
    170c:	9c 01       	movw	r18, r24
    170e:	22 0f       	add	r18, r18
    1710:	33 1f       	adc	r19, r19
    1712:	22 0f       	add	r18, r18
    1714:	33 1f       	adc	r19, r19
    1716:	22 0f       	add	r18, r18
    1718:	33 1f       	adc	r19, r19
    171a:	82 0f       	add	r24, r18
    171c:	93 1f       	adc	r25, r19
    171e:	b8 01       	movw	r22, r16
    1720:	89 53       	subi	r24, 0x39	; 57
    1722:	96 4f       	sbci	r25, 0xF6	; 246
    1724:	0e 94 9b 01 	call	0x336	; 0x336 <vListInsertEnd>
    1728:	e0 91 b3 09 	lds	r30, 0x09B3	; 0x8009b3 <pxDelayedTaskList>
    172c:	f0 91 b4 09 	lds	r31, 0x09B4	; 0x8009b4 <pxDelayedTaskList+0x1>
    1730:	80 81       	ld	r24, Z
    1732:	81 11       	cpse	r24, r1
    1734:	be cf       	rjmp	.-132    	; 0x16b2 <vTaskIncrementTick+0xee>
    1736:	b6 cf       	rjmp	.-148    	; 0x16a4 <vTaskIncrementTick+0xe0>
    1738:	80 91 96 09 	lds	r24, 0x0996	; 0x800996 <uxMissedTicks>
    173c:	8f 5f       	subi	r24, 0xFF	; 255
    173e:	80 93 96 09 	sts	0x0996, r24	; 0x800996 <uxMissedTicks>
    1742:	df 91       	pop	r29
    1744:	cf 91       	pop	r28
    1746:	1f 91       	pop	r17
    1748:	0f 91       	pop	r16
    174a:	08 95       	ret

0000174c <xTaskResumeAll>:
    174c:	cf 92       	push	r12
    174e:	df 92       	push	r13
    1750:	ef 92       	push	r14
    1752:	ff 92       	push	r15
    1754:	0f 93       	push	r16
    1756:	1f 93       	push	r17
    1758:	cf 93       	push	r28
    175a:	df 93       	push	r29
    175c:	0f b6       	in	r0, 0x3f	; 63
    175e:	f8 94       	cli
    1760:	0f 92       	push	r0
    1762:	80 91 97 09 	lds	r24, 0x0997	; 0x800997 <uxSchedulerSuspended>
    1766:	81 50       	subi	r24, 0x01	; 1
    1768:	80 93 97 09 	sts	0x0997, r24	; 0x800997 <uxSchedulerSuspended>
    176c:	80 91 97 09 	lds	r24, 0x0997	; 0x800997 <uxSchedulerSuspended>
    1770:	81 11       	cpse	r24, r1
    1772:	62 c0       	rjmp	.+196    	; 0x1838 <xTaskResumeAll+0xec>
    1774:	80 91 9d 09 	lds	r24, 0x099D	; 0x80099d <uxCurrentNumberOfTasks>
    1778:	81 11       	cpse	r24, r1
    177a:	32 c0       	rjmp	.+100    	; 0x17e0 <xTaskResumeAll+0x94>
    177c:	60 c0       	rjmp	.+192    	; 0x183e <xTaskResumeAll+0xf2>
    177e:	d7 01       	movw	r26, r14
    1780:	15 96       	adiw	r26, 0x05	; 5
    1782:	ed 91       	ld	r30, X+
    1784:	fc 91       	ld	r31, X
    1786:	16 97       	sbiw	r26, 0x06	; 6
    1788:	c6 81       	ldd	r28, Z+6	; 0x06
    178a:	d7 81       	ldd	r29, Z+7	; 0x07
    178c:	ce 01       	movw	r24, r28
    178e:	0c 96       	adiw	r24, 0x0c	; 12
    1790:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
    1794:	8e 01       	movw	r16, r28
    1796:	0e 5f       	subi	r16, 0xFE	; 254
    1798:	1f 4f       	sbci	r17, 0xFF	; 255
    179a:	c8 01       	movw	r24, r16
    179c:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
    17a0:	8e 89       	ldd	r24, Y+22	; 0x16
    17a2:	90 91 99 09 	lds	r25, 0x0999	; 0x800999 <uxTopReadyPriority>
    17a6:	98 17       	cp	r25, r24
    17a8:	10 f4       	brcc	.+4      	; 0x17ae <xTaskResumeAll+0x62>
    17aa:	80 93 99 09 	sts	0x0999, r24	; 0x800999 <uxTopReadyPriority>
    17ae:	90 e0       	ldi	r25, 0x00	; 0
    17b0:	9c 01       	movw	r18, r24
    17b2:	22 0f       	add	r18, r18
    17b4:	33 1f       	adc	r19, r19
    17b6:	22 0f       	add	r18, r18
    17b8:	33 1f       	adc	r19, r19
    17ba:	22 0f       	add	r18, r18
    17bc:	33 1f       	adc	r19, r19
    17be:	82 0f       	add	r24, r18
    17c0:	93 1f       	adc	r25, r19
    17c2:	b8 01       	movw	r22, r16
    17c4:	89 53       	subi	r24, 0x39	; 57
    17c6:	96 4f       	sbci	r25, 0xF6	; 246
    17c8:	0e 94 9b 01 	call	0x336	; 0x336 <vListInsertEnd>
    17cc:	e0 91 eb 09 	lds	r30, 0x09EB	; 0x8009eb <pxCurrentTCB>
    17d0:	f0 91 ec 09 	lds	r31, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    17d4:	9e 89       	ldd	r25, Y+22	; 0x16
    17d6:	86 89       	ldd	r24, Z+22	; 0x16
    17d8:	98 17       	cp	r25, r24
    17da:	58 f0       	brcs	.+22     	; 0x17f2 <xTaskResumeAll+0xa6>
    17dc:	dc 2c       	mov	r13, r12
    17de:	09 c0       	rjmp	.+18     	; 0x17f2 <xTaskResumeAll+0xa6>
    17e0:	d1 2c       	mov	r13, r1
    17e2:	0f 2e       	mov	r0, r31
    17e4:	f8 ea       	ldi	r31, 0xA8	; 168
    17e6:	ef 2e       	mov	r14, r31
    17e8:	f9 e0       	ldi	r31, 0x09	; 9
    17ea:	ff 2e       	mov	r15, r31
    17ec:	f0 2d       	mov	r31, r0
    17ee:	cc 24       	eor	r12, r12
    17f0:	c3 94       	inc	r12
    17f2:	f7 01       	movw	r30, r14
    17f4:	80 81       	ld	r24, Z
    17f6:	81 11       	cpse	r24, r1
    17f8:	c2 cf       	rjmp	.-124    	; 0x177e <xTaskResumeAll+0x32>
    17fa:	80 91 96 09 	lds	r24, 0x0996	; 0x800996 <uxMissedTicks>
    17fe:	88 23       	and	r24, r24
    1800:	79 f0       	breq	.+30     	; 0x1820 <xTaskResumeAll+0xd4>
    1802:	80 91 96 09 	lds	r24, 0x0996	; 0x800996 <uxMissedTicks>
    1806:	88 23       	and	r24, r24
    1808:	91 f0       	breq	.+36     	; 0x182e <xTaskResumeAll+0xe2>
    180a:	dc de       	rcall	.-584    	; 0x15c4 <vTaskIncrementTick>
    180c:	80 91 96 09 	lds	r24, 0x0996	; 0x800996 <uxMissedTicks>
    1810:	81 50       	subi	r24, 0x01	; 1
    1812:	80 93 96 09 	sts	0x0996, r24	; 0x800996 <uxMissedTicks>
    1816:	80 91 96 09 	lds	r24, 0x0996	; 0x800996 <uxMissedTicks>
    181a:	81 11       	cpse	r24, r1
    181c:	f6 cf       	rjmp	.-20     	; 0x180a <xTaskResumeAll+0xbe>
    181e:	07 c0       	rjmp	.+14     	; 0x182e <xTaskResumeAll+0xe2>
    1820:	f1 e0       	ldi	r31, 0x01	; 1
    1822:	df 16       	cp	r13, r31
    1824:	21 f0       	breq	.+8      	; 0x182e <xTaskResumeAll+0xe2>
    1826:	80 91 95 09 	lds	r24, 0x0995	; 0x800995 <xMissedYield>
    182a:	81 30       	cpi	r24, 0x01	; 1
    182c:	39 f4       	brne	.+14     	; 0x183c <xTaskResumeAll+0xf0>
    182e:	10 92 95 09 	sts	0x0995, r1	; 0x800995 <xMissedYield>
    1832:	b0 dc       	rcall	.-1696   	; 0x1194 <vPortYield>
    1834:	81 e0       	ldi	r24, 0x01	; 1
    1836:	03 c0       	rjmp	.+6      	; 0x183e <xTaskResumeAll+0xf2>
    1838:	80 e0       	ldi	r24, 0x00	; 0
    183a:	01 c0       	rjmp	.+2      	; 0x183e <xTaskResumeAll+0xf2>
    183c:	80 e0       	ldi	r24, 0x00	; 0
    183e:	0f 90       	pop	r0
    1840:	0f be       	out	0x3f, r0	; 63
    1842:	df 91       	pop	r29
    1844:	cf 91       	pop	r28
    1846:	1f 91       	pop	r17
    1848:	0f 91       	pop	r16
    184a:	ff 90       	pop	r15
    184c:	ef 90       	pop	r14
    184e:	df 90       	pop	r13
    1850:	cf 90       	pop	r12
    1852:	08 95       	ret

00001854 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1854:	cf 93       	push	r28
    1856:	df 93       	push	r29
    1858:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    185a:	89 2b       	or	r24, r25
		{
			vTaskSuspendAll();
    185c:	99 f0       	breq	.+38     	; 0x1884 <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    185e:	ac de       	rcall	.-680    	; 0x15b8 <vTaskSuspendAll>
    1860:	80 91 9b 09 	lds	r24, 0x099B	; 0x80099b <xTickCount>
    1864:	90 91 9c 09 	lds	r25, 0x099C	; 0x80099c <xTickCount+0x1>
    1868:	c8 0f       	add	r28, r24

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    186a:	d9 1f       	adc	r29, r25
    186c:	80 91 eb 09 	lds	r24, 0x09EB	; 0x8009eb <pxCurrentTCB>
    1870:	90 91 ec 09 	lds	r25, 0x09EC	; 0x8009ec <pxCurrentTCB+0x1>
    1874:	02 96       	adiw	r24, 0x02	; 2
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1876:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    187a:	ce 01       	movw	r24, r28
    187c:	3e dd       	rcall	.-1412   	; 0x12fa <prvAddCurrentTaskToDelayedList>
		{
			portYIELD_WITHIN_API();
    187e:	66 df       	rcall	.-308    	; 0x174c <xTaskResumeAll>
    1880:	81 11       	cpse	r24, r1
		}
	}
    1882:	01 c0       	rjmp	.+2      	; 0x1886 <vTaskDelay+0x32>
    1884:	87 dc       	rcall	.-1778   	; 0x1194 <vPortYield>
    1886:	df 91       	pop	r29
    1888:	cf 91       	pop	r28
    188a:	08 95       	ret

0000188c <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    188c:	0f 2e       	mov	r0, r31
    188e:	ff e9       	ldi	r31, 0x9F	; 159
    1890:	ef 2e       	mov	r14, r31
    1892:	f9 e0       	ldi	r31, 0x09	; 9
    1894:	ff 2e       	mov	r15, r31
    1896:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1898:	c7 ec       	ldi	r28, 0xC7	; 199
    189a:	d9 e0       	ldi	r29, 0x09	; 9
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    189c:	80 91 9e 09 	lds	r24, 0x099E	; 0x80099e <uxTasksDeleted>
    18a0:	88 23       	and	r24, r24
		{
			vTaskSuspendAll();
    18a2:	41 f1       	breq	.+80     	; 0x18f4 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    18a4:	89 de       	rcall	.-750    	; 0x15b8 <vTaskSuspendAll>
			xTaskResumeAll();
    18a6:	d7 01       	movw	r26, r14
    18a8:	1c 91       	ld	r17, X

			if( xListIsEmpty == pdFALSE )
    18aa:	50 df       	rcall	.-352    	; 0x174c <xTaskResumeAll>
    18ac:	11 23       	and	r17, r17
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    18ae:	11 f1       	breq	.+68     	; 0x18f4 <prvIdleTask+0x68>
    18b0:	0f b6       	in	r0, 0x3f	; 63
    18b2:	f8 94       	cli
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    18b4:	0f 92       	push	r0
    18b6:	d7 01       	movw	r26, r14
    18b8:	15 96       	adiw	r26, 0x05	; 5
    18ba:	ed 91       	ld	r30, X+
    18bc:	fc 91       	ld	r31, X
    18be:	16 97       	sbiw	r26, 0x06	; 6
    18c0:	06 81       	ldd	r16, Z+6	; 0x06
					vListRemove( &( pxTCB->xGenericListItem ) );
    18c2:	17 81       	ldd	r17, Z+7	; 0x07
    18c4:	c8 01       	movw	r24, r16
    18c6:	02 96       	adiw	r24, 0x02	; 2
    18c8:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
					--uxCurrentNumberOfTasks;
    18cc:	80 91 9d 09 	lds	r24, 0x099D	; 0x80099d <uxCurrentNumberOfTasks>
    18d0:	81 50       	subi	r24, 0x01	; 1
    18d2:	80 93 9d 09 	sts	0x099D, r24	; 0x80099d <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    18d6:	80 91 9e 09 	lds	r24, 0x099E	; 0x80099e <uxTasksDeleted>
    18da:	81 50       	subi	r24, 0x01	; 1
    18dc:	80 93 9e 09 	sts	0x099E, r24	; 0x80099e <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    18e0:	0f 90       	pop	r0
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    18e2:	0f be       	out	0x3f, r0	; 63
    18e4:	f8 01       	movw	r30, r16
    18e6:	87 89       	ldd	r24, Z+23	; 0x17
    18e8:	90 8d       	ldd	r25, Z+24	; 0x18
    18ea:	0e 94 88 01 	call	0x310	; 0x310 <vPortFree>
		vPortFree( pxTCB );
    18ee:	c8 01       	movw	r24, r16
    18f0:	0e 94 88 01 	call	0x310	; 0x310 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    18f4:	88 81       	ld	r24, Y
			{
				taskYIELD();
    18f6:	82 30       	cpi	r24, 0x02	; 2
    18f8:	88 f2       	brcs	.-94     	; 0x189c <prvIdleTask+0x10>
    18fa:	4c dc       	rcall	.-1896   	; 0x1194 <vPortYield>
    18fc:	cf cf       	rjmp	.-98     	; 0x189c <prvIdleTask+0x10>

000018fe <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    18fe:	80 91 97 09 	lds	r24, 0x0997	; 0x800997 <uxSchedulerSuspended>
    1902:	81 11       	cpse	r24, r1
    1904:	13 c0       	rjmp	.+38     	; 0x192c <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1906:	80 91 99 09 	lds	r24, 0x0999	; 0x800999 <uxTopReadyPriority>
    190a:	90 e0       	ldi	r25, 0x00	; 0
    190c:	fc 01       	movw	r30, r24
    190e:	ee 0f       	add	r30, r30
    1910:	ff 1f       	adc	r31, r31
    1912:	ee 0f       	add	r30, r30
    1914:	ff 1f       	adc	r31, r31
    1916:	ee 0f       	add	r30, r30
    1918:	ff 1f       	adc	r31, r31
    191a:	8e 0f       	add	r24, r30
    191c:	9f 1f       	adc	r25, r31
    191e:	fc 01       	movw	r30, r24
    1920:	e9 53       	subi	r30, 0x39	; 57
    1922:	f6 4f       	sbci	r31, 0xF6	; 246
    1924:	80 81       	ld	r24, Z
    1926:	88 23       	and	r24, r24
    1928:	29 f0       	breq	.+10     	; 0x1934 <vTaskSwitchContext+0x36>
    192a:	1b c0       	rjmp	.+54     	; 0x1962 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    192c:	81 e0       	ldi	r24, 0x01	; 1
    192e:	80 93 95 09 	sts	0x0995, r24	; 0x800995 <xMissedYield>
    1932:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1934:	80 91 99 09 	lds	r24, 0x0999	; 0x800999 <uxTopReadyPriority>
    1938:	81 50       	subi	r24, 0x01	; 1
    193a:	80 93 99 09 	sts	0x0999, r24	; 0x800999 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    193e:	80 91 99 09 	lds	r24, 0x0999	; 0x800999 <uxTopReadyPriority>
    1942:	90 e0       	ldi	r25, 0x00	; 0
    1944:	fc 01       	movw	r30, r24
    1946:	ee 0f       	add	r30, r30
    1948:	ff 1f       	adc	r31, r31
    194a:	ee 0f       	add	r30, r30
    194c:	ff 1f       	adc	r31, r31
    194e:	ee 0f       	add	r30, r30
    1950:	ff 1f       	adc	r31, r31
    1952:	8e 0f       	add	r24, r30
    1954:	9f 1f       	adc	r25, r31
    1956:	fc 01       	movw	r30, r24
    1958:	e9 53       	subi	r30, 0x39	; 57
    195a:	f6 4f       	sbci	r31, 0xF6	; 246
    195c:	80 81       	ld	r24, Z
    195e:	88 23       	and	r24, r24
    1960:	49 f3       	breq	.-46     	; 0x1934 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1962:	80 91 99 09 	lds	r24, 0x0999	; 0x800999 <uxTopReadyPriority>
    1966:	90 e0       	ldi	r25, 0x00	; 0
    1968:	9c 01       	movw	r18, r24
    196a:	22 0f       	add	r18, r18
    196c:	33 1f       	adc	r19, r19
    196e:	22 0f       	add	r18, r18
    1970:	33 1f       	adc	r19, r19
    1972:	22 0f       	add	r18, r18
    1974:	33 1f       	adc	r19, r19
    1976:	28 0f       	add	r18, r24
    1978:	39 1f       	adc	r19, r25
    197a:	d9 01       	movw	r26, r18
    197c:	a9 53       	subi	r26, 0x39	; 57
    197e:	b6 4f       	sbci	r27, 0xF6	; 246
    1980:	11 96       	adiw	r26, 0x01	; 1
    1982:	ed 91       	ld	r30, X+
    1984:	fc 91       	ld	r31, X
    1986:	12 97       	sbiw	r26, 0x02	; 2
    1988:	02 80       	ldd	r0, Z+2	; 0x02
    198a:	f3 81       	ldd	r31, Z+3	; 0x03
    198c:	e0 2d       	mov	r30, r0
    198e:	12 96       	adiw	r26, 0x02	; 2
    1990:	fc 93       	st	X, r31
    1992:	ee 93       	st	-X, r30
    1994:	11 97       	sbiw	r26, 0x01	; 1
    1996:	26 53       	subi	r18, 0x36	; 54
    1998:	36 4f       	sbci	r19, 0xF6	; 246
    199a:	e2 17       	cp	r30, r18
    199c:	f3 07       	cpc	r31, r19
    199e:	29 f4       	brne	.+10     	; 0x19aa <vTaskSwitchContext+0xac>
    19a0:	22 81       	ldd	r18, Z+2	; 0x02
    19a2:	33 81       	ldd	r19, Z+3	; 0x03
    19a4:	fd 01       	movw	r30, r26
    19a6:	32 83       	std	Z+2, r19	; 0x02
    19a8:	21 83       	std	Z+1, r18	; 0x01
    19aa:	fc 01       	movw	r30, r24
    19ac:	ee 0f       	add	r30, r30
    19ae:	ff 1f       	adc	r31, r31
    19b0:	ee 0f       	add	r30, r30
    19b2:	ff 1f       	adc	r31, r31
    19b4:	ee 0f       	add	r30, r30
    19b6:	ff 1f       	adc	r31, r31
    19b8:	8e 0f       	add	r24, r30
    19ba:	9f 1f       	adc	r25, r31
    19bc:	fc 01       	movw	r30, r24
    19be:	e9 53       	subi	r30, 0x39	; 57
    19c0:	f6 4f       	sbci	r31, 0xF6	; 246
    19c2:	01 80       	ldd	r0, Z+1	; 0x01
    19c4:	f2 81       	ldd	r31, Z+2	; 0x02
    19c6:	e0 2d       	mov	r30, r0
    19c8:	86 81       	ldd	r24, Z+6	; 0x06
    19ca:	97 81       	ldd	r25, Z+7	; 0x07
    19cc:	90 93 ec 09 	sts	0x09EC, r25	; 0x8009ec <pxCurrentTCB+0x1>
    19d0:	80 93 eb 09 	sts	0x09EB, r24	; 0x8009eb <pxCurrentTCB>
    19d4:	08 95       	ret

000019d6 <__udivmodqi4>:
    19d6:	99 1b       	sub	r25, r25
    19d8:	79 e0       	ldi	r23, 0x09	; 9
    19da:	04 c0       	rjmp	.+8      	; 0x19e4 <__udivmodqi4_ep>

000019dc <__udivmodqi4_loop>:
    19dc:	99 1f       	adc	r25, r25
    19de:	96 17       	cp	r25, r22
    19e0:	08 f0       	brcs	.+2      	; 0x19e4 <__udivmodqi4_ep>
    19e2:	96 1b       	sub	r25, r22

000019e4 <__udivmodqi4_ep>:
    19e4:	88 1f       	adc	r24, r24
    19e6:	7a 95       	dec	r23
    19e8:	c9 f7       	brne	.-14     	; 0x19dc <__udivmodqi4_loop>
    19ea:	80 95       	com	r24
    19ec:	08 95       	ret

000019ee <__tablejump2__>:
    19ee:	ee 0f       	add	r30, r30
    19f0:	ff 1f       	adc	r31, r31
    19f2:	00 24       	eor	r0, r0
    19f4:	00 1c       	adc	r0, r0
    19f6:	0b be       	out	0x3b, r0	; 59
    19f8:	07 90       	elpm	r0, Z+
    19fa:	f6 91       	elpm	r31, Z
    19fc:	e0 2d       	mov	r30, r0
    19fe:	09 94       	ijmp

00001a00 <memset>:
    1a00:	dc 01       	movw	r26, r24
    1a02:	01 c0       	rjmp	.+2      	; 0x1a06 <memset+0x6>
    1a04:	6d 93       	st	X+, r22
    1a06:	41 50       	subi	r20, 0x01	; 1
    1a08:	50 40       	sbci	r21, 0x00	; 0
    1a0a:	e0 f7       	brcc	.-8      	; 0x1a04 <memset+0x4>
    1a0c:	08 95       	ret

00001a0e <strncpy>:
    1a0e:	fb 01       	movw	r30, r22
    1a10:	dc 01       	movw	r26, r24
    1a12:	41 50       	subi	r20, 0x01	; 1
    1a14:	50 40       	sbci	r21, 0x00	; 0
    1a16:	48 f0       	brcs	.+18     	; 0x1a2a <strncpy+0x1c>
    1a18:	01 90       	ld	r0, Z+
    1a1a:	0d 92       	st	X+, r0
    1a1c:	00 20       	and	r0, r0
    1a1e:	c9 f7       	brne	.-14     	; 0x1a12 <strncpy+0x4>
    1a20:	01 c0       	rjmp	.+2      	; 0x1a24 <strncpy+0x16>
    1a22:	1d 92       	st	X+, r1
    1a24:	41 50       	subi	r20, 0x01	; 1
    1a26:	50 40       	sbci	r21, 0x00	; 0
    1a28:	e0 f7       	brcc	.-8      	; 0x1a22 <strncpy+0x14>
    1a2a:	08 95       	ret

00001a2c <_exit>:
    1a2c:	f8 94       	cli

00001a2e <__stop_program>:
    1a2e:	ff cf       	rjmp	.-2      	; 0x1a2e <__stop_program>
