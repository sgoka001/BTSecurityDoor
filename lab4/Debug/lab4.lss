
lab4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a8  00800100  000019fa  00001a8e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000019fa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000840  008001a8  008001a8  00001b36  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001b36  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001b68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000258  00000000  00000000  00001ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003766  00000000  00000000  00001e00  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001107  00000000  00000000  00005566  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002124  00000000  00000000  0000666d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000062c  00000000  00000000  00008794  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000fb7  00000000  00000000  00008dc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000201c  00000000  00000000  00009d77  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000270  00000000  00000000  0000bd93  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	42 c1       	rjmp	.+644    	; 0x286 <__ctors_end>
       2:	00 00       	nop
       4:	5e c1       	rjmp	.+700    	; 0x2c2 <__bad_interrupt>
       6:	00 00       	nop
       8:	5c c1       	rjmp	.+696    	; 0x2c2 <__bad_interrupt>
       a:	00 00       	nop
       c:	5a c1       	rjmp	.+692    	; 0x2c2 <__bad_interrupt>
       e:	00 00       	nop
      10:	58 c1       	rjmp	.+688    	; 0x2c2 <__bad_interrupt>
      12:	00 00       	nop
      14:	56 c1       	rjmp	.+684    	; 0x2c2 <__bad_interrupt>
      16:	00 00       	nop
      18:	54 c1       	rjmp	.+680    	; 0x2c2 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	52 c1       	rjmp	.+676    	; 0x2c2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	50 c1       	rjmp	.+672    	; 0x2c2 <__bad_interrupt>
      22:	00 00       	nop
      24:	4e c1       	rjmp	.+668    	; 0x2c2 <__bad_interrupt>
      26:	00 00       	nop
      28:	4c c1       	rjmp	.+664    	; 0x2c2 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4a c1       	rjmp	.+660    	; 0x2c2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	48 c1       	rjmp	.+656    	; 0x2c2 <__bad_interrupt>
      32:	00 00       	nop
      34:	0c 94 60 09 	jmp	0x12c0	; 0x12c0 <__vector_13>
      38:	44 c1       	rjmp	.+648    	; 0x2c2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	42 c1       	rjmp	.+644    	; 0x2c2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	40 c1       	rjmp	.+640    	; 0x2c2 <__bad_interrupt>
      42:	00 00       	nop
      44:	3e c1       	rjmp	.+636    	; 0x2c2 <__bad_interrupt>
      46:	00 00       	nop
      48:	3c c1       	rjmp	.+632    	; 0x2c2 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	3a c1       	rjmp	.+628    	; 0x2c2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	38 c1       	rjmp	.+624    	; 0x2c2 <__bad_interrupt>
      52:	00 00       	nop
      54:	36 c1       	rjmp	.+620    	; 0x2c2 <__bad_interrupt>
      56:	00 00       	nop
      58:	34 c1       	rjmp	.+616    	; 0x2c2 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	32 c1       	rjmp	.+612    	; 0x2c2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	30 c1       	rjmp	.+608    	; 0x2c2 <__bad_interrupt>
      62:	00 00       	nop
      64:	2e c1       	rjmp	.+604    	; 0x2c2 <__bad_interrupt>
      66:	00 00       	nop
      68:	2c c1       	rjmp	.+600    	; 0x2c2 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2a c1       	rjmp	.+596    	; 0x2c2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	28 c1       	rjmp	.+592    	; 0x2c2 <__bad_interrupt>
      72:	00 00       	nop
      74:	26 c1       	rjmp	.+588    	; 0x2c2 <__bad_interrupt>
      76:	00 00       	nop
      78:	24 c1       	rjmp	.+584    	; 0x2c2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	22 c1       	rjmp	.+580    	; 0x2c2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	20 c1       	rjmp	.+576    	; 0x2c2 <__bad_interrupt>
      82:	00 00       	nop
      84:	1e c1       	rjmp	.+572    	; 0x2c2 <__bad_interrupt>
      86:	00 00       	nop
      88:	1c c1       	rjmp	.+568    	; 0x2c2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	47 04       	cpc	r4, r7
      8e:	4e 04       	cpc	r4, r14
      90:	5d 04       	cpc	r5, r13
      92:	6b 04       	cpc	r6, r11
      94:	85 04       	cpc	r8, r5
      96:	93 04       	cpc	r9, r3
      98:	ad 04       	cpc	r10, r13
      9a:	bb 04       	cpc	r11, r11
      9c:	d5 04       	cpc	r13, r5
      9e:	e3 04       	cpc	r14, r3
      a0:	fd 04       	cpc	r15, r13
      a2:	19 05       	cpc	r17, r9
      a4:	06 05       	cpc	r16, r6

000000a6 <CHARSET>:
      a6:	00 00 00 00 00 00 00 5f 00 00 00 07 00 07 00 14     ......._........
      b6:	7f 14 7f 14 24 2a 7f 2a 12 23 13 08 64 62 36 49     ....$*.*.#..db6I
      c6:	55 22 50 00 05 03 00 00 00 1c 22 41 00 00 41 22     U"P......."A..A"
      d6:	1c 00 14 08 3e 08 14 08 08 3e 08 08 00 50 30 00     ....>....>...P0.
      e6:	00 08 08 08 08 08 00 60 60 00 00 20 10 08 04 02     .......``.. ....
      f6:	3e 51 49 45 3e 00 42 7f 40 00 42 61 51 49 46 21     >QIE>.B.@.BaQIF!
     106:	41 45 4b 31 18 14 12 7f 10 27 45 45 45 39 3c 4a     AEK1.....'EEE9<J
     116:	49 49 30 01 71 09 05 03 36 49 49 49 36 06 49 49     II0.q...6III6.II
     126:	29 1e 00 36 36 00 00 00 56 36 00 00 08 14 22 41     )..66...V6...."A
     136:	00 14 14 14 14 14 00 41 22 14 08 02 01 51 09 06     .......A"....Q..
     146:	32 49 79 41 3e 7e 11 11 11 7e 7f 49 49 49 36 3e     2IyA>~...~.III6>
     156:	41 41 41 22 7f 41 41 22 1c 7f 49 49 49 41 7f 09     AAA".AA"..IIIA..
     166:	09 09 01 3e 41 49 49 7a 7f 08 08 08 7f 00 41 7f     ...>AIIz......A.
     176:	41 00 20 40 41 3f 01 7f 08 14 22 41 7f 40 40 40     A. @A?...."A.@@@
     186:	40 7f 02 0c 02 7f 7f 04 08 10 7f 3e 41 41 41 3e     @..........>AAA>
     196:	7f 09 09 09 06 3e 41 51 21 5e 7f 09 19 29 46 46     .....>AQ!^...)FF
     1a6:	49 49 49 31 01 01 7f 01 01 3f 40 40 40 3f 1f 20     III1.....?@@@?. 
     1b6:	40 20 1f 3f 40 38 40 3f 63 14 08 14 63 07 08 70     @ .?@8@?c...c..p
     1c6:	08 07 61 51 49 45 43 00 7f 41 41 00 02 04 08 10     ..aQIEC..AA.....
     1d6:	20 00 41 41 7f 00 04 02 01 02 04 40 40 40 40 40      .AA.......@@@@@
     1e6:	00 01 02 04 00 20 54 54 54 78 7f 48 44 44 38 38     ..... TTTx.HDD88
     1f6:	44 44 44 20 38 44 44 48 7f 38 54 54 54 18 08 7e     DDD 8DDH.8TTT..~
     206:	09 01 02 0c 52 52 52 3e 7f 08 04 04 78 00 44 7d     ....RRR>....x.D}
     216:	40 00 20 40 44 3d 00 7f 10 28 44 00 00 41 7f 40     @. @D=...(D..A.@
     226:	00 7c 04 18 04 78 7c 08 04 04 78 38 44 44 44 38     .|...x|...x8DDD8
     236:	7c 14 14 14 08 08 14 14 18 7c 7c 08 04 04 08 48     |........||....H
     246:	54 54 54 20 04 3f 44 40 20 3c 40 40 20 7c 1c 20     TTT .?D@ <@@ |. 
     256:	40 20 1c 3c 40 30 40 3c 44 28 10 28 44 0c 50 50     @ .<@0@<D(.(D.PP
     266:	50 3c 44 64 54 4c 44 00 08 36 41 00 00 00 7f 00     P<DdTLD..6A.....
     276:	00 00 41 36 08 00 10 08 08 10 08 00 00 00 00 00     ..A6............

00000286 <__ctors_end>:
     286:	11 24       	eor	r1, r1
     288:	1f be       	out	0x3f, r1	; 63
     28a:	cf ef       	ldi	r28, 0xFF	; 255
     28c:	d0 e4       	ldi	r29, 0x40	; 64
     28e:	de bf       	out	0x3e, r29	; 62
     290:	cd bf       	out	0x3d, r28	; 61

00000292 <__do_copy_data>:
     292:	11 e0       	ldi	r17, 0x01	; 1
     294:	a0 e0       	ldi	r26, 0x00	; 0
     296:	b1 e0       	ldi	r27, 0x01	; 1
     298:	ea ef       	ldi	r30, 0xFA	; 250
     29a:	f9 e1       	ldi	r31, 0x19	; 25
     29c:	00 e0       	ldi	r16, 0x00	; 0
     29e:	0b bf       	out	0x3b, r16	; 59
     2a0:	02 c0       	rjmp	.+4      	; 0x2a6 <__do_copy_data+0x14>
     2a2:	07 90       	elpm	r0, Z+
     2a4:	0d 92       	st	X+, r0
     2a6:	a8 3a       	cpi	r26, 0xA8	; 168
     2a8:	b1 07       	cpc	r27, r17
     2aa:	d9 f7       	brne	.-10     	; 0x2a2 <__do_copy_data+0x10>

000002ac <__do_clear_bss>:
     2ac:	29 e0       	ldi	r18, 0x09	; 9
     2ae:	a8 ea       	ldi	r26, 0xA8	; 168
     2b0:	b1 e0       	ldi	r27, 0x01	; 1
     2b2:	01 c0       	rjmp	.+2      	; 0x2b6 <.do_clear_bss_start>

000002b4 <.do_clear_bss_loop>:
     2b4:	1d 92       	st	X+, r1

000002b6 <.do_clear_bss_start>:
     2b6:	a8 3e       	cpi	r26, 0xE8	; 232
     2b8:	b2 07       	cpc	r27, r18
     2ba:	e1 f7       	brne	.-8      	; 0x2b4 <.do_clear_bss_loop>
     2bc:	92 d6       	rcall	.+3364   	; 0xfe2 <main>
     2be:	0c 94 fb 0c 	jmp	0x19f6	; 0x19f6 <_exit>

000002c2 <__bad_interrupt>:
     2c2:	9e ce       	rjmp	.-708    	; 0x0 <__vectors>

000002c4 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     2c4:	cf 93       	push	r28
     2c6:	df 93       	push	r29
     2c8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     2ca:	0e 94 c1 0a 	call	0x1582	; 0x1582 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     2ce:	20 91 a8 01 	lds	r18, 0x01A8	; 0x8001a8 <__data_end>
     2d2:	30 91 a9 01 	lds	r19, 0x01A9	; 0x8001a9 <__data_end+0x1>
     2d6:	c9 01       	movw	r24, r18
     2d8:	8c 0f       	add	r24, r28
     2da:	9d 1f       	adc	r25, r29
     2dc:	8c 3d       	cpi	r24, 0xDC	; 220
     2de:	45 e0       	ldi	r20, 0x05	; 5
     2e0:	94 07       	cpc	r25, r20
     2e2:	58 f4       	brcc	.+22     	; 0x2fa <pvPortMalloc+0x36>
     2e4:	28 17       	cp	r18, r24
     2e6:	39 07       	cpc	r19, r25
     2e8:	58 f4       	brcc	.+22     	; 0x300 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     2ea:	e9 01       	movw	r28, r18
     2ec:	c6 55       	subi	r28, 0x56	; 86
     2ee:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
     2f0:	90 93 a9 01 	sts	0x01A9, r25	; 0x8001a9 <__data_end+0x1>
     2f4:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <__data_end>
     2f8:	05 c0       	rjmp	.+10     	; 0x304 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     2fa:	c0 e0       	ldi	r28, 0x00	; 0
     2fc:	d0 e0       	ldi	r29, 0x00	; 0
     2fe:	02 c0       	rjmp	.+4      	; 0x304 <pvPortMalloc+0x40>
     300:	c0 e0       	ldi	r28, 0x00	; 0
     302:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     304:	0e 94 8b 0b 	call	0x1716	; 0x1716 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     308:	ce 01       	movw	r24, r28
     30a:	df 91       	pop	r29
     30c:	cf 91       	pop	r28
     30e:	08 95       	ret

00000310 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     310:	08 95       	ret

00000312 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     312:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     314:	03 96       	adiw	r24, 0x03	; 3
     316:	92 83       	std	Z+2, r25	; 0x02
     318:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     31a:	2f ef       	ldi	r18, 0xFF	; 255
     31c:	3f ef       	ldi	r19, 0xFF	; 255
     31e:	34 83       	std	Z+4, r19	; 0x04
     320:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     322:	96 83       	std	Z+6, r25	; 0x06
     324:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     326:	90 87       	std	Z+8, r25	; 0x08
     328:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     32a:	10 82       	st	Z, r1
     32c:	08 95       	ret

0000032e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     32e:	fc 01       	movw	r30, r24
     330:	11 86       	std	Z+9, r1	; 0x09
     332:	10 86       	std	Z+8, r1	; 0x08
     334:	08 95       	ret

00000336 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     336:	cf 93       	push	r28
     338:	df 93       	push	r29
     33a:	fc 01       	movw	r30, r24
     33c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     33e:	21 81       	ldd	r18, Z+1	; 0x01
     340:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     342:	e9 01       	movw	r28, r18
     344:	8a 81       	ldd	r24, Y+2	; 0x02
     346:	9b 81       	ldd	r25, Y+3	; 0x03
     348:	13 96       	adiw	r26, 0x03	; 3
     34a:	9c 93       	st	X, r25
     34c:	8e 93       	st	-X, r24
     34e:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     350:	81 81       	ldd	r24, Z+1	; 0x01
     352:	92 81       	ldd	r25, Z+2	; 0x02
     354:	15 96       	adiw	r26, 0x05	; 5
     356:	9c 93       	st	X, r25
     358:	8e 93       	st	-X, r24
     35a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     35c:	8a 81       	ldd	r24, Y+2	; 0x02
     35e:	9b 81       	ldd	r25, Y+3	; 0x03
     360:	ec 01       	movw	r28, r24
     362:	7d 83       	std	Y+5, r23	; 0x05
     364:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     366:	e9 01       	movw	r28, r18
     368:	7b 83       	std	Y+3, r23	; 0x03
     36a:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     36c:	72 83       	std	Z+2, r23	; 0x02
     36e:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     370:	19 96       	adiw	r26, 0x09	; 9
     372:	fc 93       	st	X, r31
     374:	ee 93       	st	-X, r30
     376:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     378:	80 81       	ld	r24, Z
     37a:	8f 5f       	subi	r24, 0xFF	; 255
     37c:	80 83       	st	Z, r24
}
     37e:	df 91       	pop	r29
     380:	cf 91       	pop	r28
     382:	08 95       	ret

00000384 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     384:	cf 93       	push	r28
     386:	df 93       	push	r29
     388:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     38a:	48 81       	ld	r20, Y
     38c:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     38e:	4f 3f       	cpi	r20, 0xFF	; 255
     390:	2f ef       	ldi	r18, 0xFF	; 255
     392:	52 07       	cpc	r21, r18
     394:	31 f4       	brne	.+12     	; 0x3a2 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     396:	dc 01       	movw	r26, r24
     398:	17 96       	adiw	r26, 0x07	; 7
     39a:	ed 91       	ld	r30, X+
     39c:	fc 91       	ld	r31, X
     39e:	18 97       	sbiw	r26, 0x08	; 8
     3a0:	17 c0       	rjmp	.+46     	; 0x3d0 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     3a2:	fc 01       	movw	r30, r24
     3a4:	33 96       	adiw	r30, 0x03	; 3
     3a6:	dc 01       	movw	r26, r24
     3a8:	15 96       	adiw	r26, 0x05	; 5
     3aa:	2d 91       	ld	r18, X+
     3ac:	3c 91       	ld	r19, X
     3ae:	16 97       	sbiw	r26, 0x06	; 6
     3b0:	d9 01       	movw	r26, r18
     3b2:	2d 91       	ld	r18, X+
     3b4:	3c 91       	ld	r19, X
     3b6:	42 17       	cp	r20, r18
     3b8:	53 07       	cpc	r21, r19
     3ba:	50 f0       	brcs	.+20     	; 0x3d0 <vListInsert+0x4c>
     3bc:	02 80       	ldd	r0, Z+2	; 0x02
     3be:	f3 81       	ldd	r31, Z+3	; 0x03
     3c0:	e0 2d       	mov	r30, r0
     3c2:	a2 81       	ldd	r26, Z+2	; 0x02
     3c4:	b3 81       	ldd	r27, Z+3	; 0x03
     3c6:	2d 91       	ld	r18, X+
     3c8:	3c 91       	ld	r19, X
     3ca:	42 17       	cp	r20, r18
     3cc:	53 07       	cpc	r21, r19
     3ce:	b0 f7       	brcc	.-20     	; 0x3bc <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     3d0:	a2 81       	ldd	r26, Z+2	; 0x02
     3d2:	b3 81       	ldd	r27, Z+3	; 0x03
     3d4:	bb 83       	std	Y+3, r27	; 0x03
     3d6:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     3d8:	15 96       	adiw	r26, 0x05	; 5
     3da:	dc 93       	st	X, r29
     3dc:	ce 93       	st	-X, r28
     3de:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     3e0:	fd 83       	std	Y+5, r31	; 0x05
     3e2:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     3e4:	d3 83       	std	Z+3, r29	; 0x03
     3e6:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3e8:	99 87       	std	Y+9, r25	; 0x09
     3ea:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3ec:	fc 01       	movw	r30, r24
     3ee:	20 81       	ld	r18, Z
     3f0:	2f 5f       	subi	r18, 0xFF	; 255
     3f2:	20 83       	st	Z, r18
}
     3f4:	df 91       	pop	r29
     3f6:	cf 91       	pop	r28
     3f8:	08 95       	ret

000003fa <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     3fa:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3fc:	a2 81       	ldd	r26, Z+2	; 0x02
     3fe:	b3 81       	ldd	r27, Z+3	; 0x03
     400:	84 81       	ldd	r24, Z+4	; 0x04
     402:	95 81       	ldd	r25, Z+5	; 0x05
     404:	15 96       	adiw	r26, 0x05	; 5
     406:	9c 93       	st	X, r25
     408:	8e 93       	st	-X, r24
     40a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     40c:	a4 81       	ldd	r26, Z+4	; 0x04
     40e:	b5 81       	ldd	r27, Z+5	; 0x05
     410:	82 81       	ldd	r24, Z+2	; 0x02
     412:	93 81       	ldd	r25, Z+3	; 0x03
     414:	13 96       	adiw	r26, 0x03	; 3
     416:	9c 93       	st	X, r25
     418:	8e 93       	st	-X, r24
     41a:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     41c:	a0 85       	ldd	r26, Z+8	; 0x08
     41e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     420:	11 96       	adiw	r26, 0x01	; 1
     422:	8d 91       	ld	r24, X+
     424:	9c 91       	ld	r25, X
     426:	12 97       	sbiw	r26, 0x02	; 2
     428:	e8 17       	cp	r30, r24
     42a:	f9 07       	cpc	r31, r25
     42c:	31 f4       	brne	.+12     	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     42e:	84 81       	ldd	r24, Z+4	; 0x04
     430:	95 81       	ldd	r25, Z+5	; 0x05
     432:	12 96       	adiw	r26, 0x02	; 2
     434:	9c 93       	st	X, r25
     436:	8e 93       	st	-X, r24
     438:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     43a:	11 86       	std	Z+9, r1	; 0x09
     43c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     43e:	8c 91       	ld	r24, X
     440:	81 50       	subi	r24, 0x01	; 1
     442:	8c 93       	st	X, r24
     444:	08 95       	ret

00000446 <write>:
//////////////////////////////////////////////////////////////////////// LOCAL VARIABLES ////////////////////////////////////////////////////////////////////////

enum MotorState {READ_MOTION, MENU, READ_KEY_WAIT, READ_KEY_INIT, CURRENT_PASS, CHANGE_PASS, READ_KEY_WAIT_2, READ_KEY_INIT_2, READ_KEY_WAIT_3, READ_KEY_INIT_3, READ_KEY, LOCK, UNLOCK} motor_state;

void Motor_Init(){
	motor_state = READ_MOTION;
     446:	28 98       	cbi	0x05, 0	; 5
     448:	66 23       	and	r22, r22
     44a:	11 f0       	breq	.+4      	; 0x450 <write+0xa>
     44c:	2a 9a       	sbi	0x05, 2	; 5
     44e:	15 c0       	rjmp	.+42     	; 0x47a <write+0x34>
     450:	2a 98       	cbi	0x05, 2	; 5
     452:	13 c0       	rjmp	.+38     	; 0x47a <write+0x34>
     454:	ac 01       	movw	r20, r24
     456:	02 2e       	mov	r0, r18
     458:	02 c0       	rjmp	.+4      	; 0x45e <write+0x18>
     45a:	55 95       	asr	r21
     45c:	47 95       	ror	r20
     45e:	0a 94       	dec	r0
     460:	e2 f7       	brpl	.-8      	; 0x45a <write+0x14>
     462:	40 ff       	sbrs	r20, 0
     464:	02 c0       	rjmp	.+4      	; 0x46a <write+0x24>
     466:	2b 9a       	sbi	0x05, 3	; 5
     468:	01 c0       	rjmp	.+2      	; 0x46c <write+0x26>
     46a:	2b 98       	cbi	0x05, 3	; 5
     46c:	2c 9a       	sbi	0x05, 4	; 5
     46e:	2c 98       	cbi	0x05, 4	; 5
     470:	21 50       	subi	r18, 0x01	; 1
     472:	31 09       	sbc	r19, r1
     474:	78 f7       	brcc	.-34     	; 0x454 <write+0xe>
     476:	28 9a       	sbi	0x05, 0	; 5
     478:	08 95       	ret
     47a:	27 e0       	ldi	r18, 0x07	; 7
     47c:	30 e0       	ldi	r19, 0x00	; 0
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	e9 cf       	rjmp	.-46     	; 0x454 <write+0xe>

00000482 <write_cmd>:
     482:	60 e0       	ldi	r22, 0x00	; 0
     484:	e0 cf       	rjmp	.-64     	; 0x446 <write>
     486:	08 95       	ret

00000488 <GetKeypadKey>:
     488:	8f ee       	ldi	r24, 0xEF	; 239
     48a:	88 b9       	out	0x08, r24	; 8
     48c:	00 00       	nop
     48e:	30 9b       	sbis	0x06, 0	; 6
     490:	29 c0       	rjmp	.+82     	; 0x4e4 <GetKeypadKey+0x5c>
     492:	31 9b       	sbis	0x06, 1	; 6
     494:	29 c0       	rjmp	.+82     	; 0x4e8 <GetKeypadKey+0x60>
     496:	32 9b       	sbis	0x06, 2	; 6
     498:	29 c0       	rjmp	.+82     	; 0x4ec <GetKeypadKey+0x64>
     49a:	33 9b       	sbis	0x06, 3	; 6
     49c:	29 c0       	rjmp	.+82     	; 0x4f0 <GetKeypadKey+0x68>
     49e:	8f ed       	ldi	r24, 0xDF	; 223
     4a0:	88 b9       	out	0x08, r24	; 8
     4a2:	00 00       	nop
     4a4:	30 9b       	sbis	0x06, 0	; 6
     4a6:	26 c0       	rjmp	.+76     	; 0x4f4 <GetKeypadKey+0x6c>
     4a8:	31 9b       	sbis	0x06, 1	; 6
     4aa:	26 c0       	rjmp	.+76     	; 0x4f8 <GetKeypadKey+0x70>
     4ac:	32 9b       	sbis	0x06, 2	; 6
     4ae:	26 c0       	rjmp	.+76     	; 0x4fc <GetKeypadKey+0x74>
     4b0:	33 9b       	sbis	0x06, 3	; 6
     4b2:	26 c0       	rjmp	.+76     	; 0x500 <GetKeypadKey+0x78>
     4b4:	8f eb       	ldi	r24, 0xBF	; 191
     4b6:	88 b9       	out	0x08, r24	; 8
     4b8:	00 00       	nop
     4ba:	30 9b       	sbis	0x06, 0	; 6
     4bc:	23 c0       	rjmp	.+70     	; 0x504 <GetKeypadKey+0x7c>
     4be:	31 9b       	sbis	0x06, 1	; 6
     4c0:	23 c0       	rjmp	.+70     	; 0x508 <GetKeypadKey+0x80>
     4c2:	32 9b       	sbis	0x06, 2	; 6
     4c4:	23 c0       	rjmp	.+70     	; 0x50c <GetKeypadKey+0x84>
     4c6:	33 9b       	sbis	0x06, 3	; 6
     4c8:	23 c0       	rjmp	.+70     	; 0x510 <GetKeypadKey+0x88>
     4ca:	8f e7       	ldi	r24, 0x7F	; 127
     4cc:	88 b9       	out	0x08, r24	; 8
     4ce:	00 00       	nop
     4d0:	30 9b       	sbis	0x06, 0	; 6
     4d2:	20 c0       	rjmp	.+64     	; 0x514 <GetKeypadKey+0x8c>
     4d4:	31 9b       	sbis	0x06, 1	; 6
     4d6:	20 c0       	rjmp	.+64     	; 0x518 <GetKeypadKey+0x90>
     4d8:	32 9b       	sbis	0x06, 2	; 6
     4da:	20 c0       	rjmp	.+64     	; 0x51c <GetKeypadKey+0x94>
     4dc:	33 9b       	sbis	0x06, 3	; 6
     4de:	20 c0       	rjmp	.+64     	; 0x520 <GetKeypadKey+0x98>
     4e0:	80 e0       	ldi	r24, 0x00	; 0
     4e2:	08 95       	ret
     4e4:	81 e3       	ldi	r24, 0x31	; 49
     4e6:	08 95       	ret
     4e8:	84 e3       	ldi	r24, 0x34	; 52
     4ea:	08 95       	ret
     4ec:	87 e3       	ldi	r24, 0x37	; 55
     4ee:	08 95       	ret
     4f0:	8a e2       	ldi	r24, 0x2A	; 42
     4f2:	08 95       	ret
     4f4:	82 e3       	ldi	r24, 0x32	; 50
     4f6:	08 95       	ret
     4f8:	85 e3       	ldi	r24, 0x35	; 53
     4fa:	08 95       	ret
     4fc:	88 e3       	ldi	r24, 0x38	; 56
     4fe:	08 95       	ret
     500:	80 e3       	ldi	r24, 0x30	; 48
     502:	08 95       	ret
     504:	83 e3       	ldi	r24, 0x33	; 51
     506:	08 95       	ret
     508:	86 e3       	ldi	r24, 0x36	; 54
     50a:	08 95       	ret
     50c:	89 e3       	ldi	r24, 0x39	; 57
     50e:	08 95       	ret
     510:	83 e2       	ldi	r24, 0x23	; 35
     512:	08 95       	ret
     514:	81 e4       	ldi	r24, 0x41	; 65
     516:	08 95       	ret
     518:	82 e4       	ldi	r24, 0x42	; 66
     51a:	08 95       	ret
     51c:	83 e4       	ldi	r24, 0x43	; 67
     51e:	08 95       	ret
     520:	84 e4       	ldi	r24, 0x44	; 68
     522:	08 95       	ret

00000524 <nokia_lcd_init>:
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	20 9a       	sbi	0x04, 0	; 4
     52a:	21 9a       	sbi	0x04, 1	; 4
     52c:	22 9a       	sbi	0x04, 2	; 4
     52e:	23 9a       	sbi	0x04, 3	; 4
     530:	24 9a       	sbi	0x04, 4	; 4
     532:	29 9a       	sbi	0x05, 1	; 5
     534:	28 9a       	sbi	0x05, 0	; 5
     536:	83 ec       	ldi	r24, 0xC3	; 195
     538:	99 e0       	ldi	r25, 0x09	; 9
     53a:	01 97       	sbiw	r24, 0x01	; 1
     53c:	f1 f7       	brne	.-4      	; 0x53a <nokia_lcd_init+0x16>
     53e:	00 c0       	rjmp	.+0      	; 0x540 <nokia_lcd_init+0x1c>
     540:	00 00       	nop
     542:	29 98       	cbi	0x05, 1	; 5
     544:	8b e5       	ldi	r24, 0x5B	; 91
     546:	94 e4       	ldi	r25, 0x44	; 68
     548:	01 97       	sbiw	r24, 0x01	; 1
     54a:	f1 f7       	brne	.-4      	; 0x548 <nokia_lcd_init+0x24>
     54c:	00 c0       	rjmp	.+0      	; 0x54e <nokia_lcd_init+0x2a>
     54e:	00 00       	nop
     550:	29 9a       	sbi	0x05, 1	; 5
     552:	28 98       	cbi	0x05, 0	; 5
     554:	81 e2       	ldi	r24, 0x21	; 33
     556:	95 df       	rcall	.-214    	; 0x482 <write_cmd>
     558:	83 e1       	ldi	r24, 0x13	; 19
     55a:	93 df       	rcall	.-218    	; 0x482 <write_cmd>
     55c:	86 e0       	ldi	r24, 0x06	; 6
     55e:	91 df       	rcall	.-222    	; 0x482 <write_cmd>
     560:	82 ec       	ldi	r24, 0xC2	; 194
     562:	8f df       	rcall	.-226    	; 0x482 <write_cmd>
     564:	80 e2       	ldi	r24, 0x20	; 32
     566:	8d df       	rcall	.-230    	; 0x482 <write_cmd>
     568:	89 e0       	ldi	r24, 0x09	; 9
     56a:	8b df       	rcall	.-234    	; 0x482 <write_cmd>
     56c:	80 e8       	ldi	r24, 0x80	; 128
     56e:	89 df       	rcall	.-238    	; 0x482 <write_cmd>
     570:	80 e4       	ldi	r24, 0x40	; 64
     572:	87 df       	rcall	.-242    	; 0x482 <write_cmd>
     574:	c8 ef       	ldi	r28, 0xF8	; 248
     576:	d1 e0       	ldi	r29, 0x01	; 1
     578:	61 e0       	ldi	r22, 0x01	; 1
     57a:	80 e0       	ldi	r24, 0x00	; 0
     57c:	64 df       	rcall	.-312    	; 0x446 <write>
     57e:	21 97       	sbiw	r28, 0x01	; 1
     580:	d9 f7       	brne	.-10     	; 0x578 <nokia_lcd_init+0x54>
     582:	88 e0       	ldi	r24, 0x08	; 8
     584:	7e df       	rcall	.-260    	; 0x482 <write_cmd>
     586:	8c e0       	ldi	r24, 0x0C	; 12
     588:	7c df       	rcall	.-264    	; 0x482 <write_cmd>
     58a:	df 91       	pop	r29
     58c:	cf 91       	pop	r28
     58e:	08 95       	ret

00000590 <nokia_lcd_clear>:
     590:	80 e8       	ldi	r24, 0x80	; 128
     592:	77 df       	rcall	.-274    	; 0x482 <write_cmd>
     594:	80 e4       	ldi	r24, 0x40	; 64
     596:	75 df       	rcall	.-278    	; 0x482 <write_cmd>
     598:	10 92 87 09 	sts	0x0987, r1	; 0x800987 <nokia_lcd+0x1f8>
     59c:	10 92 88 09 	sts	0x0988, r1	; 0x800988 <nokia_lcd+0x1f9>
     5a0:	ef e8       	ldi	r30, 0x8F	; 143
     5a2:	f7 e0       	ldi	r31, 0x07	; 7
     5a4:	87 e8       	ldi	r24, 0x87	; 135
     5a6:	99 e0       	ldi	r25, 0x09	; 9
     5a8:	11 92       	st	Z+, r1
     5aa:	e8 17       	cp	r30, r24
     5ac:	f9 07       	cpc	r31, r25
     5ae:	e1 f7       	brne	.-8      	; 0x5a8 <nokia_lcd_clear+0x18>
     5b0:	08 95       	ret

000005b2 <nokia_lcd_set_pixel>:
     5b2:	26 2f       	mov	r18, r22
     5b4:	26 95       	lsr	r18
     5b6:	26 95       	lsr	r18
     5b8:	26 95       	lsr	r18
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	34 e5       	ldi	r19, 0x54	; 84
     5be:	23 9f       	mul	r18, r19
     5c0:	80 0d       	add	r24, r0
     5c2:	91 1d       	adc	r25, r1
     5c4:	11 24       	eor	r1, r1
     5c6:	44 23       	and	r20, r20
     5c8:	79 f0       	breq	.+30     	; 0x5e8 <nokia_lcd_set_pixel+0x36>
     5ca:	fc 01       	movw	r30, r24
     5cc:	e1 57       	subi	r30, 0x71	; 113
     5ce:	f8 4f       	sbci	r31, 0xF8	; 248
     5d0:	67 70       	andi	r22, 0x07	; 7
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	02 c0       	rjmp	.+4      	; 0x5dc <nokia_lcd_set_pixel+0x2a>
     5d8:	88 0f       	add	r24, r24
     5da:	99 1f       	adc	r25, r25
     5dc:	6a 95       	dec	r22
     5de:	e2 f7       	brpl	.-8      	; 0x5d8 <nokia_lcd_set_pixel+0x26>
     5e0:	90 81       	ld	r25, Z
     5e2:	89 2b       	or	r24, r25
     5e4:	80 83       	st	Z, r24
     5e6:	08 95       	ret
     5e8:	fc 01       	movw	r30, r24
     5ea:	e1 57       	subi	r30, 0x71	; 113
     5ec:	f8 4f       	sbci	r31, 0xF8	; 248
     5ee:	67 70       	andi	r22, 0x07	; 7
     5f0:	81 e0       	ldi	r24, 0x01	; 1
     5f2:	90 e0       	ldi	r25, 0x00	; 0
     5f4:	02 c0       	rjmp	.+4      	; 0x5fa <nokia_lcd_set_pixel+0x48>
     5f6:	88 0f       	add	r24, r24
     5f8:	99 1f       	adc	r25, r25
     5fa:	6a 95       	dec	r22
     5fc:	e2 f7       	brpl	.-8      	; 0x5f6 <nokia_lcd_set_pixel+0x44>
     5fe:	80 95       	com	r24
     600:	90 81       	ld	r25, Z
     602:	89 23       	and	r24, r25
     604:	80 83       	st	Z, r24
     606:	08 95       	ret

00000608 <nokia_lcd_write_char>:
     608:	5f 92       	push	r5
     60a:	6f 92       	push	r6
     60c:	7f 92       	push	r7
     60e:	8f 92       	push	r8
     610:	9f 92       	push	r9
     612:	af 92       	push	r10
     614:	bf 92       	push	r11
     616:	cf 92       	push	r12
     618:	df 92       	push	r13
     61a:	ef 92       	push	r14
     61c:	ff 92       	push	r15
     61e:	0f 93       	push	r16
     620:	1f 93       	push	r17
     622:	cf 93       	push	r28
     624:	df 93       	push	r29
     626:	56 2e       	mov	r5, r22
     628:	26 2f       	mov	r18, r22
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	49 01       	movw	r8, r18
     62e:	88 0c       	add	r8, r8
     630:	99 1c       	adc	r9, r9
     632:	88 0c       	add	r8, r8
     634:	99 1c       	adc	r9, r9
     636:	82 0e       	add	r8, r18
     638:	93 1e       	adc	r9, r19
     63a:	18 14       	cp	r1, r8
     63c:	19 04       	cpc	r1, r9
     63e:	0c f0       	brlt	.+2      	; 0x642 <nokia_lcd_write_char+0x3a>
     640:	5b c0       	rjmp	.+182    	; 0x6f8 <nokia_lcd_write_char+0xf0>
     642:	89 01       	movw	r16, r18
     644:	00 0f       	add	r16, r16
     646:	11 1f       	adc	r17, r17
     648:	00 0f       	add	r16, r16
     64a:	11 1f       	adc	r17, r17
     64c:	00 0f       	add	r16, r16
     64e:	11 1f       	adc	r17, r17
     650:	02 1b       	sub	r16, r18
     652:	13 0b       	sbc	r17, r19
     654:	61 2c       	mov	r6, r1
     656:	a8 2e       	mov	r10, r24
     658:	b1 2c       	mov	r11, r1
     65a:	c5 01       	movw	r24, r10
     65c:	80 97       	sbiw	r24, 0x20	; 32
     65e:	5c 01       	movw	r10, r24
     660:	aa 0c       	add	r10, r10
     662:	bb 1c       	adc	r11, r11
     664:	aa 0c       	add	r10, r10
     666:	bb 1c       	adc	r11, r11
     668:	a8 0e       	add	r10, r24
     66a:	b9 1e       	adc	r11, r25
     66c:	0f 2e       	mov	r0, r31
     66e:	f8 e8       	ldi	r31, 0x88	; 136
     670:	cf 2e       	mov	r12, r31
     672:	f9 e0       	ldi	r31, 0x09	; 9
     674:	df 2e       	mov	r13, r31
     676:	f0 2d       	mov	r31, r0
     678:	0f 2e       	mov	r0, r31
     67a:	f7 e8       	ldi	r31, 0x87	; 135
     67c:	ef 2e       	mov	r14, r31
     67e:	f9 e0       	ldi	r31, 0x09	; 9
     680:	ff 2e       	mov	r15, r31
     682:	f0 2d       	mov	r31, r0
     684:	2b c0       	rjmp	.+86     	; 0x6dc <nokia_lcd_write_char+0xd4>
     686:	fe 01       	movw	r30, r28
     688:	24 91       	lpm	r18, Z
     68a:	30 e0       	ldi	r19, 0x00	; 0
     68c:	87 2d       	mov	r24, r7
     68e:	65 2d       	mov	r22, r5
     690:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <__udivmodqi4>
     694:	02 c0       	rjmp	.+4      	; 0x69a <nokia_lcd_write_char+0x92>
     696:	35 95       	asr	r19
     698:	27 95       	ror	r18
     69a:	8a 95       	dec	r24
     69c:	e2 f7       	brpl	.-8      	; 0x696 <nokia_lcd_write_char+0x8e>
     69e:	20 ff       	sbrs	r18, 0
     6a0:	09 c0       	rjmp	.+18     	; 0x6b4 <nokia_lcd_write_char+0xac>
     6a2:	f6 01       	movw	r30, r12
     6a4:	60 81       	ld	r22, Z
     6a6:	67 0d       	add	r22, r7
     6a8:	f7 01       	movw	r30, r14
     6aa:	80 81       	ld	r24, Z
     6ac:	41 e0       	ldi	r20, 0x01	; 1
     6ae:	86 0d       	add	r24, r6
     6b0:	80 df       	rcall	.-256    	; 0x5b2 <nokia_lcd_set_pixel>
     6b2:	08 c0       	rjmp	.+16     	; 0x6c4 <nokia_lcd_write_char+0xbc>
     6b4:	f6 01       	movw	r30, r12
     6b6:	60 81       	ld	r22, Z
     6b8:	67 0d       	add	r22, r7
     6ba:	f7 01       	movw	r30, r14
     6bc:	80 81       	ld	r24, Z
     6be:	40 e0       	ldi	r20, 0x00	; 0
     6c0:	86 0d       	add	r24, r6
     6c2:	77 df       	rcall	.-274    	; 0x5b2 <nokia_lcd_set_pixel>
     6c4:	73 94       	inc	r7
     6c6:	87 2d       	mov	r24, r7
     6c8:	90 e0       	ldi	r25, 0x00	; 0
     6ca:	80 17       	cp	r24, r16
     6cc:	91 07       	cpc	r25, r17
     6ce:	dc f2       	brlt	.-74     	; 0x686 <nokia_lcd_write_char+0x7e>
     6d0:	63 94       	inc	r6
     6d2:	86 2d       	mov	r24, r6
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	88 15       	cp	r24, r8
     6d8:	99 05       	cpc	r25, r9
     6da:	74 f4       	brge	.+28     	; 0x6f8 <nokia_lcd_write_char+0xf0>
     6dc:	10 16       	cp	r1, r16
     6de:	11 06       	cpc	r1, r17
     6e0:	bc f7       	brge	.-18     	; 0x6d0 <nokia_lcd_write_char+0xc8>
     6e2:	86 2d       	mov	r24, r6
     6e4:	65 2d       	mov	r22, r5
     6e6:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <__udivmodqi4>
     6ea:	e5 01       	movw	r28, r10
     6ec:	c8 0f       	add	r28, r24
     6ee:	d1 1d       	adc	r29, r1
     6f0:	ca 55       	subi	r28, 0x5A	; 90
     6f2:	df 4f       	sbci	r29, 0xFF	; 255
     6f4:	71 2c       	mov	r7, r1
     6f6:	c7 cf       	rjmp	.-114    	; 0x686 <nokia_lcd_write_char+0x7e>
     6f8:	80 91 87 09 	lds	r24, 0x0987	; 0x800987 <nokia_lcd+0x1f8>
     6fc:	91 e0       	ldi	r25, 0x01	; 1
     6fe:	98 0f       	add	r25, r24
     700:	85 2d       	mov	r24, r5
     702:	88 0f       	add	r24, r24
     704:	88 0f       	add	r24, r24
     706:	85 0d       	add	r24, r5
     708:	89 0f       	add	r24, r25
     70a:	84 35       	cpi	r24, 0x54	; 84
     70c:	18 f4       	brcc	.+6      	; 0x714 <nokia_lcd_write_char+0x10c>
     70e:	80 93 87 09 	sts	0x0987, r24	; 0x800987 <nokia_lcd+0x1f8>
     712:	0e c0       	rjmp	.+28     	; 0x730 <nokia_lcd_write_char+0x128>
     714:	10 92 87 09 	sts	0x0987, r1	; 0x800987 <nokia_lcd+0x1f8>
     718:	e8 e8       	ldi	r30, 0x88	; 136
     71a:	f9 e0       	ldi	r31, 0x09	; 9
     71c:	80 81       	ld	r24, Z
     71e:	91 e0       	ldi	r25, 0x01	; 1
     720:	98 0f       	add	r25, r24
     722:	85 2d       	mov	r24, r5
     724:	88 0f       	add	r24, r24
     726:	88 0f       	add	r24, r24
     728:	88 0f       	add	r24, r24
     72a:	85 19       	sub	r24, r5
     72c:	89 0f       	add	r24, r25
     72e:	80 83       	st	Z, r24
     730:	80 91 88 09 	lds	r24, 0x0988	; 0x800988 <nokia_lcd+0x1f9>
     734:	80 33       	cpi	r24, 0x30	; 48
     736:	20 f0       	brcs	.+8      	; 0x740 <nokia_lcd_write_char+0x138>
     738:	10 92 87 09 	sts	0x0987, r1	; 0x800987 <nokia_lcd+0x1f8>
     73c:	10 92 88 09 	sts	0x0988, r1	; 0x800988 <nokia_lcd+0x1f9>
     740:	df 91       	pop	r29
     742:	cf 91       	pop	r28
     744:	1f 91       	pop	r17
     746:	0f 91       	pop	r16
     748:	ff 90       	pop	r15
     74a:	ef 90       	pop	r14
     74c:	df 90       	pop	r13
     74e:	cf 90       	pop	r12
     750:	bf 90       	pop	r11
     752:	af 90       	pop	r10
     754:	9f 90       	pop	r9
     756:	8f 90       	pop	r8
     758:	7f 90       	pop	r7
     75a:	6f 90       	pop	r6
     75c:	5f 90       	pop	r5
     75e:	08 95       	ret

00000760 <nokia_lcd_write_string>:
     760:	1f 93       	push	r17
     762:	cf 93       	push	r28
     764:	df 93       	push	r29
     766:	ec 01       	movw	r28, r24
     768:	88 81       	ld	r24, Y
     76a:	88 23       	and	r24, r24
     76c:	39 f0       	breq	.+14     	; 0x77c <nokia_lcd_write_string+0x1c>
     76e:	16 2f       	mov	r17, r22
     770:	21 96       	adiw	r28, 0x01	; 1
     772:	61 2f       	mov	r22, r17
     774:	49 df       	rcall	.-366    	; 0x608 <nokia_lcd_write_char>
     776:	89 91       	ld	r24, Y+
     778:	81 11       	cpse	r24, r1
     77a:	fb cf       	rjmp	.-10     	; 0x772 <nokia_lcd_write_string+0x12>
     77c:	df 91       	pop	r29
     77e:	cf 91       	pop	r28
     780:	1f 91       	pop	r17
     782:	08 95       	ret

00000784 <nokia_lcd_render>:
     784:	0f 93       	push	r16
     786:	1f 93       	push	r17
     788:	cf 93       	push	r28
     78a:	df 93       	push	r29
     78c:	80 e8       	ldi	r24, 0x80	; 128
     78e:	79 de       	rcall	.-782    	; 0x482 <write_cmd>
     790:	80 e4       	ldi	r24, 0x40	; 64
     792:	77 de       	rcall	.-786    	; 0x482 <write_cmd>
     794:	cf e8       	ldi	r28, 0x8F	; 143
     796:	d7 e0       	ldi	r29, 0x07	; 7
     798:	07 e8       	ldi	r16, 0x87	; 135
     79a:	19 e0       	ldi	r17, 0x09	; 9
     79c:	61 e0       	ldi	r22, 0x01	; 1
     79e:	89 91       	ld	r24, Y+
     7a0:	52 de       	rcall	.-860    	; 0x446 <write>
     7a2:	c0 17       	cp	r28, r16
     7a4:	d1 07       	cpc	r29, r17
     7a6:	d1 f7       	brne	.-12     	; 0x79c <nokia_lcd_render+0x18>
     7a8:	df 91       	pop	r29
     7aa:	cf 91       	pop	r28
     7ac:	1f 91       	pop	r17
     7ae:	0f 91       	pop	r16
     7b0:	08 95       	ret

000007b2 <initUSART>:
     7b2:	81 30       	cpi	r24, 0x01	; 1
     7b4:	81 f0       	breq	.+32     	; 0x7d6 <initUSART+0x24>
     7b6:	e1 ec       	ldi	r30, 0xC1	; 193
     7b8:	f0 e0       	ldi	r31, 0x00	; 0
     7ba:	80 81       	ld	r24, Z
     7bc:	88 61       	ori	r24, 0x18	; 24
     7be:	80 83       	st	Z, r24
     7c0:	e2 ec       	ldi	r30, 0xC2	; 194
     7c2:	f0 e0       	ldi	r31, 0x00	; 0
     7c4:	80 81       	ld	r24, Z
     7c6:	86 60       	ori	r24, 0x06	; 6
     7c8:	80 83       	st	Z, r24
     7ca:	85 e0       	ldi	r24, 0x05	; 5
     7cc:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     7d0:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     7d4:	08 95       	ret
     7d6:	e9 ec       	ldi	r30, 0xC9	; 201
     7d8:	f0 e0       	ldi	r31, 0x00	; 0
     7da:	80 81       	ld	r24, Z
     7dc:	88 61       	ori	r24, 0x18	; 24
     7de:	80 83       	st	Z, r24
     7e0:	ea ec       	ldi	r30, 0xCA	; 202
     7e2:	f0 e0       	ldi	r31, 0x00	; 0
     7e4:	80 81       	ld	r24, Z
     7e6:	86 60       	ori	r24, 0x06	; 6
     7e8:	80 83       	st	Z, r24
     7ea:	85 e0       	ldi	r24, 0x05	; 5
     7ec:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
     7f0:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
     7f4:	08 95       	ret

000007f6 <USART_Flush>:
     7f6:	81 30       	cpi	r24, 0x01	; 1
     7f8:	29 f4       	brne	.+10     	; 0x804 <USART_Flush+0xe>
     7fa:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
     7fe:	88 23       	and	r24, r24
     800:	74 f0       	brlt	.+28     	; 0x81e <USART_Flush+0x28>
     802:	08 95       	ret
     804:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     808:	88 23       	and	r24, r24
     80a:	8c f4       	brge	.+34     	; 0x82e <USART_Flush+0x38>
     80c:	a6 ec       	ldi	r26, 0xC6	; 198
     80e:	b0 e0       	ldi	r27, 0x00	; 0
     810:	e0 ec       	ldi	r30, 0xC0	; 192
     812:	f0 e0       	ldi	r31, 0x00	; 0
     814:	8c 91       	ld	r24, X
     816:	80 81       	ld	r24, Z
     818:	88 23       	and	r24, r24
     81a:	e4 f3       	brlt	.-8      	; 0x814 <USART_Flush+0x1e>
     81c:	08 95       	ret
     81e:	ae ec       	ldi	r26, 0xCE	; 206
     820:	b0 e0       	ldi	r27, 0x00	; 0
     822:	e8 ec       	ldi	r30, 0xC8	; 200
     824:	f0 e0       	ldi	r31, 0x00	; 0
     826:	8c 91       	ld	r24, X
     828:	80 81       	ld	r24, Z
     82a:	88 23       	and	r24, r24
     82c:	e4 f3       	brlt	.-8      	; 0x826 <USART_Flush+0x30>
     82e:	08 95       	ret

00000830 <USART_Receive>:
     830:	81 30       	cpi	r24, 0x01	; 1
     832:	41 f0       	breq	.+16     	; 0x844 <USART_Receive+0x14>
     834:	e0 ec       	ldi	r30, 0xC0	; 192
     836:	f0 e0       	ldi	r31, 0x00	; 0
     838:	80 81       	ld	r24, Z
     83a:	88 23       	and	r24, r24
     83c:	ec f7       	brge	.-6      	; 0x838 <USART_Receive+0x8>
     83e:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     842:	08 95       	ret
     844:	e8 ec       	ldi	r30, 0xC8	; 200
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	80 81       	ld	r24, Z
     84a:	88 23       	and	r24, r24
     84c:	ec f7       	brge	.-6      	; 0x848 <USART_Receive+0x18>
     84e:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     852:	08 95       	ret

00000854 <Motor_Tick>:
}

void Motor_Tick()
{
     854:	cf 92       	push	r12
     856:	df 92       	push	r13
     858:	ef 92       	push	r14
     85a:	ff 92       	push	r15
     85c:	0f 93       	push	r16
     85e:	1f 93       	push	r17
     860:	cf 93       	push	r28
     862:	df 93       	push	r29
	char garage_button = (GetBit(~PIND, 3)); //if button is pressed then = 8
     864:	89 b1       	in	r24, 0x09	; 9
	return (bin_value ? pin | (0x01 << number) : pin & ~(0x01 << number));
}

unsigned char GetBit(unsigned char port, unsigned char number)
{
	return ( port & (0x01 << number) );
     866:	80 95       	com	r24
     868:	38 2f       	mov	r19, r24
     86a:	38 70       	andi	r19, 0x08	; 8
	char motion_sensor = (GetBit(~PIND, 2)); //if motion is sensed then = 4
     86c:	89 b1       	in	r24, 0x09	; 9
     86e:	80 95       	com	r24
     870:	28 2f       	mov	r18, r24
     872:	24 70       	andi	r18, 0x04	; 4
	switch(motor_state)
     874:	e0 91 e3 09 	lds	r30, 0x09E3	; 0x8009e3 <motor_state>
     878:	8e 2f       	mov	r24, r30
     87a:	90 e0       	ldi	r25, 0x00	; 0
     87c:	8d 30       	cpi	r24, 0x0D	; 13
     87e:	91 05       	cpc	r25, r1
     880:	08 f0       	brcs	.+2      	; 0x884 <Motor_Tick+0x30>
     882:	e7 c0       	rjmp	.+462    	; 0xa52 <Motor_Tick+0x1fe>
     884:	fc 01       	movw	r30, r24
     886:	ea 5b       	subi	r30, 0xBA	; 186
     888:	ff 4f       	sbci	r31, 0xFF	; 255
     88a:	0c 94 dc 0c 	jmp	0x19b8	; 0x19b8 <__tablejump2__>
	{	
		case READ_MOTION:
			if(motion_sensor == 4){motor_state = MENU;}
     88e:	24 30       	cpi	r18, 0x04	; 4
     890:	09 f0       	breq	.+2      	; 0x894 <Motor_Tick+0x40>
     892:	37 c3       	rjmp	.+1646   	; 0xf02 <Motor_Tick+0x6ae>
     894:	81 e0       	ldi	r24, 0x01	; 1
     896:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     89a:	37 c3       	rjmp	.+1646   	; 0xf0a <Motor_Tick+0x6b6>
			else if(motion_sensor == 0){motor_state = READ_MOTION;}
			break;
		
		case MENU:
			if(menu_check == 1){motor_state = READ_KEY_WAIT;}
     89c:	80 91 8b 07 	lds	r24, 0x078B	; 0x80078b <menu_check>
     8a0:	81 30       	cpi	r24, 0x01	; 1
     8a2:	21 f4       	brne	.+8      	; 0x8ac <Motor_Tick+0x58>
     8a4:	82 e0       	ldi	r24, 0x02	; 2
     8a6:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     8aa:	6c c3       	rjmp	.+1752   	; 0xf84 <Motor_Tick+0x730>
			//else if(menu_check == 2){motor_state = CHANGE_PASS;}
			else if(menu_check == 3){motor_state = CURRENT_PASS;}
     8ac:	83 30       	cpi	r24, 0x03	; 3
     8ae:	09 f0       	breq	.+2      	; 0x8b2 <Motor_Tick+0x5e>
     8b0:	2c c3       	rjmp	.+1624   	; 0xf0a <Motor_Tick+0x6b6>
     8b2:	84 e0       	ldi	r24, 0x04	; 4
     8b4:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     8b8:	2f c3       	rjmp	.+1630   	; 0xf18 <Motor_Tick+0x6c4>
			else if(menu_check == 0){motor_state = MENU;}
			break;
			
		case READ_KEY_WAIT:
			if(cnt > 100){motor_state = READ_KEY_INIT; cnt = 0;}
     8ba:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <cnt>
     8be:	85 36       	cpi	r24, 0x65	; 101
     8c0:	30 f0       	brcs	.+12     	; 0x8ce <Motor_Tick+0x7a>
     8c2:	83 e0       	ldi	r24, 0x03	; 3
     8c4:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     8c8:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <cnt>
     8cc:	0a c1       	rjmp	.+532    	; 0xae2 <Motor_Tick+0x28e>
			else{motor_state = READ_KEY_WAIT; cnt = cnt + 1;}
     8ce:	8f 5f       	subi	r24, 0xFF	; 255
     8d0:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <cnt>
     8d4:	57 c3       	rjmp	.+1710   	; 0xf84 <Motor_Tick+0x730>
			break;
			
		case READ_KEY_INIT:
			if((checker == 1) && (bt_check == 0)){motor_state = READ_KEY_WAIT_2;}
     8d6:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <checker>
     8da:	81 30       	cpi	r24, 0x01	; 1
     8dc:	41 f4       	brne	.+16     	; 0x8ee <Motor_Tick+0x9a>
     8de:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <bt_check>
     8e2:	81 11       	cpse	r24, r1
     8e4:	fe c0       	rjmp	.+508    	; 0xae2 <Motor_Tick+0x28e>
     8e6:	86 e0       	ldi	r24, 0x06	; 6
     8e8:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     8ec:	4b c3       	rjmp	.+1686   	; 0xf84 <Motor_Tick+0x730>
			else if((checker == 0) && (bt_check == 1)){motor_state = UNLOCK; lr = 2;}
     8ee:	81 11       	cpse	r24, r1
     8f0:	f8 c0       	rjmp	.+496    	; 0xae2 <Motor_Tick+0x28e>
     8f2:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <bt_check>
     8f6:	81 30       	cpi	r24, 0x01	; 1
     8f8:	09 f0       	breq	.+2      	; 0x8fc <Motor_Tick+0xa8>
     8fa:	f3 c0       	rjmp	.+486    	; 0xae2 <Motor_Tick+0x28e>
     8fc:	8c e0       	ldi	r24, 0x0C	; 12
     8fe:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     902:	82 e0       	ldi	r24, 0x02	; 2
     904:	80 93 87 07 	sts	0x0787, r24	; 0x800787 <lr>
     908:	07 c2       	rjmp	.+1038   	; 0xd18 <Motor_Tick+0x4c4>
			else if((checker == 0) && (bt_check == 0)){motor_state = READ_KEY_INIT;}
			break;
			
		case CURRENT_PASS:
			if(cnt > 100){motor_state = MENU; cnt = 0;}
     90a:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <cnt>
     90e:	85 36       	cpi	r24, 0x65	; 101
     910:	30 f0       	brcs	.+12     	; 0x91e <Motor_Tick+0xca>
     912:	81 e0       	ldi	r24, 0x01	; 1
     914:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     918:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <cnt>
     91c:	f6 c2       	rjmp	.+1516   	; 0xf0a <Motor_Tick+0x6b6>
			else{motor_state = CURRENT_PASS; cnt = cnt + 1;}
     91e:	8f 5f       	subi	r24, 0xFF	; 255
     920:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <cnt>
     924:	f9 c2       	rjmp	.+1522   	; 0xf18 <Motor_Tick+0x6c4>
			break;
			
		case CHANGE_PASS:
			if(cnt > 100){motor_state = MENU; cnt = 0;}
     926:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <cnt>
     92a:	85 36       	cpi	r24, 0x65	; 101
     92c:	30 f0       	brcs	.+12     	; 0x93a <Motor_Tick+0xe6>
     92e:	81 e0       	ldi	r24, 0x01	; 1
     930:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     934:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <cnt>
     938:	e8 c2       	rjmp	.+1488   	; 0xf0a <Motor_Tick+0x6b6>
			else{motor_state = CHANGE_PASS; cnt = cnt + 1;}
     93a:	8f 5f       	subi	r24, 0xFF	; 255
     93c:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <cnt>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     940:	27 de       	rcall	.-946    	; 0x590 <nokia_lcd_clear>
     942:	85 e0       	ldi	r24, 0x05	; 5
     944:	80 93 87 09 	sts	0x0987, r24	; 0x800987 <nokia_lcd+0x1f8>
    nokia_lcd.cursor_y = y;
     948:	8a e0       	ldi	r24, 0x0A	; 10
     94a:	80 93 88 09 	sts	0x0988, r24	; 0x800988 <nokia_lcd+0x1f9>
			break;
			
		case CHANGE_PASS:
			nokia_lcd_clear();
			nokia_lcd_set_cursor(5, 10);
			nokia_lcd_write_string("New Code:", 1);
     94e:	61 e0       	ldi	r22, 0x01	; 1
     950:	81 e1       	ldi	r24, 0x11	; 17
			nokia_lcd_render();
     952:	91 e0       	ldi	r25, 0x01	; 1
     954:	05 df       	rcall	.-502    	; 0x760 <nokia_lcd_write_string>
			break;
     956:	16 df       	rcall	.-468    	; 0x784 <nokia_lcd_render>
			if(cnt > 100){motor_state = MENU; cnt = 0;}
			else{motor_state = CHANGE_PASS; cnt = cnt + 1;}
			break;
			
		case READ_KEY_WAIT_2:
			if(cnt > 200){motor_state = READ_KEY_INIT_2; cnt = 0;}
     958:	15 c3       	rjmp	.+1578   	; 0xf84 <Motor_Tick+0x730>
     95a:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <cnt>
     95e:	89 3c       	cpi	r24, 0xC9	; 201
     960:	30 f0       	brcs	.+12     	; 0x96e <Motor_Tick+0x11a>
     962:	87 e0       	ldi	r24, 0x07	; 7
     964:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     968:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <cnt>
			else{motor_state = READ_KEY_WAIT_2; cnt = cnt + 1;}
     96c:	f8 c0       	rjmp	.+496    	; 0xb5e <Motor_Tick+0x30a>
     96e:	8f 5f       	subi	r24, 0xFF	; 255
     970:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <cnt>
			break;
			
		case READ_KEY_INIT_2:
			if((checker2 == 1) && (bt_check == 0)){motor_state = READ_KEY_WAIT_3;}
     974:	07 c3       	rjmp	.+1550   	; 0xf84 <Motor_Tick+0x730>
     976:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <checker2>
     97a:	81 30       	cpi	r24, 0x01	; 1
     97c:	41 f4       	brne	.+16     	; 0x98e <Motor_Tick+0x13a>
     97e:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <bt_check>
     982:	81 11       	cpse	r24, r1
     984:	ec c0       	rjmp	.+472    	; 0xb5e <Motor_Tick+0x30a>
     986:	88 e0       	ldi	r24, 0x08	; 8
     988:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
			else if((checker2 == 0) && (bt_check == 1)){motor_state = UNLOCK; lr = 2;}
     98c:	fb c2       	rjmp	.+1526   	; 0xf84 <Motor_Tick+0x730>
     98e:	81 11       	cpse	r24, r1
     990:	e6 c0       	rjmp	.+460    	; 0xb5e <Motor_Tick+0x30a>
     992:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <bt_check>
     996:	81 30       	cpi	r24, 0x01	; 1
     998:	09 f0       	breq	.+2      	; 0x99c <Motor_Tick+0x148>
     99a:	e1 c0       	rjmp	.+450    	; 0xb5e <Motor_Tick+0x30a>
     99c:	8c e0       	ldi	r24, 0x0C	; 12
     99e:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     9a2:	82 e0       	ldi	r24, 0x02	; 2
     9a4:	80 93 87 07 	sts	0x0787, r24	; 0x800787 <lr>
			else if((checker2 == 0) && (bt_check == 0)){motor_state = READ_KEY_INIT_2;}
			break;
			
		case READ_KEY_WAIT_3:
			if(cnt > 200){motor_state = READ_KEY_INIT_3; cnt = 0;}
     9a8:	b7 c1       	rjmp	.+878    	; 0xd18 <Motor_Tick+0x4c4>
     9aa:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <cnt>
     9ae:	89 3c       	cpi	r24, 0xC9	; 201
     9b0:	30 f0       	brcs	.+12     	; 0x9be <Motor_Tick+0x16a>
     9b2:	89 e0       	ldi	r24, 0x09	; 9
     9b4:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     9b8:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <cnt>
			else{motor_state = READ_KEY_WAIT_3; cnt = cnt + 1;}
     9bc:	14 c1       	rjmp	.+552    	; 0xbe6 <Motor_Tick+0x392>
     9be:	8f 5f       	subi	r24, 0xFF	; 255
     9c0:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <cnt>
			break;
			
		case READ_KEY_INIT_3:
			if((checker3 == 1) && (bt_check == 0)){motor_state = READ_KEY;}
     9c4:	df c2       	rjmp	.+1470   	; 0xf84 <Motor_Tick+0x730>
     9c6:	80 91 88 07 	lds	r24, 0x0788	; 0x800788 <checker3>
     9ca:	81 30       	cpi	r24, 0x01	; 1
     9cc:	41 f4       	brne	.+16     	; 0x9de <Motor_Tick+0x18a>
     9ce:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <bt_check>
     9d2:	81 11       	cpse	r24, r1
     9d4:	08 c1       	rjmp	.+528    	; 0xbe6 <Motor_Tick+0x392>
     9d6:	8a e0       	ldi	r24, 0x0A	; 10
     9d8:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
			else if((checker3 == 0) && (bt_check == 1)){motor_state = UNLOCK; lr = 2;}
     9dc:	8a c2       	rjmp	.+1300   	; 0xef2 <Motor_Tick+0x69e>
     9de:	81 11       	cpse	r24, r1
     9e0:	02 c1       	rjmp	.+516    	; 0xbe6 <Motor_Tick+0x392>
     9e2:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <bt_check>
     9e6:	81 30       	cpi	r24, 0x01	; 1
     9e8:	09 f0       	breq	.+2      	; 0x9ec <Motor_Tick+0x198>
     9ea:	fd c0       	rjmp	.+506    	; 0xbe6 <Motor_Tick+0x392>
     9ec:	8c e0       	ldi	r24, 0x0C	; 12
     9ee:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     9f2:	82 e0       	ldi	r24, 0x02	; 2
     9f4:	80 93 87 07 	sts	0x0787, r24	; 0x800787 <lr>
			else if((checker3 == 0) && (bt_check == 0)){motor_state = READ_KEY_INIT_3;}
			break;
			
		case READ_KEY:
			if (lr == 2){motor_state = UNLOCK;}
     9f8:	8f c1       	rjmp	.+798    	; 0xd18 <Motor_Tick+0x4c4>
     9fa:	80 91 87 07 	lds	r24, 0x0787	; 0x800787 <lr>
     9fe:	82 30       	cpi	r24, 0x02	; 2
     a00:	09 f0       	breq	.+2      	; 0xa04 <Motor_Tick+0x1b0>
     a02:	77 c2       	rjmp	.+1262   	; 0xef2 <Motor_Tick+0x69e>
     a04:	8c e0       	ldi	r24, 0x0C	; 12
     a06:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
			else {motor_state = READ_KEY;}
			break;
		
		case UNLOCK:
			if(cnt > 200) {motor_state = LOCK; cnt = 0; motion_sensor = 0;}
     a0a:	86 c1       	rjmp	.+780    	; 0xd18 <Motor_Tick+0x4c4>
     a0c:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <cnt>
     a10:	89 3c       	cpi	r24, 0xC9	; 201
     a12:	30 f0       	brcs	.+12     	; 0xa20 <Motor_Tick+0x1cc>
     a14:	8b e0       	ldi	r24, 0x0B	; 11
     a16:	80 93 e3 09 	sts	0x09E3, r24	; 0x8009e3 <motor_state>
     a1a:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <cnt>
			else {motor_state = UNLOCK; cnt = cnt + 1;}
     a1e:	ad c2       	rjmp	.+1370   	; 0xf7a <Motor_Tick+0x726>
     a20:	8f 5f       	subi	r24, 0xFF	; 255
     a22:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <cnt>
			}
			
			break;
		
		case UNLOCK:
			if(lr){
     a26:	80 91 87 07 	lds	r24, 0x0787	; 0x800787 <lr>
     a2a:	88 23       	and	r24, r24
     a2c:	09 f4       	brne	.+2      	; 0xa30 <Motor_Tick+0x1dc>
     a2e:	8c c1       	rjmp	.+792    	; 0xd48 <Motor_Tick+0x4f4>
			if(cnt > 200) {motor_state = LOCK; cnt = 0; motion_sensor = 0;}
			else {motor_state = UNLOCK; cnt = cnt + 1;}
			break;
			
		case LOCK:
			if(cnt > 200) {motor_state = READ_MOTION; cnt = 0; lr = 0; motion_sensor = 0;}
     a30:	73 c1       	rjmp	.+742    	; 0xd18 <Motor_Tick+0x4c4>
     a32:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <cnt>
     a36:	89 3c       	cpi	r24, 0xC9	; 201
     a38:	40 f0       	brcs	.+16     	; 0xa4a <Motor_Tick+0x1f6>
     a3a:	10 92 e3 09 	sts	0x09E3, r1	; 0x8009e3 <motor_state>
     a3e:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <cnt>
     a42:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <lr>
			
			
	switch(motor_state)
	{
		case READ_MOTION:
			PORTD = SetBit(PORTD,4,0); //GARAGE LIGHT OFF
     a46:	5c 98       	cbi	0x0b, 4	; 11
			else {motor_state = UNLOCK; cnt = cnt + 1;}
			break;
			
		case LOCK:
			if(cnt > 200) {motor_state = READ_MOTION; cnt = 0; lr = 0; motion_sensor = 0;}
			else {motor_state = LOCK; cnt = cnt + 1;}
     a48:	07 c0       	rjmp	.+14     	; 0xa58 <Motor_Tick+0x204>
     a4a:	8f 5f       	subi	r24, 0xFF	; 255
     a4c:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <cnt>
			break;
		
		default:
			motor_state = READ_MOTION;
			break;
     a50:	94 c2       	rjmp	.+1320   	; 0xf7a <Motor_Tick+0x726>
	switch(motor_state)
	{
		case READ_MOTION:
			PORTD = SetBit(PORTD,4,0); //GARAGE LIGHT OFF
			if (motion_sensor == 0){
				nokia_lcd_clear();
     a52:	10 92 e3 09 	sts	0x09E3, r1	; 0x8009e3 <motor_state>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     a56:	55 c2       	rjmp	.+1194   	; 0xf02 <Motor_Tick+0x6ae>
     a58:	9b dd       	rcall	.-1226   	; 0x590 <nokia_lcd_clear>
     a5a:	07 e8       	ldi	r16, 0x87	; 135
     a5c:	19 e0       	ldi	r17, 0x09	; 9
     a5e:	83 e2       	ldi	r24, 0x23	; 35
    nokia_lcd.cursor_y = y;
     a60:	f8 01       	movw	r30, r16
     a62:	80 83       	st	Z, r24
				nokia_lcd_set_cursor(35, 0);
				nokia_lcd_write_string("No", 2);
     a64:	c8 e8       	ldi	r28, 0x88	; 136
     a66:	d9 e0       	ldi	r29, 0x09	; 9
     a68:	18 82       	st	Y, r1
     a6a:	62 e0       	ldi	r22, 0x02	; 2
     a6c:	8b e1       	ldi	r24, 0x1B	; 27
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     a6e:	91 e0       	ldi	r25, 0x01	; 1
     a70:	77 de       	rcall	.-786    	; 0x760 <nokia_lcd_write_string>
				nokia_lcd_set_cursor(15, 20);
				nokia_lcd_write_string("Motion", 2);
     a72:	8f e0       	ldi	r24, 0x0F	; 15
     a74:	f8 01       	movw	r30, r16
     a76:	80 83       	st	Z, r24
     a78:	84 e1       	ldi	r24, 0x14	; 20
     a7a:	88 83       	st	Y, r24
			}
			nokia_lcd_render();
     a7c:	62 e0       	ldi	r22, 0x02	; 2
     a7e:	8e e1       	ldi	r24, 0x1E	; 30
			break;
     a80:	91 e0       	ldi	r25, 0x01	; 1
			
		case MENU:
			menu_key = GetKeypadKey();
			if ((menu_key == 'A')){
				menu_check = 1;
     a82:	6e de       	rcall	.-804    	; 0x760 <nokia_lcd_write_string>
     a84:	7f de       	rcall	.-770    	; 0x784 <nokia_lcd_render>
     a86:	7e c2       	rjmp	.+1276   	; 0xf84 <Motor_Tick+0x730>
     a88:	81 e0       	ldi	r24, 0x01	; 1
			/*
			else if ((menu_key == 'B')){
				menu_check = 2;
			}
			*/
			else if ((menu_key == 'C')){
     a8a:	80 93 8b 07 	sts	0x078B, r24	; 0x80078b <menu_check>
				menu_check = 3;
     a8e:	08 c0       	rjmp	.+16     	; 0xaa0 <Motor_Tick+0x24c>
     a90:	83 34       	cpi	r24, 0x43	; 67
     a92:	21 f4       	brne	.+8      	; 0xa9c <Motor_Tick+0x248>
			}
			else{
				menu_check = 0;
     a94:	83 e0       	ldi	r24, 0x03	; 3
     a96:	80 93 8b 07 	sts	0x078B, r24	; 0x80078b <menu_check>
			}
			nokia_lcd_clear();
     a9a:	02 c0       	rjmp	.+4      	; 0xaa0 <Motor_Tick+0x24c>
     a9c:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <menu_check>
     aa0:	77 dd       	rcall	.-1298   	; 0x590 <nokia_lcd_clear>
     aa2:	07 e8       	ldi	r16, 0x87	; 135
     aa4:	19 e0       	ldi	r17, 0x09	; 9
     aa6:	0f 2e       	mov	r0, r31
     aa8:	fe e1       	ldi	r31, 0x1E	; 30
    nokia_lcd.cursor_y = y;
     aaa:	ff 2e       	mov	r15, r31
     aac:	f0 2d       	mov	r31, r0
     aae:	f8 01       	movw	r30, r16
			nokia_lcd_set_cursor(30, 0);
			nokia_lcd_write_string("Menu", 1);
     ab0:	f0 82       	st	Z, r15
     ab2:	c8 e8       	ldi	r28, 0x88	; 136
     ab4:	d9 e0       	ldi	r29, 0x09	; 9
     ab6:	18 82       	st	Y, r1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ab8:	61 e0       	ldi	r22, 0x01	; 1
     aba:	85 e2       	ldi	r24, 0x25	; 37
    nokia_lcd.cursor_y = y;
     abc:	91 e0       	ldi	r25, 0x01	; 1
     abe:	50 de       	rcall	.-864    	; 0x760 <nokia_lcd_write_string>
			nokia_lcd_set_cursor(0, 20);
			nokia_lcd_write_string("A - enter code", 1);
     ac0:	f8 01       	movw	r30, r16
     ac2:	10 82       	st	Z, r1
     ac4:	84 e1       	ldi	r24, 0x14	; 20
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ac6:	88 83       	st	Y, r24
     ac8:	61 e0       	ldi	r22, 0x01	; 1
    nokia_lcd.cursor_y = y;
     aca:	8a e2       	ldi	r24, 0x2A	; 42
			/*
			nokia_lcd_set_cursor(0, 20);
			nokia_lcd_write_string("B-change code", 1);
			*/
			nokia_lcd_set_cursor(0, 30);
			nokia_lcd_write_string("C - check code", 1);
     acc:	91 e0       	ldi	r25, 0x01	; 1
     ace:	48 de       	rcall	.-880    	; 0x760 <nokia_lcd_write_string>
     ad0:	f8 01       	movw	r30, r16
     ad2:	10 82       	st	Z, r1
			nokia_lcd_render();
     ad4:	f8 82       	st	Y, r15
     ad6:	61 e0       	ldi	r22, 0x01	; 1
//Functionality - checks if USART has recieved data
//Parameter: usartNum specifies which USART is checked
//Returns: 1 if true else 0
unsigned char USART_HasReceived(unsigned char usartNum)
{
	return (usartNum != 1) ? (UCSR0A & (1 << RXC0)) : (UCSR1A & (1 << RXC1));
     ad8:	89 e3       	ldi	r24, 0x39	; 57
			
		case READ_KEY_WAIT:
			break;	
			
		case READ_KEY_INIT:
			if((USART_HasReceived(0))){
     ada:	91 e0       	ldi	r25, 0x01	; 1
				bt_check = 1;
     adc:	41 de       	rcall	.-894    	; 0x760 <nokia_lcd_write_string>
     ade:	52 de       	rcall	.-860    	; 0x784 <nokia_lcd_render>
				key = USART_Receive(0);
     ae0:	51 c2       	rjmp	.+1186   	; 0xf84 <Motor_Tick+0x730>
     ae2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     ae6:	88 23       	and	r24, r24
     ae8:	54 f4       	brge	.+20     	; 0xafe <Motor_Tick+0x2aa>
				USART_Flush(0);
     aea:	81 e0       	ldi	r24, 0x01	; 1
     aec:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <bt_check>
			}
			else{
				bt_check = 0;
     af0:	80 e0       	ldi	r24, 0x00	; 0
     af2:	9e de       	rcall	.-708    	; 0x830 <USART_Receive>
				key = GetKeypadKey();
     af4:	80 93 e4 09 	sts	0x09E4, r24	; 0x8009e4 <key>
     af8:	80 e0       	ldi	r24, 0x00	; 0
     afa:	7d de       	rcall	.-774    	; 0x7f6 <USART_Flush>
				if ((key != '\0')){
     afc:	0d c0       	rjmp	.+26     	; 0xb18 <Motor_Tick+0x2c4>
     afe:	10 92 8c 07 	sts	0x078C, r1	; 0x80078c <bt_check>
					checker = 1;
     b02:	c2 dc       	rcall	.-1660   	; 0x488 <GetKeypadKey>
     b04:	80 93 e4 09 	sts	0x09E4, r24	; 0x8009e4 <key>
				}
				else{
					checker = 0;
     b08:	88 23       	and	r24, r24
     b0a:	21 f0       	breq	.+8      	; 0xb14 <Motor_Tick+0x2c0>
				}
			}
				
			nokia_lcd_clear();
     b0c:	81 e0       	ldi	r24, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     b0e:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <checker>
     b12:	02 c0       	rjmp	.+4      	; 0xb18 <Motor_Tick+0x2c4>
     b14:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <checker>
     b18:	3b dd       	rcall	.-1418   	; 0x590 <nokia_lcd_clear>
     b1a:	0f 2e       	mov	r0, r31
     b1c:	f7 e8       	ldi	r31, 0x87	; 135
    nokia_lcd.cursor_y = y;
     b1e:	ef 2e       	mov	r14, r31
     b20:	f9 e0       	ldi	r31, 0x09	; 9
     b22:	ff 2e       	mov	r15, r31
			nokia_lcd_set_cursor(30, 0);
			nokia_lcd_write_string("CODE?", 1);
     b24:	f0 2d       	mov	r31, r0
     b26:	1e e1       	ldi	r17, 0x1E	; 30
     b28:	f7 01       	movw	r30, r14
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     b2a:	10 83       	st	Z, r17
     b2c:	c8 e8       	ldi	r28, 0x88	; 136
     b2e:	d9 e0       	ldi	r29, 0x09	; 9
    nokia_lcd.cursor_y = y;
     b30:	18 82       	st	Y, r1
			nokia_lcd_set_cursor(10, 30);
			nokia_lcd_write_string("Entry: ", 1);
     b32:	61 e0       	ldi	r22, 0x01	; 1
     b34:	88 e4       	ldi	r24, 0x48	; 72
     b36:	91 e0       	ldi	r25, 0x01	; 1
     b38:	13 de       	rcall	.-986    	; 0x760 <nokia_lcd_write_string>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     b3a:	8a e0       	ldi	r24, 0x0A	; 10
     b3c:	f7 01       	movw	r30, r14
			nokia_lcd_set_cursor(50, 30);
			nokia_lcd_write_char(key, 1);
     b3e:	80 83       	st	Z, r24
     b40:	18 83       	st	Y, r17
     b42:	61 e0       	ldi	r22, 0x01	; 1
			nokia_lcd_render();
     b44:	8e e4       	ldi	r24, 0x4E	; 78
     b46:	91 e0       	ldi	r25, 0x01	; 1
			break;
     b48:	0b de       	rcall	.-1002   	; 0x760 <nokia_lcd_write_string>
     b4a:	82 e3       	ldi	r24, 0x32	; 50
     b4c:	f7 01       	movw	r30, r14
			
		case READ_KEY_WAIT_2:
			break;
			
		case READ_KEY_INIT_2:
			if((USART_HasReceived(0))){
     b4e:	80 83       	st	Z, r24
     b50:	18 83       	st	Y, r17
				bt_check = 1;
     b52:	61 e0       	ldi	r22, 0x01	; 1
     b54:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <key>
				key2 = USART_Receive(0);
     b58:	57 dd       	rcall	.-1362   	; 0x608 <nokia_lcd_write_char>
     b5a:	14 de       	rcall	.-984    	; 0x784 <nokia_lcd_render>
     b5c:	13 c2       	rjmp	.+1062   	; 0xf84 <Motor_Tick+0x730>
     b5e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
				USART_Flush(0);
     b62:	88 23       	and	r24, r24
     b64:	54 f4       	brge	.+20     	; 0xb7a <Motor_Tick+0x326>
     b66:	81 e0       	ldi	r24, 0x01	; 1
			}
			else{
				key2 = GetKeypadKey();
     b68:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <bt_check>
     b6c:	80 e0       	ldi	r24, 0x00	; 0
     b6e:	60 de       	rcall	.-832    	; 0x830 <USART_Receive>
				if ((key2 != '\0')){
     b70:	80 93 e6 09 	sts	0x09E6, r24	; 0x8009e6 <key2>
					checker2 = 1;
     b74:	80 e0       	ldi	r24, 0x00	; 0
     b76:	3f de       	rcall	.-898    	; 0x7f6 <USART_Flush>
     b78:	0b c0       	rjmp	.+22     	; 0xb90 <Motor_Tick+0x33c>
				}
				else{
					checker2 = 0;
     b7a:	86 dc       	rcall	.-1780   	; 0x488 <GetKeypadKey>
     b7c:	80 93 e6 09 	sts	0x09E6, r24	; 0x8009e6 <key2>
     b80:	88 23       	and	r24, r24
     b82:	21 f0       	breq	.+8      	; 0xb8c <Motor_Tick+0x338>
     b84:	81 e0       	ldi	r24, 0x01	; 1
     b86:	80 93 89 07 	sts	0x0789, r24	; 0x800789 <checker2>
     b8a:	02 c0       	rjmp	.+4      	; 0xb90 <Motor_Tick+0x33c>
     b8c:	10 92 89 07 	sts	0x0789, r1	; 0x800789 <checker2>
    nokia_lcd.cursor_y = y;
     b90:	ff dc       	rcall	.-1538   	; 0x590 <nokia_lcd_clear>
     b92:	0f 2e       	mov	r0, r31
     b94:	f7 e8       	ldi	r31, 0x87	; 135
				}
			}
			
			nokia_lcd_clear();
			nokia_lcd_set_cursor(30, 0);
			nokia_lcd_write_string("CODE?", 1);
     b96:	ef 2e       	mov	r14, r31
     b98:	f9 e0       	ldi	r31, 0x09	; 9
     b9a:	ff 2e       	mov	r15, r31
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     b9c:	f0 2d       	mov	r31, r0
     b9e:	1e e1       	ldi	r17, 0x1E	; 30
     ba0:	f7 01       	movw	r30, r14
    nokia_lcd.cursor_y = y;
     ba2:	10 83       	st	Z, r17
			nokia_lcd_set_cursor(10, 30);
			nokia_lcd_write_string("Entry: ", 1);
     ba4:	c8 e8       	ldi	r28, 0x88	; 136
     ba6:	d9 e0       	ldi	r29, 0x09	; 9
     ba8:	18 82       	st	Y, r1
     baa:	61 e0       	ldi	r22, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     bac:	88 e4       	ldi	r24, 0x48	; 72
     bae:	91 e0       	ldi	r25, 0x01	; 1
			nokia_lcd_set_cursor(50, 30);
			nokia_lcd_write_char(key, 1);
     bb0:	d7 dd       	rcall	.-1106   	; 0x760 <nokia_lcd_write_string>
     bb2:	8a e0       	ldi	r24, 0x0A	; 10
     bb4:	f7 01       	movw	r30, r14
     bb6:	80 83       	st	Z, r24
     bb8:	18 83       	st	Y, r17
     bba:	61 e0       	ldi	r22, 0x01	; 1
    nokia_lcd.cursor_y = y;
     bbc:	8e e4       	ldi	r24, 0x4E	; 78
			nokia_lcd_set_cursor(60, 30);
			nokia_lcd_write_char(key2, 1);
     bbe:	91 e0       	ldi	r25, 0x01	; 1
     bc0:	cf dd       	rcall	.-1122   	; 0x760 <nokia_lcd_write_string>
     bc2:	82 e3       	ldi	r24, 0x32	; 50
     bc4:	f7 01       	movw	r30, r14
			nokia_lcd_render();
     bc6:	80 83       	st	Z, r24
     bc8:	18 83       	st	Y, r17
			break;
     bca:	61 e0       	ldi	r22, 0x01	; 1
     bcc:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <key>
			
		case READ_KEY_WAIT_3:
			break;
		
		case READ_KEY_INIT_3:
			if((USART_HasReceived(0))){
     bd0:	1b dd       	rcall	.-1482   	; 0x608 <nokia_lcd_write_char>
     bd2:	8c e3       	ldi	r24, 0x3C	; 60
				bt_check = 1;
     bd4:	f7 01       	movw	r30, r14
     bd6:	80 83       	st	Z, r24
     bd8:	18 83       	st	Y, r17
				key3 = USART_Receive(0);
     bda:	61 e0       	ldi	r22, 0x01	; 1
     bdc:	80 91 e6 09 	lds	r24, 0x09E6	; 0x8009e6 <key2>
     be0:	13 dd       	rcall	.-1498   	; 0x608 <nokia_lcd_write_char>
				USART_Flush(0);
     be2:	d0 dd       	rcall	.-1120   	; 0x784 <nokia_lcd_render>
     be4:	cf c1       	rjmp	.+926    	; 0xf84 <Motor_Tick+0x730>
     be6:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
			}
			else{
				key3 = GetKeypadKey();
     bea:	88 23       	and	r24, r24
     bec:	54 f4       	brge	.+20     	; 0xc02 <Motor_Tick+0x3ae>
				if ((key3 != '\0')){
     bee:	81 e0       	ldi	r24, 0x01	; 1
					checker3 = 1;
     bf0:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <bt_check>
     bf4:	80 e0       	ldi	r24, 0x00	; 0
     bf6:	1c de       	rcall	.-968    	; 0x830 <USART_Receive>
				}
				else{
					checker3 = 0;
     bf8:	80 93 e5 09 	sts	0x09E5, r24	; 0x8009e5 <key3>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     bfc:	80 e0       	ldi	r24, 0x00	; 0
     bfe:	fb dd       	rcall	.-1034   	; 0x7f6 <USART_Flush>
     c00:	0b c0       	rjmp	.+22     	; 0xc18 <Motor_Tick+0x3c4>
     c02:	42 dc       	rcall	.-1916   	; 0x488 <GetKeypadKey>
     c04:	80 93 e5 09 	sts	0x09E5, r24	; 0x8009e5 <key3>
     c08:	88 23       	and	r24, r24
     c0a:	21 f0       	breq	.+8      	; 0xc14 <Motor_Tick+0x3c0>
    nokia_lcd.cursor_y = y;
     c0c:	81 e0       	ldi	r24, 0x01	; 1
     c0e:	80 93 88 07 	sts	0x0788, r24	; 0x800788 <checker3>
				}
			}
		
			nokia_lcd_clear();
			nokia_lcd_set_cursor(30, 0);
			nokia_lcd_write_string("CODE?", 1);
     c12:	02 c0       	rjmp	.+4      	; 0xc18 <Motor_Tick+0x3c4>
     c14:	10 92 88 07 	sts	0x0788, r1	; 0x800788 <checker3>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     c18:	bb dc       	rcall	.-1674   	; 0x590 <nokia_lcd_clear>
     c1a:	0f 2e       	mov	r0, r31
     c1c:	f7 e8       	ldi	r31, 0x87	; 135
    nokia_lcd.cursor_y = y;
     c1e:	ef 2e       	mov	r14, r31
			nokia_lcd_set_cursor(10, 30);
			nokia_lcd_write_string("Entry: ", 1);
     c20:	f9 e0       	ldi	r31, 0x09	; 9
     c22:	ff 2e       	mov	r15, r31
     c24:	f0 2d       	mov	r31, r0
     c26:	1e e1       	ldi	r17, 0x1E	; 30
     c28:	f7 01       	movw	r30, r14
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     c2a:	10 83       	st	Z, r17
     c2c:	c8 e8       	ldi	r28, 0x88	; 136
     c2e:	d9 e0       	ldi	r29, 0x09	; 9
    nokia_lcd.cursor_y = y;
     c30:	18 82       	st	Y, r1
			nokia_lcd_set_cursor(50, 30);
			nokia_lcd_write_char(key, 1);
     c32:	61 e0       	ldi	r22, 0x01	; 1
     c34:	88 e4       	ldi	r24, 0x48	; 72
     c36:	91 e0       	ldi	r25, 0x01	; 1
     c38:	93 dd       	rcall	.-1242   	; 0x760 <nokia_lcd_write_string>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     c3a:	8a e0       	ldi	r24, 0x0A	; 10
     c3c:	f7 01       	movw	r30, r14
     c3e:	80 83       	st	Z, r24
    nokia_lcd.cursor_y = y;
     c40:	18 83       	st	Y, r17
			nokia_lcd_set_cursor(60, 30);
			nokia_lcd_write_char(key2, 1);
     c42:	61 e0       	ldi	r22, 0x01	; 1
     c44:	8e e4       	ldi	r24, 0x4E	; 78
     c46:	91 e0       	ldi	r25, 0x01	; 1
     c48:	8b dd       	rcall	.-1258   	; 0x760 <nokia_lcd_write_string>
     c4a:	82 e3       	ldi	r24, 0x32	; 50
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     c4c:	f7 01       	movw	r30, r14
     c4e:	80 83       	st	Z, r24
     c50:	18 83       	st	Y, r17
			nokia_lcd_set_cursor(70, 30);
			nokia_lcd_write_char(key3, 1);
     c52:	61 e0       	ldi	r22, 0x01	; 1
     c54:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <key>
     c58:	d7 dc       	rcall	.-1618   	; 0x608 <nokia_lcd_write_char>
			nokia_lcd_render();
     c5a:	8c e3       	ldi	r24, 0x3C	; 60
     c5c:	f7 01       	movw	r30, r14
			break;
			
			
		case READ_KEY:
			if((key == passwordarray[0]) && (key2 == passwordarray[1]) && (key3 == passwordarray[2])){ 
     c5e:	80 83       	st	Z, r24
     c60:	18 83       	st	Y, r17
     c62:	61 e0       	ldi	r22, 0x01	; 1
     c64:	80 91 e6 09 	lds	r24, 0x09E6	; 0x8009e6 <key2>
     c68:	cf dc       	rcall	.-1634   	; 0x608 <nokia_lcd_write_char>
     c6a:	86 e4       	ldi	r24, 0x46	; 70
     c6c:	f7 01       	movw	r30, r14
     c6e:	80 83       	st	Z, r24
     c70:	18 83       	st	Y, r17
				lr = 2;
     c72:	61 e0       	ldi	r22, 0x01	; 1
     c74:	80 91 e5 09 	lds	r24, 0x09E5	; 0x8009e5 <key3>
     c78:	c7 dc       	rcall	.-1650   	; 0x608 <nokia_lcd_write_char>
			}
			else{
				nokia_lcd_clear();
     c7a:	84 dd       	rcall	.-1272   	; 0x784 <nokia_lcd_render>
     c7c:	83 c1       	rjmp	.+774    	; 0xf84 <Motor_Tick+0x730>
     c7e:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     c82:	80 91 e6 09 	lds	r24, 0x09E6	; 0x8009e6 <key2>
    nokia_lcd.cursor_y = y;
     c86:	98 13       	cpse	r25, r24
     c88:	0a c0       	rjmp	.+20     	; 0xc9e <Motor_Tick+0x44a>
     c8a:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <__data_start+0x2>
     c8e:	80 91 e5 09 	lds	r24, 0x09E5	; 0x8009e5 <key3>
				nokia_lcd_set_cursor(0, 10);
				nokia_lcd_write_string("WRONG PASSWORD", 1);
     c92:	98 13       	cpse	r25, r24
     c94:	04 c0       	rjmp	.+8      	; 0xc9e <Motor_Tick+0x44a>
     c96:	82 e0       	ldi	r24, 0x02	; 2
     c98:	80 93 87 07 	sts	0x0787, r24	; 0x800787 <lr>
				nokia_lcd_set_cursor(0, 20);
				nokia_lcd_write_string("RESTART BOARD", 1);
     c9c:	73 c1       	rjmp	.+742    	; 0xf84 <Motor_Tick+0x730>
     c9e:	78 dc       	rcall	.-1808   	; 0x590 <nokia_lcd_clear>
     ca0:	07 e8       	ldi	r16, 0x87	; 135
     ca2:	19 e0       	ldi	r17, 0x09	; 9
     ca4:	f8 01       	movw	r30, r16
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ca6:	10 82       	st	Z, r1
     ca8:	c8 e8       	ldi	r28, 0x88	; 136
    nokia_lcd.cursor_y = y;
     caa:	d9 e0       	ldi	r29, 0x09	; 9
     cac:	0f 2e       	mov	r0, r31
     cae:	fa e0       	ldi	r31, 0x0A	; 10
     cb0:	ff 2e       	mov	r15, r31
     cb2:	f0 2d       	mov	r31, r0
				nokia_lcd_set_cursor(10, 30);
				nokia_lcd_write_string("Entry: ", 1);
     cb4:	f8 82       	st	Y, r15
     cb6:	61 e0       	ldi	r22, 0x01	; 1
     cb8:	86 e5       	ldi	r24, 0x56	; 86
     cba:	91 e0       	ldi	r25, 0x01	; 1
     cbc:	51 dd       	rcall	.-1374   	; 0x760 <nokia_lcd_write_string>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     cbe:	f8 01       	movw	r30, r16
     cc0:	10 82       	st	Z, r1
     cc2:	84 e1       	ldi	r24, 0x14	; 20
    nokia_lcd.cursor_y = y;
     cc4:	88 83       	st	Y, r24
				nokia_lcd_set_cursor(50, 30);
				nokia_lcd_write_char(key, 1);
     cc6:	61 e0       	ldi	r22, 0x01	; 1
     cc8:	85 e6       	ldi	r24, 0x65	; 101
     cca:	91 e0       	ldi	r25, 0x01	; 1
     ccc:	49 dd       	rcall	.-1390   	; 0x760 <nokia_lcd_write_string>
     cce:	f8 01       	movw	r30, r16
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     cd0:	f0 82       	st	Z, r15
     cd2:	0f 2e       	mov	r0, r31
     cd4:	fe e1       	ldi	r31, 0x1E	; 30
    nokia_lcd.cursor_y = y;
     cd6:	ff 2e       	mov	r15, r31
				nokia_lcd_set_cursor(60, 30);
				nokia_lcd_write_char(key2, 1);
     cd8:	f0 2d       	mov	r31, r0
     cda:	f8 82       	st	Y, r15
     cdc:	61 e0       	ldi	r22, 0x01	; 1
     cde:	8e e4       	ldi	r24, 0x4E	; 78
     ce0:	91 e0       	ldi	r25, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     ce2:	3e dd       	rcall	.-1412   	; 0x760 <nokia_lcd_write_string>
     ce4:	82 e3       	ldi	r24, 0x32	; 50
     ce6:	f8 01       	movw	r30, r16
    nokia_lcd.cursor_y = y;
     ce8:	80 83       	st	Z, r24
				nokia_lcd_set_cursor(70, 30);
				nokia_lcd_write_char(key3, 1);
     cea:	f8 82       	st	Y, r15
     cec:	61 e0       	ldi	r22, 0x01	; 1
     cee:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <key>
     cf2:	8a dc       	rcall	.-1772   	; 0x608 <nokia_lcd_write_char>
				nokia_lcd_render();
     cf4:	8c e3       	ldi	r24, 0x3C	; 60
     cf6:	f8 01       	movw	r30, r16
     cf8:	80 83       	st	Z, r24
			
			break;
		
		case UNLOCK:
			if(lr){
				if (temp < 7) {temp = temp + 1;}
     cfa:	f8 82       	st	Y, r15
     cfc:	61 e0       	ldi	r22, 0x01	; 1
     cfe:	80 91 e6 09 	lds	r24, 0x09E6	; 0x8009e6 <key2>
     d02:	82 dc       	rcall	.-1788   	; 0x608 <nokia_lcd_write_char>
     d04:	86 e4       	ldi	r24, 0x46	; 70
				else {temp = 0;}
     d06:	f8 01       	movw	r30, r16
     d08:	80 83       	st	Z, r24
			
				if((numPhases - 1) == 0)
     d0a:	f8 82       	st	Y, r15
     d0c:	61 e0       	ldi	r22, 0x01	; 1
     d0e:	80 91 e5 09 	lds	r24, 0x09E5	; 0x8009e5 <key3>
     d12:	7a dc       	rcall	.-1804   	; 0x608 <nokia_lcd_write_char>
     d14:	37 dd       	rcall	.-1426   	; 0x784 <nokia_lcd_render>
     d16:	36 c1       	rjmp	.+620    	; 0xf84 <Motor_Tick+0x730>
     d18:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <temp>
     d1c:	87 30       	cpi	r24, 0x07	; 7
     d1e:	20 f4       	brcc	.+8      	; 0xd28 <Motor_Tick+0x4d4>
				{
					lr = 0;
     d20:	8f 5f       	subi	r24, 0xFF	; 255
     d22:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <temp>
				}
			} 
			if(garage_button == 8){PORTA = (loc[temp] << 4); PORTD = ((0x01 << 4) | PORTD); room = 2;}
     d26:	02 c0       	rjmp	.+4      	; 0xd2c <Motor_Tick+0x4d8>
     d28:	10 92 8e 07 	sts	0x078E, r1	; 0x80078e <temp>
     d2c:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <numPhases>
     d30:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <numPhases+0x1>
     d34:	a0 91 05 01 	lds	r26, 0x0105	; 0x800105 <numPhases+0x2>
     d38:	b0 91 06 01 	lds	r27, 0x0106	; 0x800106 <numPhases+0x3>
     d3c:	01 97       	sbiw	r24, 0x01	; 1
     d3e:	a1 05       	cpc	r26, r1
     d40:	b1 05       	cpc	r27, r1
			else{PORTA = loc[temp]; PORTD = SetBit(PORTD,4,0); room = 1;}
     d42:	11 f4       	brne	.+4      	; 0xd48 <Motor_Tick+0x4f4>
     d44:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <lr>
     d48:	38 30       	cpi	r19, 0x08	; 8
     d4a:	71 f4       	brne	.+28     	; 0xd68 <Motor_Tick+0x514>
     d4c:	e0 91 8e 07 	lds	r30, 0x078E	; 0x80078e <temp>
     d50:	f0 e0       	ldi	r31, 0x00	; 0
     d52:	e9 5f       	subi	r30, 0xF9	; 249
     d54:	fe 4f       	sbci	r31, 0xFE	; 254
				
			nokia_lcd_clear();
     d56:	80 81       	ld	r24, Z
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     d58:	82 95       	swap	r24
     d5a:	80 7f       	andi	r24, 0xF0	; 240
     d5c:	82 b9       	out	0x02, r24	; 2
     d5e:	5c 9a       	sbi	0x0b, 4	; 11
     d60:	82 e0       	ldi	r24, 0x02	; 2
     d62:	80 93 86 07 	sts	0x0786, r24	; 0x800786 <room>
     d66:	0b c0       	rjmp	.+22     	; 0xd7e <Motor_Tick+0x52a>
    nokia_lcd.cursor_y = y;
     d68:	e0 91 8e 07 	lds	r30, 0x078E	; 0x80078e <temp>
     d6c:	f0 e0       	ldi	r31, 0x00	; 0
     d6e:	e9 5f       	subi	r30, 0xF9	; 249
			nokia_lcd_set_cursor(10, 10);
			nokia_lcd_write_string("UNLOCKING!", 1);
     d70:	fe 4f       	sbci	r31, 0xFE	; 254
     d72:	80 81       	ld	r24, Z
     d74:	82 b9       	out	0x02, r24	; 2
     d76:	5c 98       	cbi	0x0b, 4	; 11
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     d78:	81 e0       	ldi	r24, 0x01	; 1
    nokia_lcd.cursor_y = y;
     d7a:	80 93 86 07 	sts	0x0786, r24	; 0x800786 <room>
     d7e:	08 dc       	rcall	.-2032   	; 0x590 <nokia_lcd_clear>
			nokia_lcd_set_cursor(10, 30);
			nokia_lcd_write_string("Entry: ", 1);
     d80:	0f 2e       	mov	r0, r31
     d82:	f7 e8       	ldi	r31, 0x87	; 135
     d84:	ef 2e       	mov	r14, r31
     d86:	f9 e0       	ldi	r31, 0x09	; 9
     d88:	ff 2e       	mov	r15, r31
			if(bt_check == 0){
     d8a:	f0 2d       	mov	r31, r0
     d8c:	ca e0       	ldi	r28, 0x0A	; 10
     d8e:	f7 01       	movw	r30, r14
     d90:	c0 83       	st	Z, r28
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     d92:	08 e8       	ldi	r16, 0x88	; 136
     d94:	19 e0       	ldi	r17, 0x09	; 9
    nokia_lcd.cursor_y = y;
     d96:	f8 01       	movw	r30, r16
     d98:	c0 83       	st	Z, r28
				nokia_lcd_set_cursor(50, 30);
				nokia_lcd_write_char(key, 1);
     d9a:	61 e0       	ldi	r22, 0x01	; 1
     d9c:	83 e7       	ldi	r24, 0x73	; 115
     d9e:	91 e0       	ldi	r25, 0x01	; 1
     da0:	df dc       	rcall	.-1602   	; 0x760 <nokia_lcd_write_string>
     da2:	f7 01       	movw	r30, r14
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     da4:	c0 83       	st	Z, r28
    nokia_lcd.cursor_y = y;
     da6:	8e e1       	ldi	r24, 0x1E	; 30
				nokia_lcd_set_cursor(60, 30);
				nokia_lcd_write_char(key2, 1);
     da8:	f8 01       	movw	r30, r16
     daa:	80 83       	st	Z, r24
     dac:	61 e0       	ldi	r22, 0x01	; 1
     dae:	8e e4       	ldi	r24, 0x4E	; 78
     db0:	91 e0       	ldi	r25, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     db2:	d6 dc       	rcall	.-1620   	; 0x760 <nokia_lcd_write_string>
     db4:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <bt_check>
    nokia_lcd.cursor_y = y;
     db8:	81 11       	cpse	r24, r1
				nokia_lcd_set_cursor(70, 30);
				nokia_lcd_write_char(key3, 1);
     dba:	1b c0       	rjmp	.+54     	; 0xdf2 <Motor_Tick+0x59e>
     dbc:	82 e3       	ldi	r24, 0x32	; 50
     dbe:	f7 01       	movw	r30, r14
     dc0:	80 83       	st	Z, r24
     dc2:	e8 01       	movw	r28, r16
     dc4:	1e e1       	ldi	r17, 0x1E	; 30
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     dc6:	18 83       	st	Y, r17
     dc8:	61 e0       	ldi	r22, 0x01	; 1
     dca:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <key>
    nokia_lcd.cursor_y = y;
     dce:	1c dc       	rcall	.-1992   	; 0x608 <nokia_lcd_write_char>
     dd0:	8c e3       	ldi	r24, 0x3C	; 60
			}
			else{
				nokia_lcd_set_cursor(50, 30);
				nokia_lcd_write_string("Phone", 1);
     dd2:	f7 01       	movw	r30, r14
     dd4:	80 83       	st	Z, r24
     dd6:	18 83       	st	Y, r17
     dd8:	61 e0       	ldi	r22, 0x01	; 1
     dda:	80 91 e6 09 	lds	r24, 0x09E6	; 0x8009e6 <key2>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     dde:	14 dc       	rcall	.-2008   	; 0x608 <nokia_lcd_write_char>
     de0:	86 e4       	ldi	r24, 0x46	; 70
     de2:	f7 01       	movw	r30, r14
     de4:	80 83       	st	Z, r24
     de6:	18 83       	st	Y, r17
     de8:	61 e0       	ldi	r22, 0x01	; 1
     dea:	80 91 e5 09 	lds	r24, 0x09E5	; 0x8009e5 <key3>
    nokia_lcd.cursor_y = y;
     dee:	0c dc       	rcall	.-2024   	; 0x608 <nokia_lcd_write_char>
     df0:	0a c0       	rjmp	.+20     	; 0xe06 <Motor_Tick+0x5b2>
     df2:	82 e3       	ldi	r24, 0x32	; 50
     df4:	80 93 87 09 	sts	0x0987, r24	; 0x800987 <nokia_lcd+0x1f8>
			}
			nokia_lcd_set_cursor(10, 40);
			nokia_lcd_write_string("Room: ", 1);
     df8:	8e e1       	ldi	r24, 0x1E	; 30
     dfa:	80 93 88 09 	sts	0x0988, r24	; 0x800988 <nokia_lcd+0x1f9>
     dfe:	61 e0       	ldi	r22, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     e00:	8e e7       	ldi	r24, 0x7E	; 126
     e02:	91 e0       	ldi	r25, 0x01	; 1
     e04:	ad dc       	rcall	.-1702   	; 0x760 <nokia_lcd_write_string>
    nokia_lcd.cursor_y = y;
     e06:	0f 2e       	mov	r0, r31
			nokia_lcd_set_cursor(65, 40);
			nokia_lcd_write_char(room + '0', 1);
     e08:	f7 e8       	ldi	r31, 0x87	; 135
     e0a:	ef 2e       	mov	r14, r31
     e0c:	f9 e0       	ldi	r31, 0x09	; 9
     e0e:	ff 2e       	mov	r15, r31
     e10:	f0 2d       	mov	r31, r0
			nokia_lcd_render();
     e12:	8a e0       	ldi	r24, 0x0A	; 10
     e14:	f7 01       	movw	r30, r14
			break;
     e16:	80 83       	st	Z, r24
			
		case LOCK:
			if(lr){
				if (temp > 0) {temp = temp - 1;}
     e18:	c8 e8       	ldi	r28, 0x88	; 136
     e1a:	d9 e0       	ldi	r29, 0x09	; 9
     e1c:	18 e2       	ldi	r17, 0x28	; 40
     e1e:	18 83       	st	Y, r17
     e20:	61 e0       	ldi	r22, 0x01	; 1
     e22:	84 e8       	ldi	r24, 0x84	; 132
     e24:	91 e0       	ldi	r25, 0x01	; 1
     e26:	9c dc       	rcall	.-1736   	; 0x760 <nokia_lcd_write_string>
				else {temp = 7;}
     e28:	81 e4       	ldi	r24, 0x41	; 65
     e2a:	f7 01       	movw	r30, r14
			
				if((numPhases - 1) == 0)
     e2c:	80 83       	st	Z, r24
     e2e:	18 83       	st	Y, r17
     e30:	80 91 86 07 	lds	r24, 0x0786	; 0x800786 <room>
     e34:	61 e0       	ldi	r22, 0x01	; 1
     e36:	80 5d       	subi	r24, 0xD0	; 208
     e38:	e7 db       	rcall	.-2098   	; 0x608 <nokia_lcd_write_char>
     e3a:	a4 dc       	rcall	.-1720   	; 0x784 <nokia_lcd_render>
     e3c:	a3 c0       	rjmp	.+326    	; 0xf84 <Motor_Tick+0x730>
     e3e:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <temp>
				{
					lr = 0;
     e42:	88 23       	and	r24, r24
     e44:	21 f0       	breq	.+8      	; 0xe4e <Motor_Tick+0x5fa>
				}
				
			}
			if(garage_button == 8){PORTA = (loc[temp] << 4); PORTD = ((0x01 << 4) | PORTD); room = 2;}
     e46:	81 50       	subi	r24, 0x01	; 1
     e48:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <temp>
     e4c:	03 c0       	rjmp	.+6      	; 0xe54 <Motor_Tick+0x600>
     e4e:	87 e0       	ldi	r24, 0x07	; 7
     e50:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <temp>
     e54:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <numPhases>
     e58:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <numPhases+0x1>
     e5c:	a0 91 05 01 	lds	r26, 0x0105	; 0x800105 <numPhases+0x2>
     e60:	b0 91 06 01 	lds	r27, 0x0106	; 0x800106 <numPhases+0x3>
			else{PORTA = loc[temp]; PORTD = SetBit(PORTD,4,0); room = 1;}
     e64:	01 97       	sbiw	r24, 0x01	; 1
     e66:	a1 05       	cpc	r26, r1
     e68:	b1 05       	cpc	r27, r1
     e6a:	11 f4       	brne	.+4      	; 0xe70 <Motor_Tick+0x61c>
     e6c:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <lr>
     e70:	38 30       	cpi	r19, 0x08	; 8
     e72:	71 f4       	brne	.+28     	; 0xe90 <Motor_Tick+0x63c>
			
			nokia_lcd_clear();
     e74:	e0 91 8e 07 	lds	r30, 0x078E	; 0x80078e <temp>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     e78:	f0 e0       	ldi	r31, 0x00	; 0
     e7a:	e9 5f       	subi	r30, 0xF9	; 249
     e7c:	fe 4f       	sbci	r31, 0xFE	; 254
     e7e:	80 81       	ld	r24, Z
     e80:	82 95       	swap	r24
     e82:	80 7f       	andi	r24, 0xF0	; 240
     e84:	82 b9       	out	0x02, r24	; 2
    nokia_lcd.cursor_y = y;
     e86:	5c 9a       	sbi	0x0b, 4	; 11
     e88:	82 e0       	ldi	r24, 0x02	; 2
     e8a:	80 93 86 07 	sts	0x0786, r24	; 0x800786 <room>
			nokia_lcd_set_cursor(10, 10);
			nokia_lcd_write_string("LOCKING!", 1);
     e8e:	0b c0       	rjmp	.+22     	; 0xea6 <Motor_Tick+0x652>
     e90:	e0 91 8e 07 	lds	r30, 0x078E	; 0x80078e <temp>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     e94:	f0 e0       	ldi	r31, 0x00	; 0
     e96:	e9 5f       	subi	r30, 0xF9	; 249
    nokia_lcd.cursor_y = y;
     e98:	fe 4f       	sbci	r31, 0xFE	; 254
     e9a:	80 81       	ld	r24, Z
     e9c:	82 b9       	out	0x02, r24	; 2
     e9e:	5c 98       	cbi	0x0b, 4	; 11
     ea0:	81 e0       	ldi	r24, 0x01	; 1
			nokia_lcd_set_cursor(10, 40);
			nokia_lcd_write_string("Room: ", 1);
     ea2:	80 93 86 07 	sts	0x0786, r24	; 0x800786 <room>
     ea6:	74 db       	rcall	.-2328   	; 0x590 <nokia_lcd_clear>
     ea8:	07 e8       	ldi	r16, 0x87	; 135
     eaa:	19 e0       	ldi	r17, 0x09	; 9
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     eac:	0f 2e       	mov	r0, r31
     eae:	fa e0       	ldi	r31, 0x0A	; 10
    nokia_lcd.cursor_y = y;
     eb0:	ff 2e       	mov	r15, r31
			nokia_lcd_set_cursor(65, 40);
			nokia_lcd_write_char(room + '0', 1);
     eb2:	f0 2d       	mov	r31, r0
     eb4:	f8 01       	movw	r30, r16
     eb6:	f0 82       	st	Z, r15
     eb8:	c8 e8       	ldi	r28, 0x88	; 136
     eba:	d9 e0       	ldi	r29, 0x09	; 9
			nokia_lcd_render();
     ebc:	f8 82       	st	Y, r15
     ebe:	61 e0       	ldi	r22, 0x01	; 1
			break;
		
		default:
			break;
	}
}
     ec0:	85 e7       	ldi	r24, 0x75	; 117
			nokia_lcd_render();
			break;
			
			
		case READ_KEY:
			if((key == passwordarray[0]) && (key2 == passwordarray[1]) && (key3 == passwordarray[2])){ 
     ec2:	91 e0       	ldi	r25, 0x01	; 1
     ec4:	4d dc       	rcall	.-1894   	; 0x760 <nokia_lcd_write_string>
     ec6:	f8 01       	movw	r30, r16
     ec8:	f0 82       	st	Z, r15
     eca:	0f 2e       	mov	r0, r31
     ecc:	f8 e2       	ldi	r31, 0x28	; 40
			
			
	switch(motor_state)
	{
		case READ_MOTION:
			PORTD = SetBit(PORTD,4,0); //GARAGE LIGHT OFF
     ece:	ff 2e       	mov	r15, r31
			if (motion_sensor == 0){
     ed0:	f0 2d       	mov	r31, r0
     ed2:	f8 82       	st	Y, r15
     ed4:	61 e0       	ldi	r22, 0x01	; 1
			}
			nokia_lcd_render();
			break;
			
		case MENU:
			menu_key = GetKeypadKey();
     ed6:	84 e8       	ldi	r24, 0x84	; 132
     ed8:	91 e0       	ldi	r25, 0x01	; 1
     eda:	42 dc       	rcall	.-1916   	; 0x760 <nokia_lcd_write_string>
     edc:	81 e4       	ldi	r24, 0x41	; 65
			if ((menu_key == 'A')){
     ede:	f8 01       	movw	r30, r16
     ee0:	80 83       	st	Z, r24
     ee2:	f8 82       	st	Y, r15
     ee4:	80 91 86 07 	lds	r24, 0x0786	; 0x800786 <room>
			nokia_lcd_write_char(key, 1);
			nokia_lcd_render();
			break;
			
		case CURRENT_PASS:
			nokia_lcd_clear();
     ee8:	61 e0       	ldi	r22, 0x01	; 1
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     eea:	80 5d       	subi	r24, 0xD0	; 208
     eec:	8d db       	rcall	.-2278   	; 0x608 <nokia_lcd_write_char>
     eee:	4a dc       	rcall	.-1900   	; 0x784 <nokia_lcd_render>
     ef0:	49 c0       	rjmp	.+146    	; 0xf84 <Motor_Tick+0x730>
     ef2:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
     ef6:	80 91 e4 09 	lds	r24, 0x09E4	; 0x8009e4 <key>
     efa:	98 17       	cp	r25, r24
    nokia_lcd.cursor_y = y;
     efc:	09 f4       	brne	.+2      	; 0xf00 <Motor_Tick+0x6ac>
     efe:	bf ce       	rjmp	.-642    	; 0xc7e <Motor_Tick+0x42a>
     f00:	ce ce       	rjmp	.-612    	; 0xc9e <Motor_Tick+0x44a>
     f02:	5c 98       	cbi	0x0b, 4	; 11
			nokia_lcd_set_cursor(5, 10);
			nokia_lcd_write_string("Current Code:", 1);
     f04:	21 11       	cpse	r18, r1
     f06:	be cd       	rjmp	.-1156   	; 0xa84 <Motor_Tick+0x230>
     f08:	a7 cd       	rjmp	.-1202   	; 0xa58 <Motor_Tick+0x204>
     f0a:	be da       	rcall	.-2692   	; 0x488 <GetKeypadKey>
     f0c:	80 93 e7 09 	sts	0x09E7, r24	; 0x8009e7 <menu_key>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     f10:	81 34       	cpi	r24, 0x41	; 65
    nokia_lcd.cursor_y = y;
     f12:	09 f0       	breq	.+2      	; 0xf16 <Motor_Tick+0x6c2>
     f14:	bd cd       	rjmp	.-1158   	; 0xa90 <Motor_Tick+0x23c>
			nokia_lcd_set_cursor(10, 20);
			nokia_lcd_write_char(passwordarray[0], 1);
     f16:	b8 cd       	rjmp	.-1168   	; 0xa88 <Motor_Tick+0x234>
     f18:	3b db       	rcall	.-2442   	; 0x590 <nokia_lcd_clear>
     f1a:	0f 2e       	mov	r0, r31
     f1c:	f7 e8       	ldi	r31, 0x87	; 135
     f1e:	ef 2e       	mov	r14, r31
     f20:	f9 e0       	ldi	r31, 0x09	; 9
     f22:	ff 2e       	mov	r15, r31
     f24:	f0 2d       	mov	r31, r0
     f26:	85 e0       	ldi	r24, 0x05	; 5
     f28:	f7 01       	movw	r30, r14
     f2a:	80 83       	st	Z, r24
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     f2c:	c8 e8       	ldi	r28, 0x88	; 136
     f2e:	d9 e0       	ldi	r29, 0x09	; 9
    nokia_lcd.cursor_y = y;
     f30:	1a e0       	ldi	r17, 0x0A	; 10
			nokia_lcd_set_cursor(20, 20);
			nokia_lcd_write_char(passwordarray[1], 1);
     f32:	18 83       	st	Y, r17
     f34:	61 e0       	ldi	r22, 0x01	; 1
     f36:	8b e8       	ldi	r24, 0x8B	; 139
     f38:	91 e0       	ldi	r25, 0x01	; 1
     f3a:	12 dc       	rcall	.-2012   	; 0x760 <nokia_lcd_write_string>
        nokia_lcd_write_char(*str++, scale);
}
  
void nokia_lcd_set_cursor(uint8_t x, uint8_t y)
{
    nokia_lcd.cursor_x = x;
     f3c:	f7 01       	movw	r30, r14
     f3e:	10 83       	st	Z, r17
     f40:	14 e1       	ldi	r17, 0x14	; 20
    nokia_lcd.cursor_y = y;
     f42:	18 83       	st	Y, r17
			nokia_lcd_set_cursor(30, 20);
			nokia_lcd_write_char(passwordarray[2], 1);
     f44:	0f 2e       	mov	r0, r31
     f46:	f0 e0       	ldi	r31, 0x00	; 0
     f48:	cf 2e       	mov	r12, r31
     f4a:	f1 e0       	ldi	r31, 0x01	; 1
     f4c:	df 2e       	mov	r13, r31
			nokia_lcd_render();
     f4e:	f0 2d       	mov	r31, r0
     f50:	61 e0       	ldi	r22, 0x01	; 1
			break;
     f52:	f6 01       	movw	r30, r12
			nokia_lcd_write_char(room + '0', 1);
			nokia_lcd_render();
			break;
			
		case LOCK:
			if(lr){
     f54:	80 81       	ld	r24, Z
     f56:	58 db       	rcall	.-2384   	; 0x608 <nokia_lcd_write_char>
     f58:	f7 01       	movw	r30, r14
     f5a:	10 83       	st	Z, r17
     f5c:	18 83       	st	Y, r17
			break;
		
		default:
			break;
	}
}
     f5e:	61 e0       	ldi	r22, 0x01	; 1
     f60:	f6 01       	movw	r30, r12
     f62:	81 81       	ldd	r24, Z+1	; 0x01
     f64:	51 db       	rcall	.-2398   	; 0x608 <nokia_lcd_write_char>
     f66:	8e e1       	ldi	r24, 0x1E	; 30
     f68:	f7 01       	movw	r30, r14
     f6a:	80 83       	st	Z, r24
     f6c:	18 83       	st	Y, r17
     f6e:	61 e0       	ldi	r22, 0x01	; 1
     f70:	f6 01       	movw	r30, r12
     f72:	82 81       	ldd	r24, Z+2	; 0x02
     f74:	49 db       	rcall	.-2414   	; 0x608 <nokia_lcd_write_char>
     f76:	06 dc       	rcall	.-2036   	; 0x784 <nokia_lcd_render>
     f78:	05 c0       	rjmp	.+10     	; 0xf84 <Motor_Tick+0x730>
     f7a:	80 91 87 07 	lds	r24, 0x0787	; 0x800787 <lr>
     f7e:	81 11       	cpse	r24, r1
     f80:	5e cf       	rjmp	.-324    	; 0xe3e <Motor_Tick+0x5ea>
     f82:	76 cf       	rjmp	.-276    	; 0xe70 <Motor_Tick+0x61c>
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	1f 91       	pop	r17
     f8a:	0f 91       	pop	r16
     f8c:	ff 90       	pop	r15
     f8e:	ef 90       	pop	r14
     f90:	df 90       	pop	r13
     f92:	cf 90       	pop	r12
     f94:	08 95       	ret

00000f96 <MotorTask>:
//////////////////////////////////////////////////////////////////////// LOCAL VARIABLES ////////////////////////////////////////////////////////////////////////

enum MotorState {READ_MOTION, MENU, READ_KEY_WAIT, READ_KEY_INIT, CURRENT_PASS, CHANGE_PASS, READ_KEY_WAIT_2, READ_KEY_INIT_2, READ_KEY_WAIT_3, READ_KEY_INIT_3, READ_KEY, LOCK, UNLOCK} motor_state;

void Motor_Init(){
	motor_state = READ_MOTION;
     f96:	10 92 e3 09 	sts	0x09E3, r1	; 0x8009e3 <motor_state>
{
	Motor_Init();
   for(;;) 
   { 	
	Motor_Tick();
	vTaskDelay(3); 
     f9a:	5c dc       	rcall	.-1864   	; 0x854 <Motor_Tick>
     f9c:	83 e0       	ldi	r24, 0x03	; 3
     f9e:	90 e0       	ldi	r25, 0x00	; 0
     fa0:	3e d4       	rcall	.+2172   	; 0x181e <vTaskDelay>
     fa2:	fb cf       	rjmp	.-10     	; 0xf9a <MotorTask+0x4>

00000fa4 <StartSecPulse>:
   } 
}

void StartSecPulse(unsigned portBASE_TYPE Priority)
{
     fa4:	af 92       	push	r10
     fa6:	bf 92       	push	r11
     fa8:	cf 92       	push	r12
     faa:	df 92       	push	r13
     fac:	ef 92       	push	r14
     fae:	ff 92       	push	r15
     fb0:	0f 93       	push	r16
	xTaskCreate(MotorTask, (signed portCHAR *)"MotorTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     fb2:	a1 2c       	mov	r10, r1
     fb4:	b1 2c       	mov	r11, r1
     fb6:	c1 2c       	mov	r12, r1
     fb8:	d1 2c       	mov	r13, r1
     fba:	e1 2c       	mov	r14, r1
     fbc:	f1 2c       	mov	r15, r1
     fbe:	08 2f       	mov	r16, r24
     fc0:	20 e0       	ldi	r18, 0x00	; 0
     fc2:	30 e0       	ldi	r19, 0x00	; 0
     fc4:	45 e5       	ldi	r20, 0x55	; 85
     fc6:	50 e0       	ldi	r21, 0x00	; 0
     fc8:	69 e9       	ldi	r22, 0x99	; 153
     fca:	71 e0       	ldi	r23, 0x01	; 1
     fcc:	8b ec       	ldi	r24, 0xCB	; 203
     fce:	97 e0       	ldi	r25, 0x07	; 7
     fd0:	ae d1       	rcall	.+860    	; 0x132e <xTaskGenericCreate>
}
     fd2:	0f 91       	pop	r16
     fd4:	ff 90       	pop	r15
     fd6:	ef 90       	pop	r14
     fd8:	df 90       	pop	r13
     fda:	cf 90       	pop	r12
     fdc:	bf 90       	pop	r11
     fde:	af 90       	pop	r10
     fe0:	08 95       	ret

00000fe2 <main>:
 
int main(void) 
{
   DDRA = 0xFF; PORTA = 0x00; //stepper
     fe2:	8f ef       	ldi	r24, 0xFF	; 255
     fe4:	81 b9       	out	0x01, r24	; 1
     fe6:	12 b8       	out	0x02, r1	; 2
   DDRB = 0xFF; PORTB = 0x00; //NOKIA 5110
     fe8:	84 b9       	out	0x04, r24	; 4
     fea:	15 b8       	out	0x05, r1	; 5
   DDRC = 0xF0, PORTC = 0x0F; //calculator
     fec:	80 ef       	ldi	r24, 0xF0	; 240
     fee:	87 b9       	out	0x07, r24	; 7
     ff0:	8f e0       	ldi	r24, 0x0F	; 15
     ff2:	88 b9       	out	0x08, r24	; 8
   DDRD = 0xF2; PORTD = 0x0D; //D0 (Rx of Bluetooth), D2 (IR sensor), and D3 (button) inputs and rest outputs for lightbulbs and Tx of Bluetooth
     ff4:	82 ef       	ldi	r24, 0xF2	; 242
     ff6:	8a b9       	out	0x0a, r24	; 10
     ff8:	8d e0       	ldi	r24, 0x0D	; 13
        nokia_lcd.screen[i] = 0x00;
}
  
void nokia_lcd_power(uint8_t on)
{
    write_cmd(on ? 0x20 : 0x24);
     ffa:	8b b9       	out	0x0b, r24	; 11
   
   nokia_lcd_init();
   nokia_lcd_power(1);
   initUSART(0);
     ffc:	93 da       	rcall	.-2778   	; 0x524 <nokia_lcd_init>
   
   //Start Tasks  
   StartSecPulse(1);
     ffe:	80 e2       	ldi	r24, 0x20	; 32
    1000:	40 da       	rcall	.-2944   	; 0x482 <write_cmd>
    1002:	80 e0       	ldi	r24, 0x00	; 0
    //RunSchedular 
   vTaskStartScheduler();
    1004:	d6 db       	rcall	.-2132   	; 0x7b2 <initUSART>
    1006:	81 e0       	ldi	r24, 0x01	; 1
   eeprom_write_byte(0, password)
   password = eeprom_read_byte(0);
   eeprom_update_byte(0, )
   */
   return 0; 
}
    1008:	cd df       	rcall	.-102    	; 0xfa4 <StartSecPulse>
    100a:	92 d2       	rcall	.+1316   	; 0x1530 <vTaskStartScheduler>
    100c:	80 e0       	ldi	r24, 0x00	; 0
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	08 95       	ret

00001012 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1012:	31 e1       	ldi	r19, 0x11	; 17
    1014:	fc 01       	movw	r30, r24
    1016:	30 83       	st	Z, r19
    1018:	31 97       	sbiw	r30, 0x01	; 1
    101a:	22 e2       	ldi	r18, 0x22	; 34
    101c:	20 83       	st	Z, r18
    101e:	31 97       	sbiw	r30, 0x01	; 1
    1020:	a3 e3       	ldi	r26, 0x33	; 51
    1022:	a0 83       	st	Z, r26
    1024:	31 97       	sbiw	r30, 0x01	; 1
    1026:	60 83       	st	Z, r22
    1028:	31 97       	sbiw	r30, 0x01	; 1
    102a:	70 83       	st	Z, r23
    102c:	31 97       	sbiw	r30, 0x01	; 1
    102e:	10 82       	st	Z, r1
    1030:	31 97       	sbiw	r30, 0x01	; 1
    1032:	60 e8       	ldi	r22, 0x80	; 128
    1034:	60 83       	st	Z, r22
    1036:	31 97       	sbiw	r30, 0x01	; 1
    1038:	10 82       	st	Z, r1
    103a:	31 97       	sbiw	r30, 0x01	; 1
    103c:	62 e0       	ldi	r22, 0x02	; 2
    103e:	60 83       	st	Z, r22
    1040:	31 97       	sbiw	r30, 0x01	; 1
    1042:	63 e0       	ldi	r22, 0x03	; 3
    1044:	60 83       	st	Z, r22
    1046:	31 97       	sbiw	r30, 0x01	; 1
    1048:	64 e0       	ldi	r22, 0x04	; 4
    104a:	60 83       	st	Z, r22
    104c:	31 97       	sbiw	r30, 0x01	; 1
    104e:	65 e0       	ldi	r22, 0x05	; 5
    1050:	60 83       	st	Z, r22
    1052:	31 97       	sbiw	r30, 0x01	; 1
    1054:	66 e0       	ldi	r22, 0x06	; 6
    1056:	60 83       	st	Z, r22
    1058:	31 97       	sbiw	r30, 0x01	; 1
    105a:	67 e0       	ldi	r22, 0x07	; 7
    105c:	60 83       	st	Z, r22
    105e:	31 97       	sbiw	r30, 0x01	; 1
    1060:	68 e0       	ldi	r22, 0x08	; 8
    1062:	60 83       	st	Z, r22
    1064:	31 97       	sbiw	r30, 0x01	; 1
    1066:	69 e0       	ldi	r22, 0x09	; 9
    1068:	60 83       	st	Z, r22
    106a:	31 97       	sbiw	r30, 0x01	; 1
    106c:	60 e1       	ldi	r22, 0x10	; 16
    106e:	60 83       	st	Z, r22
    1070:	31 97       	sbiw	r30, 0x01	; 1
    1072:	30 83       	st	Z, r19
    1074:	31 97       	sbiw	r30, 0x01	; 1
    1076:	32 e1       	ldi	r19, 0x12	; 18
    1078:	30 83       	st	Z, r19
    107a:	31 97       	sbiw	r30, 0x01	; 1
    107c:	33 e1       	ldi	r19, 0x13	; 19
    107e:	30 83       	st	Z, r19
    1080:	31 97       	sbiw	r30, 0x01	; 1
    1082:	34 e1       	ldi	r19, 0x14	; 20
    1084:	30 83       	st	Z, r19
    1086:	31 97       	sbiw	r30, 0x01	; 1
    1088:	35 e1       	ldi	r19, 0x15	; 21
    108a:	30 83       	st	Z, r19
    108c:	31 97       	sbiw	r30, 0x01	; 1
    108e:	36 e1       	ldi	r19, 0x16	; 22
    1090:	30 83       	st	Z, r19
    1092:	31 97       	sbiw	r30, 0x01	; 1
    1094:	37 e1       	ldi	r19, 0x17	; 23
    1096:	30 83       	st	Z, r19
    1098:	31 97       	sbiw	r30, 0x01	; 1
    109a:	38 e1       	ldi	r19, 0x18	; 24
    109c:	30 83       	st	Z, r19
    109e:	31 97       	sbiw	r30, 0x01	; 1
    10a0:	39 e1       	ldi	r19, 0x19	; 25
    10a2:	30 83       	st	Z, r19
    10a4:	31 97       	sbiw	r30, 0x01	; 1
    10a6:	30 e2       	ldi	r19, 0x20	; 32
    10a8:	30 83       	st	Z, r19
    10aa:	31 97       	sbiw	r30, 0x01	; 1
    10ac:	31 e2       	ldi	r19, 0x21	; 33
    10ae:	30 83       	st	Z, r19
    10b0:	31 97       	sbiw	r30, 0x01	; 1
    10b2:	20 83       	st	Z, r18
    10b4:	31 97       	sbiw	r30, 0x01	; 1
    10b6:	23 e2       	ldi	r18, 0x23	; 35
    10b8:	20 83       	st	Z, r18
    10ba:	31 97       	sbiw	r30, 0x01	; 1
    10bc:	40 83       	st	Z, r20
    10be:	31 97       	sbiw	r30, 0x01	; 1
    10c0:	50 83       	st	Z, r21
    10c2:	31 97       	sbiw	r30, 0x01	; 1
    10c4:	26 e2       	ldi	r18, 0x26	; 38
    10c6:	20 83       	st	Z, r18
    10c8:	31 97       	sbiw	r30, 0x01	; 1
    10ca:	27 e2       	ldi	r18, 0x27	; 39
    10cc:	20 83       	st	Z, r18
    10ce:	31 97       	sbiw	r30, 0x01	; 1
    10d0:	28 e2       	ldi	r18, 0x28	; 40
    10d2:	20 83       	st	Z, r18
    10d4:	31 97       	sbiw	r30, 0x01	; 1
    10d6:	29 e2       	ldi	r18, 0x29	; 41
    10d8:	20 83       	st	Z, r18
    10da:	31 97       	sbiw	r30, 0x01	; 1
    10dc:	20 e3       	ldi	r18, 0x30	; 48
    10de:	20 83       	st	Z, r18
    10e0:	31 97       	sbiw	r30, 0x01	; 1
    10e2:	21 e3       	ldi	r18, 0x31	; 49
    10e4:	20 83       	st	Z, r18
    10e6:	86 97       	sbiw	r24, 0x26	; 38
    10e8:	08 95       	ret

000010ea <xPortStartScheduler>:
    10ea:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    10ee:	8c e7       	ldi	r24, 0x7C	; 124
    10f0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
    10f4:	8b e0       	ldi	r24, 0x0B	; 11
    10f6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    10fa:	ef e6       	ldi	r30, 0x6F	; 111
    10fc:	f0 e0       	ldi	r31, 0x00	; 0
    10fe:	80 81       	ld	r24, Z
    1100:	82 60       	ori	r24, 0x02	; 2
    1102:	80 83       	st	Z, r24
    1104:	a0 91 e1 09 	lds	r26, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    1108:	b0 91 e2 09 	lds	r27, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    110c:	cd 91       	ld	r28, X+
    110e:	cd bf       	out	0x3d, r28	; 61
    1110:	dd 91       	ld	r29, X+
    1112:	de bf       	out	0x3e, r29	; 62
    1114:	ff 91       	pop	r31
    1116:	ef 91       	pop	r30
    1118:	df 91       	pop	r29
    111a:	cf 91       	pop	r28
    111c:	bf 91       	pop	r27
    111e:	af 91       	pop	r26
    1120:	9f 91       	pop	r25
    1122:	8f 91       	pop	r24
    1124:	7f 91       	pop	r23
    1126:	6f 91       	pop	r22
    1128:	5f 91       	pop	r21
    112a:	4f 91       	pop	r20
    112c:	3f 91       	pop	r19
    112e:	2f 91       	pop	r18
    1130:	1f 91       	pop	r17
    1132:	0f 91       	pop	r16
    1134:	ff 90       	pop	r15
    1136:	ef 90       	pop	r14
    1138:	df 90       	pop	r13
    113a:	cf 90       	pop	r12
    113c:	bf 90       	pop	r11
    113e:	af 90       	pop	r10
    1140:	9f 90       	pop	r9
    1142:	8f 90       	pop	r8
    1144:	7f 90       	pop	r7
    1146:	6f 90       	pop	r6
    1148:	5f 90       	pop	r5
    114a:	4f 90       	pop	r4
    114c:	3f 90       	pop	r3
    114e:	2f 90       	pop	r2
    1150:	1f 90       	pop	r1
    1152:	0f 90       	pop	r0
    1154:	0f be       	out	0x3f, r0	; 63
    1156:	0f 90       	pop	r0
    1158:	08 95       	ret
    115a:	81 e0       	ldi	r24, 0x01	; 1
    115c:	08 95       	ret

0000115e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    115e:	0f 92       	push	r0
    1160:	0f b6       	in	r0, 0x3f	; 63
    1162:	f8 94       	cli
    1164:	0f 92       	push	r0
    1166:	1f 92       	push	r1
    1168:	11 24       	eor	r1, r1
    116a:	2f 92       	push	r2
    116c:	3f 92       	push	r3
    116e:	4f 92       	push	r4
    1170:	5f 92       	push	r5
    1172:	6f 92       	push	r6
    1174:	7f 92       	push	r7
    1176:	8f 92       	push	r8
    1178:	9f 92       	push	r9
    117a:	af 92       	push	r10
    117c:	bf 92       	push	r11
    117e:	cf 92       	push	r12
    1180:	df 92       	push	r13
    1182:	ef 92       	push	r14
    1184:	ff 92       	push	r15
    1186:	0f 93       	push	r16
    1188:	1f 93       	push	r17
    118a:	2f 93       	push	r18
    118c:	3f 93       	push	r19
    118e:	4f 93       	push	r20
    1190:	5f 93       	push	r21
    1192:	6f 93       	push	r22
    1194:	7f 93       	push	r23
    1196:	8f 93       	push	r24
    1198:	9f 93       	push	r25
    119a:	af 93       	push	r26
    119c:	bf 93       	push	r27
    119e:	cf 93       	push	r28
    11a0:	df 93       	push	r29
    11a2:	ef 93       	push	r30
    11a4:	ff 93       	push	r31
    11a6:	a0 91 e1 09 	lds	r26, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    11aa:	b0 91 e2 09 	lds	r27, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    11ae:	0d b6       	in	r0, 0x3d	; 61
    11b0:	0d 92       	st	X+, r0
    11b2:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    11b4:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    11b6:	88 d3       	rcall	.+1808   	; 0x18c8 <vTaskSwitchContext>
    11b8:	a0 91 e1 09 	lds	r26, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    11bc:	b0 91 e2 09 	lds	r27, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    11c0:	cd 91       	ld	r28, X+
    11c2:	cd bf       	out	0x3d, r28	; 61
    11c4:	dd 91       	ld	r29, X+
    11c6:	de bf       	out	0x3e, r29	; 62
    11c8:	ff 91       	pop	r31
    11ca:	ef 91       	pop	r30
    11cc:	df 91       	pop	r29
    11ce:	cf 91       	pop	r28
    11d0:	bf 91       	pop	r27
    11d2:	af 91       	pop	r26
    11d4:	9f 91       	pop	r25
    11d6:	8f 91       	pop	r24
    11d8:	7f 91       	pop	r23
    11da:	6f 91       	pop	r22
    11dc:	5f 91       	pop	r21
    11de:	4f 91       	pop	r20
    11e0:	3f 91       	pop	r19
    11e2:	2f 91       	pop	r18
    11e4:	1f 91       	pop	r17
    11e6:	0f 91       	pop	r16
    11e8:	ff 90       	pop	r15
    11ea:	ef 90       	pop	r14
    11ec:	df 90       	pop	r13
    11ee:	cf 90       	pop	r12
    11f0:	bf 90       	pop	r11
    11f2:	af 90       	pop	r10
    11f4:	9f 90       	pop	r9
    11f6:	8f 90       	pop	r8
    11f8:	7f 90       	pop	r7
    11fa:	6f 90       	pop	r6
    11fc:	5f 90       	pop	r5
    11fe:	4f 90       	pop	r4
    1200:	3f 90       	pop	r3
    1202:	2f 90       	pop	r2
    1204:	1f 90       	pop	r1
    1206:	0f 90       	pop	r0
    1208:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    120a:	0f 90       	pop	r0
    120c:	08 95       	ret

0000120e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    120e:	0f 92       	push	r0
    1210:	0f b6       	in	r0, 0x3f	; 63
    1212:	f8 94       	cli
    1214:	0f 92       	push	r0
    1216:	1f 92       	push	r1
    1218:	11 24       	eor	r1, r1
    121a:	2f 92       	push	r2
    121c:	3f 92       	push	r3
    121e:	4f 92       	push	r4
    1220:	5f 92       	push	r5
    1222:	6f 92       	push	r6
    1224:	7f 92       	push	r7
    1226:	8f 92       	push	r8
    1228:	9f 92       	push	r9
    122a:	af 92       	push	r10
    122c:	bf 92       	push	r11
    122e:	cf 92       	push	r12
    1230:	df 92       	push	r13
    1232:	ef 92       	push	r14
    1234:	ff 92       	push	r15
    1236:	0f 93       	push	r16
    1238:	1f 93       	push	r17
    123a:	2f 93       	push	r18
    123c:	3f 93       	push	r19
    123e:	4f 93       	push	r20
    1240:	5f 93       	push	r21
    1242:	6f 93       	push	r22
    1244:	7f 93       	push	r23
    1246:	8f 93       	push	r24
    1248:	9f 93       	push	r25
    124a:	af 93       	push	r26
    124c:	bf 93       	push	r27
    124e:	cf 93       	push	r28
    1250:	df 93       	push	r29
    1252:	ef 93       	push	r30
    1254:	ff 93       	push	r31
    1256:	a0 91 e1 09 	lds	r26, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    125a:	b0 91 e2 09 	lds	r27, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    125e:	0d b6       	in	r0, 0x3d	; 61
    1260:	0d 92       	st	X+, r0
    1262:	0e b6       	in	r0, 0x3e	; 62
	vTaskIncrementTick();
	vTaskSwitchContext();
    1264:	0d 92       	st	X+, r0
    1266:	93 d1       	rcall	.+806    	; 0x158e <vTaskIncrementTick>
	portRESTORE_CONTEXT();
    1268:	2f d3       	rcall	.+1630   	; 0x18c8 <vTaskSwitchContext>
    126a:	a0 91 e1 09 	lds	r26, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    126e:	b0 91 e2 09 	lds	r27, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    1272:	cd 91       	ld	r28, X+
    1274:	cd bf       	out	0x3d, r28	; 61
    1276:	dd 91       	ld	r29, X+
    1278:	de bf       	out	0x3e, r29	; 62
    127a:	ff 91       	pop	r31
    127c:	ef 91       	pop	r30
    127e:	df 91       	pop	r29
    1280:	cf 91       	pop	r28
    1282:	bf 91       	pop	r27
    1284:	af 91       	pop	r26
    1286:	9f 91       	pop	r25
    1288:	8f 91       	pop	r24
    128a:	7f 91       	pop	r23
    128c:	6f 91       	pop	r22
    128e:	5f 91       	pop	r21
    1290:	4f 91       	pop	r20
    1292:	3f 91       	pop	r19
    1294:	2f 91       	pop	r18
    1296:	1f 91       	pop	r17
    1298:	0f 91       	pop	r16
    129a:	ff 90       	pop	r15
    129c:	ef 90       	pop	r14
    129e:	df 90       	pop	r13
    12a0:	cf 90       	pop	r12
    12a2:	bf 90       	pop	r11
    12a4:	af 90       	pop	r10
    12a6:	9f 90       	pop	r9
    12a8:	8f 90       	pop	r8
    12aa:	7f 90       	pop	r7
    12ac:	6f 90       	pop	r6
    12ae:	5f 90       	pop	r5
    12b0:	4f 90       	pop	r4
    12b2:	3f 90       	pop	r3
    12b4:	2f 90       	pop	r2
    12b6:	1f 90       	pop	r1
    12b8:	0f 90       	pop	r0
    12ba:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    12bc:	0f 90       	pop	r0
    12be:	08 95       	ret

000012c0 <__vector_13>:
}
    12c0:	a6 df       	rcall	.-180    	; 0x120e <vPortYieldFromTick>
    12c2:	18 95       	reti

000012c4 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    12c4:	cf 93       	push	r28
    12c6:	df 93       	push	r29
    12c8:	ec 01       	movw	r28, r24
    12ca:	e0 91 e1 09 	lds	r30, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    12ce:	f0 91 e2 09 	lds	r31, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    12d2:	93 83       	std	Z+3, r25	; 0x03
    12d4:	82 83       	std	Z+2, r24	; 0x02
    12d6:	80 91 91 09 	lds	r24, 0x0991	; 0x800991 <xTickCount>
    12da:	90 91 92 09 	lds	r25, 0x0992	; 0x800992 <xTickCount+0x1>
    12de:	c8 17       	cp	r28, r24
    12e0:	d9 07       	cpc	r29, r25
    12e2:	60 f4       	brcc	.+24     	; 0x12fc <prvAddCurrentTaskToDelayedList+0x38>
    12e4:	60 91 e1 09 	lds	r22, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    12e8:	70 91 e2 09 	lds	r23, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    12ec:	80 91 a7 09 	lds	r24, 0x09A7	; 0x8009a7 <pxOverflowDelayedTaskList>
    12f0:	90 91 a8 09 	lds	r25, 0x09A8	; 0x8009a8 <pxOverflowDelayedTaskList+0x1>
    12f4:	6e 5f       	subi	r22, 0xFE	; 254
    12f6:	7f 4f       	sbci	r23, 0xFF	; 255
    12f8:	45 d8       	rcall	.-3958   	; 0x384 <vListInsert>
    12fa:	16 c0       	rjmp	.+44     	; 0x1328 <prvAddCurrentTaskToDelayedList+0x64>
    12fc:	60 91 e1 09 	lds	r22, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    1300:	70 91 e2 09 	lds	r23, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    1304:	80 91 a9 09 	lds	r24, 0x09A9	; 0x8009a9 <pxDelayedTaskList>
    1308:	90 91 aa 09 	lds	r25, 0x09AA	; 0x8009aa <pxDelayedTaskList+0x1>
    130c:	6e 5f       	subi	r22, 0xFE	; 254
    130e:	7f 4f       	sbci	r23, 0xFF	; 255
    1310:	39 d8       	rcall	.-3982   	; 0x384 <vListInsert>
    1312:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <xNextTaskUnblockTime>
    1316:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <xNextTaskUnblockTime+0x1>
    131a:	c8 17       	cp	r28, r24
    131c:	d9 07       	cpc	r29, r25
    131e:	20 f4       	brcc	.+8      	; 0x1328 <prvAddCurrentTaskToDelayedList+0x64>
    1320:	d0 93 10 01 	sts	0x0110, r29	; 0x800110 <xNextTaskUnblockTime+0x1>
    1324:	c0 93 0f 01 	sts	0x010F, r28	; 0x80010f <xNextTaskUnblockTime>
    1328:	df 91       	pop	r29
    132a:	cf 91       	pop	r28
    132c:	08 95       	ret

0000132e <xTaskGenericCreate>:
    132e:	4f 92       	push	r4
    1330:	5f 92       	push	r5
    1332:	6f 92       	push	r6
    1334:	7f 92       	push	r7
    1336:	8f 92       	push	r8
    1338:	9f 92       	push	r9
    133a:	af 92       	push	r10
    133c:	bf 92       	push	r11
    133e:	cf 92       	push	r12
    1340:	df 92       	push	r13
    1342:	ef 92       	push	r14
    1344:	ff 92       	push	r15
    1346:	0f 93       	push	r16
    1348:	1f 93       	push	r17
    134a:	cf 93       	push	r28
    134c:	df 93       	push	r29
    134e:	5c 01       	movw	r10, r24
    1350:	4b 01       	movw	r8, r22
    1352:	3a 01       	movw	r6, r20
    1354:	29 01       	movw	r4, r18
    1356:	81 e2       	ldi	r24, 0x21	; 33
    1358:	90 e0       	ldi	r25, 0x00	; 0
    135a:	0e 94 62 01 	call	0x2c4	; 0x2c4 <pvPortMalloc>
    135e:	ec 01       	movw	r28, r24
    1360:	89 2b       	or	r24, r25
    1362:	09 f4       	brne	.+2      	; 0x1366 <xTaskGenericCreate+0x38>
    1364:	d3 c0       	rjmp	.+422    	; 0x150c <xTaskGenericCreate+0x1de>
    1366:	c1 14       	cp	r12, r1
    1368:	d1 04       	cpc	r13, r1
    136a:	09 f0       	breq	.+2      	; 0x136e <xTaskGenericCreate+0x40>
    136c:	cb c0       	rjmp	.+406    	; 0x1504 <xTaskGenericCreate+0x1d6>
    136e:	c3 01       	movw	r24, r6
    1370:	0e 94 62 01 	call	0x2c4	; 0x2c4 <pvPortMalloc>
    1374:	98 8f       	std	Y+24, r25	; 0x18
    1376:	8f 8b       	std	Y+23, r24	; 0x17
    1378:	00 97       	sbiw	r24, 0x00	; 0
    137a:	21 f4       	brne	.+8      	; 0x1384 <xTaskGenericCreate+0x56>
    137c:	ce 01       	movw	r24, r28
    137e:	0e 94 88 01 	call	0x310	; 0x310 <vPortFree>
    1382:	c4 c0       	rjmp	.+392    	; 0x150c <xTaskGenericCreate+0x1de>
    1384:	a3 01       	movw	r20, r6
    1386:	65 ea       	ldi	r22, 0xA5	; 165
    1388:	70 e0       	ldi	r23, 0x00	; 0
    138a:	1f d3       	rcall	.+1598   	; 0x19ca <memset>
    138c:	93 01       	movw	r18, r6
    138e:	21 50       	subi	r18, 0x01	; 1
    1390:	31 09       	sbc	r19, r1
    1392:	8f 89       	ldd	r24, Y+23	; 0x17
    1394:	98 8d       	ldd	r25, Y+24	; 0x18
    1396:	3c 01       	movw	r6, r24
    1398:	62 0e       	add	r6, r18
    139a:	73 1e       	adc	r7, r19
    139c:	48 e0       	ldi	r20, 0x08	; 8
    139e:	50 e0       	ldi	r21, 0x00	; 0
    13a0:	b4 01       	movw	r22, r8
    13a2:	ce 01       	movw	r24, r28
    13a4:	49 96       	adiw	r24, 0x19	; 25
    13a6:	18 d3       	rcall	.+1584   	; 0x19d8 <strncpy>
    13a8:	18 a2       	std	Y+32, r1	; 0x20
    13aa:	10 2f       	mov	r17, r16
    13ac:	04 30       	cpi	r16, 0x04	; 4
    13ae:	08 f0       	brcs	.+2      	; 0x13b2 <xTaskGenericCreate+0x84>
    13b0:	13 e0       	ldi	r17, 0x03	; 3
    13b2:	1e 8b       	std	Y+22, r17	; 0x16
    13b4:	6e 01       	movw	r12, r28
    13b6:	82 e0       	ldi	r24, 0x02	; 2
    13b8:	c8 0e       	add	r12, r24
    13ba:	d1 1c       	adc	r13, r1
    13bc:	c6 01       	movw	r24, r12
    13be:	0e 94 97 01 	call	0x32e	; 0x32e <vListInitialiseItem>
    13c2:	ce 01       	movw	r24, r28
    13c4:	0c 96       	adiw	r24, 0x0c	; 12
    13c6:	0e 94 97 01 	call	0x32e	; 0x32e <vListInitialiseItem>
    13ca:	d9 87       	std	Y+9, r29	; 0x09
    13cc:	c8 87       	std	Y+8, r28	; 0x08
    13ce:	84 e0       	ldi	r24, 0x04	; 4
    13d0:	90 e0       	ldi	r25, 0x00	; 0
    13d2:	81 1b       	sub	r24, r17
    13d4:	91 09       	sbc	r25, r1
    13d6:	9d 87       	std	Y+13, r25	; 0x0d
    13d8:	8c 87       	std	Y+12, r24	; 0x0c
    13da:	db 8b       	std	Y+19, r29	; 0x13
    13dc:	ca 8b       	std	Y+18, r28	; 0x12
    13de:	a2 01       	movw	r20, r4
    13e0:	b5 01       	movw	r22, r10
    13e2:	c3 01       	movw	r24, r6
    13e4:	16 de       	rcall	.-980    	; 0x1012 <pxPortInitialiseStack>
    13e6:	99 83       	std	Y+1, r25	; 0x01
    13e8:	88 83       	st	Y, r24
    13ea:	e1 14       	cp	r14, r1
    13ec:	f1 04       	cpc	r15, r1
    13ee:	19 f0       	breq	.+6      	; 0x13f6 <xTaskGenericCreate+0xc8>
    13f0:	f7 01       	movw	r30, r14
    13f2:	d1 83       	std	Z+1, r29	; 0x01
    13f4:	c0 83       	st	Z, r28
    13f6:	0f b6       	in	r0, 0x3f	; 63
    13f8:	f8 94       	cli
    13fa:	0f 92       	push	r0
    13fc:	80 91 93 09 	lds	r24, 0x0993	; 0x800993 <uxCurrentNumberOfTasks>
    1400:	8f 5f       	subi	r24, 0xFF	; 255
    1402:	80 93 93 09 	sts	0x0993, r24	; 0x800993 <uxCurrentNumberOfTasks>
    1406:	80 91 e1 09 	lds	r24, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    140a:	90 91 e2 09 	lds	r25, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    140e:	89 2b       	or	r24, r25
    1410:	a9 f5       	brne	.+106    	; 0x147c <xTaskGenericCreate+0x14e>
    1412:	d0 93 e2 09 	sts	0x09E2, r29	; 0x8009e2 <pxCurrentTCB+0x1>
    1416:	c0 93 e1 09 	sts	0x09E1, r28	; 0x8009e1 <pxCurrentTCB>
    141a:	80 91 93 09 	lds	r24, 0x0993	; 0x800993 <uxCurrentNumberOfTasks>
    141e:	81 30       	cpi	r24, 0x01	; 1
    1420:	e1 f5       	brne	.+120    	; 0x149a <xTaskGenericCreate+0x16c>
    1422:	8d eb       	ldi	r24, 0xBD	; 189
    1424:	99 e0       	ldi	r25, 0x09	; 9
    1426:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    142a:	86 ec       	ldi	r24, 0xC6	; 198
    142c:	99 e0       	ldi	r25, 0x09	; 9
    142e:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1432:	8f ec       	ldi	r24, 0xCF	; 207
    1434:	99 e0       	ldi	r25, 0x09	; 9
    1436:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    143a:	88 ed       	ldi	r24, 0xD8	; 216
    143c:	99 e0       	ldi	r25, 0x09	; 9
    143e:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1442:	84 eb       	ldi	r24, 0xB4	; 180
    1444:	99 e0       	ldi	r25, 0x09	; 9
    1446:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    144a:	8b ea       	ldi	r24, 0xAB	; 171
    144c:	99 e0       	ldi	r25, 0x09	; 9
    144e:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1452:	8e e9       	ldi	r24, 0x9E	; 158
    1454:	99 e0       	ldi	r25, 0x09	; 9
    1456:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    145a:	85 e9       	ldi	r24, 0x95	; 149
    145c:	99 e0       	ldi	r25, 0x09	; 9
    145e:	0e 94 89 01 	call	0x312	; 0x312 <vListInitialise>
    1462:	84 eb       	ldi	r24, 0xB4	; 180
    1464:	99 e0       	ldi	r25, 0x09	; 9
    1466:	90 93 aa 09 	sts	0x09AA, r25	; 0x8009aa <pxDelayedTaskList+0x1>
    146a:	80 93 a9 09 	sts	0x09A9, r24	; 0x8009a9 <pxDelayedTaskList>
    146e:	8b ea       	ldi	r24, 0xAB	; 171
    1470:	99 e0       	ldi	r25, 0x09	; 9
    1472:	90 93 a8 09 	sts	0x09A8, r25	; 0x8009a8 <pxOverflowDelayedTaskList+0x1>
    1476:	80 93 a7 09 	sts	0x09A7, r24	; 0x8009a7 <pxOverflowDelayedTaskList>
    147a:	0f c0       	rjmp	.+30     	; 0x149a <xTaskGenericCreate+0x16c>
    147c:	80 91 8e 09 	lds	r24, 0x098E	; 0x80098e <xSchedulerRunning>
    1480:	81 11       	cpse	r24, r1
    1482:	0b c0       	rjmp	.+22     	; 0x149a <xTaskGenericCreate+0x16c>
    1484:	e0 91 e1 09 	lds	r30, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    1488:	f0 91 e2 09 	lds	r31, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    148c:	86 89       	ldd	r24, Z+22	; 0x16
    148e:	08 17       	cp	r16, r24
    1490:	20 f0       	brcs	.+8      	; 0x149a <xTaskGenericCreate+0x16c>
    1492:	d0 93 e2 09 	sts	0x09E2, r29	; 0x8009e2 <pxCurrentTCB+0x1>
    1496:	c0 93 e1 09 	sts	0x09E1, r28	; 0x8009e1 <pxCurrentTCB>
    149a:	8e 89       	ldd	r24, Y+22	; 0x16
    149c:	90 91 90 09 	lds	r25, 0x0990	; 0x800990 <uxTopUsedPriority>
    14a0:	98 17       	cp	r25, r24
    14a2:	10 f4       	brcc	.+4      	; 0x14a8 <xTaskGenericCreate+0x17a>
    14a4:	80 93 90 09 	sts	0x0990, r24	; 0x800990 <uxTopUsedPriority>
    14a8:	90 91 89 09 	lds	r25, 0x0989	; 0x800989 <uxTaskNumber>
    14ac:	9f 5f       	subi	r25, 0xFF	; 255
    14ae:	90 93 89 09 	sts	0x0989, r25	; 0x800989 <uxTaskNumber>
    14b2:	90 91 8f 09 	lds	r25, 0x098F	; 0x80098f <uxTopReadyPriority>
    14b6:	98 17       	cp	r25, r24
    14b8:	10 f4       	brcc	.+4      	; 0x14be <xTaskGenericCreate+0x190>
    14ba:	80 93 8f 09 	sts	0x098F, r24	; 0x80098f <uxTopReadyPriority>
    14be:	90 e0       	ldi	r25, 0x00	; 0
    14c0:	9c 01       	movw	r18, r24
    14c2:	22 0f       	add	r18, r18
    14c4:	33 1f       	adc	r19, r19
    14c6:	22 0f       	add	r18, r18
    14c8:	33 1f       	adc	r19, r19
    14ca:	22 0f       	add	r18, r18
    14cc:	33 1f       	adc	r19, r19
    14ce:	82 0f       	add	r24, r18
    14d0:	93 1f       	adc	r25, r19
    14d2:	b6 01       	movw	r22, r12
    14d4:	83 54       	subi	r24, 0x43	; 67
    14d6:	96 4f       	sbci	r25, 0xF6	; 246
    14d8:	0e 94 9b 01 	call	0x336	; 0x336 <vListInsertEnd>
    14dc:	0f 90       	pop	r0
    14de:	0f be       	out	0x3f, r0	; 63
    14e0:	80 91 8e 09 	lds	r24, 0x098E	; 0x80098e <xSchedulerRunning>
    14e4:	88 23       	and	r24, r24
    14e6:	51 f0       	breq	.+20     	; 0x14fc <xTaskGenericCreate+0x1ce>
    14e8:	e0 91 e1 09 	lds	r30, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    14ec:	f0 91 e2 09 	lds	r31, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    14f0:	86 89       	ldd	r24, Z+22	; 0x16
    14f2:	80 17       	cp	r24, r16
    14f4:	28 f4       	brcc	.+10     	; 0x1500 <xTaskGenericCreate+0x1d2>
    14f6:	33 de       	rcall	.-922    	; 0x115e <vPortYield>
    14f8:	81 e0       	ldi	r24, 0x01	; 1
    14fa:	09 c0       	rjmp	.+18     	; 0x150e <xTaskGenericCreate+0x1e0>
    14fc:	81 e0       	ldi	r24, 0x01	; 1
    14fe:	07 c0       	rjmp	.+14     	; 0x150e <xTaskGenericCreate+0x1e0>
    1500:	81 e0       	ldi	r24, 0x01	; 1
    1502:	05 c0       	rjmp	.+10     	; 0x150e <xTaskGenericCreate+0x1e0>
    1504:	d8 8e       	std	Y+24, r13	; 0x18
    1506:	cf 8a       	std	Y+23, r12	; 0x17
    1508:	c6 01       	movw	r24, r12
    150a:	3c cf       	rjmp	.-392    	; 0x1384 <xTaskGenericCreate+0x56>
    150c:	8f ef       	ldi	r24, 0xFF	; 255
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	1f 91       	pop	r17
    1514:	0f 91       	pop	r16
    1516:	ff 90       	pop	r15
    1518:	ef 90       	pop	r14
    151a:	df 90       	pop	r13
    151c:	cf 90       	pop	r12
    151e:	bf 90       	pop	r11
    1520:	af 90       	pop	r10
    1522:	9f 90       	pop	r9
    1524:	8f 90       	pop	r8
    1526:	7f 90       	pop	r7
    1528:	6f 90       	pop	r6
    152a:	5f 90       	pop	r5
    152c:	4f 90       	pop	r4
    152e:	08 95       	ret

00001530 <vTaskStartScheduler>:
    1530:	af 92       	push	r10
    1532:	bf 92       	push	r11
    1534:	cf 92       	push	r12
    1536:	df 92       	push	r13
    1538:	ef 92       	push	r14
    153a:	ff 92       	push	r15
    153c:	0f 93       	push	r16
    153e:	a1 2c       	mov	r10, r1
    1540:	b1 2c       	mov	r11, r1
    1542:	c1 2c       	mov	r12, r1
    1544:	d1 2c       	mov	r13, r1
    1546:	e1 2c       	mov	r14, r1
    1548:	f1 2c       	mov	r15, r1
    154a:	00 e0       	ldi	r16, 0x00	; 0
    154c:	20 e0       	ldi	r18, 0x00	; 0
    154e:	30 e0       	ldi	r19, 0x00	; 0
    1550:	45 e5       	ldi	r20, 0x55	; 85
    1552:	50 e0       	ldi	r21, 0x00	; 0
    1554:	63 ea       	ldi	r22, 0xA3	; 163
    1556:	71 e0       	ldi	r23, 0x01	; 1
    1558:	8b e2       	ldi	r24, 0x2B	; 43
    155a:	9c e0       	ldi	r25, 0x0C	; 12
    155c:	e8 de       	rcall	.-560    	; 0x132e <xTaskGenericCreate>
    155e:	81 30       	cpi	r24, 0x01	; 1
    1560:	41 f4       	brne	.+16     	; 0x1572 <vTaskStartScheduler+0x42>
    1562:	f8 94       	cli
    1564:	80 93 8e 09 	sts	0x098E, r24	; 0x80098e <xSchedulerRunning>
    1568:	10 92 92 09 	sts	0x0992, r1	; 0x800992 <xTickCount+0x1>
    156c:	10 92 91 09 	sts	0x0991, r1	; 0x800991 <xTickCount>
    1570:	bc dd       	rcall	.-1160   	; 0x10ea <xPortStartScheduler>
    1572:	0f 91       	pop	r16
    1574:	ff 90       	pop	r15
    1576:	ef 90       	pop	r14
    1578:	df 90       	pop	r13
    157a:	cf 90       	pop	r12
    157c:	bf 90       	pop	r11
    157e:	af 90       	pop	r10
    1580:	08 95       	ret

00001582 <vTaskSuspendAll>:
    1582:	80 91 8d 09 	lds	r24, 0x098D	; 0x80098d <uxSchedulerSuspended>
    1586:	8f 5f       	subi	r24, 0xFF	; 255
    1588:	80 93 8d 09 	sts	0x098D, r24	; 0x80098d <uxSchedulerSuspended>
    158c:	08 95       	ret

0000158e <vTaskIncrementTick>:
    158e:	0f 93       	push	r16
    1590:	1f 93       	push	r17
    1592:	cf 93       	push	r28
    1594:	df 93       	push	r29
    1596:	80 91 8d 09 	lds	r24, 0x098D	; 0x80098d <uxSchedulerSuspended>
    159a:	81 11       	cpse	r24, r1
    159c:	b2 c0       	rjmp	.+356    	; 0x1702 <vTaskIncrementTick+0x174>
    159e:	80 91 91 09 	lds	r24, 0x0991	; 0x800991 <xTickCount>
    15a2:	90 91 92 09 	lds	r25, 0x0992	; 0x800992 <xTickCount+0x1>
    15a6:	01 96       	adiw	r24, 0x01	; 1
    15a8:	90 93 92 09 	sts	0x0992, r25	; 0x800992 <xTickCount+0x1>
    15ac:	80 93 91 09 	sts	0x0991, r24	; 0x800991 <xTickCount>
    15b0:	80 91 91 09 	lds	r24, 0x0991	; 0x800991 <xTickCount>
    15b4:	90 91 92 09 	lds	r25, 0x0992	; 0x800992 <xTickCount+0x1>
    15b8:	89 2b       	or	r24, r25
    15ba:	99 f5       	brne	.+102    	; 0x1622 <vTaskIncrementTick+0x94>
    15bc:	80 91 a9 09 	lds	r24, 0x09A9	; 0x8009a9 <pxDelayedTaskList>
    15c0:	90 91 aa 09 	lds	r25, 0x09AA	; 0x8009aa <pxDelayedTaskList+0x1>
    15c4:	20 91 a7 09 	lds	r18, 0x09A7	; 0x8009a7 <pxOverflowDelayedTaskList>
    15c8:	30 91 a8 09 	lds	r19, 0x09A8	; 0x8009a8 <pxOverflowDelayedTaskList+0x1>
    15cc:	30 93 aa 09 	sts	0x09AA, r19	; 0x8009aa <pxDelayedTaskList+0x1>
    15d0:	20 93 a9 09 	sts	0x09A9, r18	; 0x8009a9 <pxDelayedTaskList>
    15d4:	90 93 a8 09 	sts	0x09A8, r25	; 0x8009a8 <pxOverflowDelayedTaskList+0x1>
    15d8:	80 93 a7 09 	sts	0x09A7, r24	; 0x8009a7 <pxOverflowDelayedTaskList>
    15dc:	80 91 8a 09 	lds	r24, 0x098A	; 0x80098a <xNumOfOverflows>
    15e0:	8f 5f       	subi	r24, 0xFF	; 255
    15e2:	80 93 8a 09 	sts	0x098A, r24	; 0x80098a <xNumOfOverflows>
    15e6:	e0 91 a9 09 	lds	r30, 0x09A9	; 0x8009a9 <pxDelayedTaskList>
    15ea:	f0 91 aa 09 	lds	r31, 0x09AA	; 0x8009aa <pxDelayedTaskList+0x1>
    15ee:	80 81       	ld	r24, Z
    15f0:	81 11       	cpse	r24, r1
    15f2:	07 c0       	rjmp	.+14     	; 0x1602 <vTaskIncrementTick+0x74>
    15f4:	8f ef       	ldi	r24, 0xFF	; 255
    15f6:	9f ef       	ldi	r25, 0xFF	; 255
    15f8:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <xNextTaskUnblockTime+0x1>
    15fc:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <xNextTaskUnblockTime>
    1600:	10 c0       	rjmp	.+32     	; 0x1622 <vTaskIncrementTick+0x94>
    1602:	e0 91 a9 09 	lds	r30, 0x09A9	; 0x8009a9 <pxDelayedTaskList>
    1606:	f0 91 aa 09 	lds	r31, 0x09AA	; 0x8009aa <pxDelayedTaskList+0x1>
    160a:	05 80       	ldd	r0, Z+5	; 0x05
    160c:	f6 81       	ldd	r31, Z+6	; 0x06
    160e:	e0 2d       	mov	r30, r0
    1610:	06 80       	ldd	r0, Z+6	; 0x06
    1612:	f7 81       	ldd	r31, Z+7	; 0x07
    1614:	e0 2d       	mov	r30, r0
    1616:	82 81       	ldd	r24, Z+2	; 0x02
    1618:	93 81       	ldd	r25, Z+3	; 0x03
    161a:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <xNextTaskUnblockTime+0x1>
    161e:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <xNextTaskUnblockTime>
    1622:	20 91 91 09 	lds	r18, 0x0991	; 0x800991 <xTickCount>
    1626:	30 91 92 09 	lds	r19, 0x0992	; 0x800992 <xTickCount+0x1>
    162a:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <xNextTaskUnblockTime>
    162e:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <xNextTaskUnblockTime+0x1>
    1632:	28 17       	cp	r18, r24
    1634:	39 07       	cpc	r19, r25
    1636:	08 f4       	brcc	.+2      	; 0x163a <vTaskIncrementTick+0xac>
    1638:	69 c0       	rjmp	.+210    	; 0x170c <vTaskIncrementTick+0x17e>
    163a:	e0 91 a9 09 	lds	r30, 0x09A9	; 0x8009a9 <pxDelayedTaskList>
    163e:	f0 91 aa 09 	lds	r31, 0x09AA	; 0x8009aa <pxDelayedTaskList+0x1>
    1642:	80 81       	ld	r24, Z
    1644:	88 23       	and	r24, r24
    1646:	99 f0       	breq	.+38     	; 0x166e <vTaskIncrementTick+0xe0>
    1648:	e0 91 a9 09 	lds	r30, 0x09A9	; 0x8009a9 <pxDelayedTaskList>
    164c:	f0 91 aa 09 	lds	r31, 0x09AA	; 0x8009aa <pxDelayedTaskList+0x1>
    1650:	05 80       	ldd	r0, Z+5	; 0x05
    1652:	f6 81       	ldd	r31, Z+6	; 0x06
    1654:	e0 2d       	mov	r30, r0
    1656:	c6 81       	ldd	r28, Z+6	; 0x06
    1658:	d7 81       	ldd	r29, Z+7	; 0x07
    165a:	8a 81       	ldd	r24, Y+2	; 0x02
    165c:	9b 81       	ldd	r25, Y+3	; 0x03
    165e:	20 91 91 09 	lds	r18, 0x0991	; 0x800991 <xTickCount>
    1662:	30 91 92 09 	lds	r19, 0x0992	; 0x800992 <xTickCount+0x1>
    1666:	28 17       	cp	r18, r24
    1668:	39 07       	cpc	r19, r25
    166a:	f8 f4       	brcc	.+62     	; 0x16aa <vTaskIncrementTick+0x11c>
    166c:	19 c0       	rjmp	.+50     	; 0x16a0 <vTaskIncrementTick+0x112>
    166e:	8f ef       	ldi	r24, 0xFF	; 255
    1670:	9f ef       	ldi	r25, 0xFF	; 255
    1672:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <xNextTaskUnblockTime+0x1>
    1676:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <xNextTaskUnblockTime>
    167a:	48 c0       	rjmp	.+144    	; 0x170c <vTaskIncrementTick+0x17e>
    167c:	e0 91 a9 09 	lds	r30, 0x09A9	; 0x8009a9 <pxDelayedTaskList>
    1680:	f0 91 aa 09 	lds	r31, 0x09AA	; 0x8009aa <pxDelayedTaskList+0x1>
    1684:	05 80       	ldd	r0, Z+5	; 0x05
    1686:	f6 81       	ldd	r31, Z+6	; 0x06
    1688:	e0 2d       	mov	r30, r0
    168a:	c6 81       	ldd	r28, Z+6	; 0x06
    168c:	d7 81       	ldd	r29, Z+7	; 0x07
    168e:	8a 81       	ldd	r24, Y+2	; 0x02
    1690:	9b 81       	ldd	r25, Y+3	; 0x03
    1692:	20 91 91 09 	lds	r18, 0x0991	; 0x800991 <xTickCount>
    1696:	30 91 92 09 	lds	r19, 0x0992	; 0x800992 <xTickCount+0x1>
    169a:	28 17       	cp	r18, r24
    169c:	39 07       	cpc	r19, r25
    169e:	28 f4       	brcc	.+10     	; 0x16aa <vTaskIncrementTick+0x11c>
    16a0:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <xNextTaskUnblockTime+0x1>
    16a4:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <xNextTaskUnblockTime>
    16a8:	31 c0       	rjmp	.+98     	; 0x170c <vTaskIncrementTick+0x17e>
    16aa:	8e 01       	movw	r16, r28
    16ac:	0e 5f       	subi	r16, 0xFE	; 254
    16ae:	1f 4f       	sbci	r17, 0xFF	; 255
    16b0:	c8 01       	movw	r24, r16
    16b2:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
    16b6:	8c 89       	ldd	r24, Y+20	; 0x14
    16b8:	9d 89       	ldd	r25, Y+21	; 0x15
    16ba:	89 2b       	or	r24, r25
    16bc:	21 f0       	breq	.+8      	; 0x16c6 <vTaskIncrementTick+0x138>
    16be:	ce 01       	movw	r24, r28
    16c0:	0c 96       	adiw	r24, 0x0c	; 12
    16c2:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
    16c6:	8e 89       	ldd	r24, Y+22	; 0x16
    16c8:	90 91 8f 09 	lds	r25, 0x098F	; 0x80098f <uxTopReadyPriority>
    16cc:	98 17       	cp	r25, r24
    16ce:	10 f4       	brcc	.+4      	; 0x16d4 <vTaskIncrementTick+0x146>
    16d0:	80 93 8f 09 	sts	0x098F, r24	; 0x80098f <uxTopReadyPriority>
    16d4:	90 e0       	ldi	r25, 0x00	; 0
    16d6:	9c 01       	movw	r18, r24
    16d8:	22 0f       	add	r18, r18
    16da:	33 1f       	adc	r19, r19
    16dc:	22 0f       	add	r18, r18
    16de:	33 1f       	adc	r19, r19
    16e0:	22 0f       	add	r18, r18
    16e2:	33 1f       	adc	r19, r19
    16e4:	82 0f       	add	r24, r18
    16e6:	93 1f       	adc	r25, r19
    16e8:	b8 01       	movw	r22, r16
    16ea:	83 54       	subi	r24, 0x43	; 67
    16ec:	96 4f       	sbci	r25, 0xF6	; 246
    16ee:	0e 94 9b 01 	call	0x336	; 0x336 <vListInsertEnd>
    16f2:	e0 91 a9 09 	lds	r30, 0x09A9	; 0x8009a9 <pxDelayedTaskList>
    16f6:	f0 91 aa 09 	lds	r31, 0x09AA	; 0x8009aa <pxDelayedTaskList+0x1>
    16fa:	80 81       	ld	r24, Z
    16fc:	81 11       	cpse	r24, r1
    16fe:	be cf       	rjmp	.-132    	; 0x167c <vTaskIncrementTick+0xee>
    1700:	b6 cf       	rjmp	.-148    	; 0x166e <vTaskIncrementTick+0xe0>
    1702:	80 91 8c 09 	lds	r24, 0x098C	; 0x80098c <uxMissedTicks>
    1706:	8f 5f       	subi	r24, 0xFF	; 255
    1708:	80 93 8c 09 	sts	0x098C, r24	; 0x80098c <uxMissedTicks>
    170c:	df 91       	pop	r29
    170e:	cf 91       	pop	r28
    1710:	1f 91       	pop	r17
    1712:	0f 91       	pop	r16
    1714:	08 95       	ret

00001716 <xTaskResumeAll>:
    1716:	cf 92       	push	r12
    1718:	df 92       	push	r13
    171a:	ef 92       	push	r14
    171c:	ff 92       	push	r15
    171e:	0f 93       	push	r16
    1720:	1f 93       	push	r17
    1722:	cf 93       	push	r28
    1724:	df 93       	push	r29
    1726:	0f b6       	in	r0, 0x3f	; 63
    1728:	f8 94       	cli
    172a:	0f 92       	push	r0
    172c:	80 91 8d 09 	lds	r24, 0x098D	; 0x80098d <uxSchedulerSuspended>
    1730:	81 50       	subi	r24, 0x01	; 1
    1732:	80 93 8d 09 	sts	0x098D, r24	; 0x80098d <uxSchedulerSuspended>
    1736:	80 91 8d 09 	lds	r24, 0x098D	; 0x80098d <uxSchedulerSuspended>
    173a:	81 11       	cpse	r24, r1
    173c:	62 c0       	rjmp	.+196    	; 0x1802 <xTaskResumeAll+0xec>
    173e:	80 91 93 09 	lds	r24, 0x0993	; 0x800993 <uxCurrentNumberOfTasks>
    1742:	81 11       	cpse	r24, r1
    1744:	32 c0       	rjmp	.+100    	; 0x17aa <xTaskResumeAll+0x94>
    1746:	60 c0       	rjmp	.+192    	; 0x1808 <xTaskResumeAll+0xf2>
    1748:	d7 01       	movw	r26, r14
    174a:	15 96       	adiw	r26, 0x05	; 5
    174c:	ed 91       	ld	r30, X+
    174e:	fc 91       	ld	r31, X
    1750:	16 97       	sbiw	r26, 0x06	; 6
    1752:	c6 81       	ldd	r28, Z+6	; 0x06
    1754:	d7 81       	ldd	r29, Z+7	; 0x07
    1756:	ce 01       	movw	r24, r28
    1758:	0c 96       	adiw	r24, 0x0c	; 12
    175a:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
    175e:	8e 01       	movw	r16, r28
    1760:	0e 5f       	subi	r16, 0xFE	; 254
    1762:	1f 4f       	sbci	r17, 0xFF	; 255
    1764:	c8 01       	movw	r24, r16
    1766:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
    176a:	8e 89       	ldd	r24, Y+22	; 0x16
    176c:	90 91 8f 09 	lds	r25, 0x098F	; 0x80098f <uxTopReadyPriority>
    1770:	98 17       	cp	r25, r24
    1772:	10 f4       	brcc	.+4      	; 0x1778 <xTaskResumeAll+0x62>
    1774:	80 93 8f 09 	sts	0x098F, r24	; 0x80098f <uxTopReadyPriority>
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	9c 01       	movw	r18, r24
    177c:	22 0f       	add	r18, r18
    177e:	33 1f       	adc	r19, r19
    1780:	22 0f       	add	r18, r18
    1782:	33 1f       	adc	r19, r19
    1784:	22 0f       	add	r18, r18
    1786:	33 1f       	adc	r19, r19
    1788:	82 0f       	add	r24, r18
    178a:	93 1f       	adc	r25, r19
    178c:	b8 01       	movw	r22, r16
    178e:	83 54       	subi	r24, 0x43	; 67
    1790:	96 4f       	sbci	r25, 0xF6	; 246
    1792:	0e 94 9b 01 	call	0x336	; 0x336 <vListInsertEnd>
    1796:	e0 91 e1 09 	lds	r30, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    179a:	f0 91 e2 09 	lds	r31, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    179e:	9e 89       	ldd	r25, Y+22	; 0x16
    17a0:	86 89       	ldd	r24, Z+22	; 0x16
    17a2:	98 17       	cp	r25, r24
    17a4:	58 f0       	brcs	.+22     	; 0x17bc <xTaskResumeAll+0xa6>
    17a6:	dc 2c       	mov	r13, r12
    17a8:	09 c0       	rjmp	.+18     	; 0x17bc <xTaskResumeAll+0xa6>
    17aa:	d1 2c       	mov	r13, r1
    17ac:	0f 2e       	mov	r0, r31
    17ae:	fe e9       	ldi	r31, 0x9E	; 158
    17b0:	ef 2e       	mov	r14, r31
    17b2:	f9 e0       	ldi	r31, 0x09	; 9
    17b4:	ff 2e       	mov	r15, r31
    17b6:	f0 2d       	mov	r31, r0
    17b8:	cc 24       	eor	r12, r12
    17ba:	c3 94       	inc	r12
    17bc:	f7 01       	movw	r30, r14
    17be:	80 81       	ld	r24, Z
    17c0:	81 11       	cpse	r24, r1
    17c2:	c2 cf       	rjmp	.-124    	; 0x1748 <xTaskResumeAll+0x32>
    17c4:	80 91 8c 09 	lds	r24, 0x098C	; 0x80098c <uxMissedTicks>
    17c8:	88 23       	and	r24, r24
    17ca:	79 f0       	breq	.+30     	; 0x17ea <xTaskResumeAll+0xd4>
    17cc:	80 91 8c 09 	lds	r24, 0x098C	; 0x80098c <uxMissedTicks>
    17d0:	88 23       	and	r24, r24
    17d2:	91 f0       	breq	.+36     	; 0x17f8 <xTaskResumeAll+0xe2>
    17d4:	dc de       	rcall	.-584    	; 0x158e <vTaskIncrementTick>
    17d6:	80 91 8c 09 	lds	r24, 0x098C	; 0x80098c <uxMissedTicks>
    17da:	81 50       	subi	r24, 0x01	; 1
    17dc:	80 93 8c 09 	sts	0x098C, r24	; 0x80098c <uxMissedTicks>
    17e0:	80 91 8c 09 	lds	r24, 0x098C	; 0x80098c <uxMissedTicks>
    17e4:	81 11       	cpse	r24, r1
    17e6:	f6 cf       	rjmp	.-20     	; 0x17d4 <xTaskResumeAll+0xbe>
    17e8:	07 c0       	rjmp	.+14     	; 0x17f8 <xTaskResumeAll+0xe2>
    17ea:	f1 e0       	ldi	r31, 0x01	; 1
    17ec:	df 16       	cp	r13, r31
    17ee:	21 f0       	breq	.+8      	; 0x17f8 <xTaskResumeAll+0xe2>
    17f0:	80 91 8b 09 	lds	r24, 0x098B	; 0x80098b <xMissedYield>
    17f4:	81 30       	cpi	r24, 0x01	; 1
    17f6:	39 f4       	brne	.+14     	; 0x1806 <xTaskResumeAll+0xf0>
    17f8:	10 92 8b 09 	sts	0x098B, r1	; 0x80098b <xMissedYield>
    17fc:	b0 dc       	rcall	.-1696   	; 0x115e <vPortYield>
    17fe:	81 e0       	ldi	r24, 0x01	; 1
    1800:	03 c0       	rjmp	.+6      	; 0x1808 <xTaskResumeAll+0xf2>
    1802:	80 e0       	ldi	r24, 0x00	; 0
    1804:	01 c0       	rjmp	.+2      	; 0x1808 <xTaskResumeAll+0xf2>
    1806:	80 e0       	ldi	r24, 0x00	; 0
    1808:	0f 90       	pop	r0
    180a:	0f be       	out	0x3f, r0	; 63
    180c:	df 91       	pop	r29
    180e:	cf 91       	pop	r28
    1810:	1f 91       	pop	r17
    1812:	0f 91       	pop	r16
    1814:	ff 90       	pop	r15
    1816:	ef 90       	pop	r14
    1818:	df 90       	pop	r13
    181a:	cf 90       	pop	r12
    181c:	08 95       	ret

0000181e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    181e:	cf 93       	push	r28
    1820:	df 93       	push	r29
    1822:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1824:	89 2b       	or	r24, r25
		{
			vTaskSuspendAll();
    1826:	99 f0       	breq	.+38     	; 0x184e <vTaskDelay+0x30>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1828:	ac de       	rcall	.-680    	; 0x1582 <vTaskSuspendAll>
    182a:	80 91 91 09 	lds	r24, 0x0991	; 0x800991 <xTickCount>
    182e:	90 91 92 09 	lds	r25, 0x0992	; 0x800992 <xTickCount+0x1>
    1832:	c8 0f       	add	r28, r24

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1834:	d9 1f       	adc	r29, r25
    1836:	80 91 e1 09 	lds	r24, 0x09E1	; 0x8009e1 <pxCurrentTCB>
    183a:	90 91 e2 09 	lds	r25, 0x09E2	; 0x8009e2 <pxCurrentTCB+0x1>
    183e:	02 96       	adiw	r24, 0x02	; 2
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1840:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
			xAlreadyYielded = xTaskResumeAll();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1844:	ce 01       	movw	r24, r28
    1846:	3e dd       	rcall	.-1412   	; 0x12c4 <prvAddCurrentTaskToDelayedList>
		{
			portYIELD_WITHIN_API();
    1848:	66 df       	rcall	.-308    	; 0x1716 <xTaskResumeAll>
    184a:	81 11       	cpse	r24, r1
		}
	}
    184c:	01 c0       	rjmp	.+2      	; 0x1850 <vTaskDelay+0x32>
    184e:	87 dc       	rcall	.-1778   	; 0x115e <vPortYield>
    1850:	df 91       	pop	r29
    1852:	cf 91       	pop	r28
    1854:	08 95       	ret

00001856 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1856:	0f 2e       	mov	r0, r31
    1858:	f5 e9       	ldi	r31, 0x95	; 149
    185a:	ef 2e       	mov	r14, r31
    185c:	f9 e0       	ldi	r31, 0x09	; 9
    185e:	ff 2e       	mov	r15, r31
    1860:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1862:	cd eb       	ldi	r28, 0xBD	; 189
    1864:	d9 e0       	ldi	r29, 0x09	; 9
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1866:	80 91 94 09 	lds	r24, 0x0994	; 0x800994 <uxTasksDeleted>
    186a:	88 23       	and	r24, r24
		{
			vTaskSuspendAll();
    186c:	41 f1       	breq	.+80     	; 0x18be <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    186e:	89 de       	rcall	.-750    	; 0x1582 <vTaskSuspendAll>
			xTaskResumeAll();
    1870:	d7 01       	movw	r26, r14
    1872:	1c 91       	ld	r17, X

			if( xListIsEmpty == pdFALSE )
    1874:	50 df       	rcall	.-352    	; 0x1716 <xTaskResumeAll>
    1876:	11 23       	and	r17, r17
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    1878:	11 f1       	breq	.+68     	; 0x18be <prvIdleTask+0x68>
    187a:	0f b6       	in	r0, 0x3f	; 63
    187c:	f8 94       	cli
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    187e:	0f 92       	push	r0
    1880:	d7 01       	movw	r26, r14
    1882:	15 96       	adiw	r26, 0x05	; 5
    1884:	ed 91       	ld	r30, X+
    1886:	fc 91       	ld	r31, X
    1888:	16 97       	sbiw	r26, 0x06	; 6
    188a:	06 81       	ldd	r16, Z+6	; 0x06
					vListRemove( &( pxTCB->xGenericListItem ) );
    188c:	17 81       	ldd	r17, Z+7	; 0x07
    188e:	c8 01       	movw	r24, r16
    1890:	02 96       	adiw	r24, 0x02	; 2
    1892:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vListRemove>
					--uxCurrentNumberOfTasks;
    1896:	80 91 93 09 	lds	r24, 0x0993	; 0x800993 <uxCurrentNumberOfTasks>
    189a:	81 50       	subi	r24, 0x01	; 1
    189c:	80 93 93 09 	sts	0x0993, r24	; 0x800993 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    18a0:	80 91 94 09 	lds	r24, 0x0994	; 0x800994 <uxTasksDeleted>
    18a4:	81 50       	subi	r24, 0x01	; 1
    18a6:	80 93 94 09 	sts	0x0994, r24	; 0x800994 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    18aa:	0f 90       	pop	r0
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    18ac:	0f be       	out	0x3f, r0	; 63
    18ae:	f8 01       	movw	r30, r16
    18b0:	87 89       	ldd	r24, Z+23	; 0x17
    18b2:	90 8d       	ldd	r25, Z+24	; 0x18
    18b4:	0e 94 88 01 	call	0x310	; 0x310 <vPortFree>
		vPortFree( pxTCB );
    18b8:	c8 01       	movw	r24, r16
    18ba:	0e 94 88 01 	call	0x310	; 0x310 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    18be:	88 81       	ld	r24, Y
			{
				taskYIELD();
    18c0:	82 30       	cpi	r24, 0x02	; 2
    18c2:	88 f2       	brcs	.-94     	; 0x1866 <prvIdleTask+0x10>
    18c4:	4c dc       	rcall	.-1896   	; 0x115e <vPortYield>
    18c6:	cf cf       	rjmp	.-98     	; 0x1866 <prvIdleTask+0x10>

000018c8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    18c8:	80 91 8d 09 	lds	r24, 0x098D	; 0x80098d <uxSchedulerSuspended>
    18cc:	81 11       	cpse	r24, r1
    18ce:	13 c0       	rjmp	.+38     	; 0x18f6 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    18d0:	80 91 8f 09 	lds	r24, 0x098F	; 0x80098f <uxTopReadyPriority>
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	fc 01       	movw	r30, r24
    18d8:	ee 0f       	add	r30, r30
    18da:	ff 1f       	adc	r31, r31
    18dc:	ee 0f       	add	r30, r30
    18de:	ff 1f       	adc	r31, r31
    18e0:	ee 0f       	add	r30, r30
    18e2:	ff 1f       	adc	r31, r31
    18e4:	8e 0f       	add	r24, r30
    18e6:	9f 1f       	adc	r25, r31
    18e8:	fc 01       	movw	r30, r24
    18ea:	e3 54       	subi	r30, 0x43	; 67
    18ec:	f6 4f       	sbci	r31, 0xF6	; 246
    18ee:	80 81       	ld	r24, Z
    18f0:	88 23       	and	r24, r24
    18f2:	29 f0       	breq	.+10     	; 0x18fe <vTaskSwitchContext+0x36>
    18f4:	1b c0       	rjmp	.+54     	; 0x192c <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    18f6:	81 e0       	ldi	r24, 0x01	; 1
    18f8:	80 93 8b 09 	sts	0x098B, r24	; 0x80098b <xMissedYield>
    18fc:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    18fe:	80 91 8f 09 	lds	r24, 0x098F	; 0x80098f <uxTopReadyPriority>
    1902:	81 50       	subi	r24, 0x01	; 1
    1904:	80 93 8f 09 	sts	0x098F, r24	; 0x80098f <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1908:	80 91 8f 09 	lds	r24, 0x098F	; 0x80098f <uxTopReadyPriority>
    190c:	90 e0       	ldi	r25, 0x00	; 0
    190e:	fc 01       	movw	r30, r24
    1910:	ee 0f       	add	r30, r30
    1912:	ff 1f       	adc	r31, r31
    1914:	ee 0f       	add	r30, r30
    1916:	ff 1f       	adc	r31, r31
    1918:	ee 0f       	add	r30, r30
    191a:	ff 1f       	adc	r31, r31
    191c:	8e 0f       	add	r24, r30
    191e:	9f 1f       	adc	r25, r31
    1920:	fc 01       	movw	r30, r24
    1922:	e3 54       	subi	r30, 0x43	; 67
    1924:	f6 4f       	sbci	r31, 0xF6	; 246
    1926:	80 81       	ld	r24, Z
    1928:	88 23       	and	r24, r24
    192a:	49 f3       	breq	.-46     	; 0x18fe <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    192c:	80 91 8f 09 	lds	r24, 0x098F	; 0x80098f <uxTopReadyPriority>
    1930:	90 e0       	ldi	r25, 0x00	; 0
    1932:	9c 01       	movw	r18, r24
    1934:	22 0f       	add	r18, r18
    1936:	33 1f       	adc	r19, r19
    1938:	22 0f       	add	r18, r18
    193a:	33 1f       	adc	r19, r19
    193c:	22 0f       	add	r18, r18
    193e:	33 1f       	adc	r19, r19
    1940:	28 0f       	add	r18, r24
    1942:	39 1f       	adc	r19, r25
    1944:	d9 01       	movw	r26, r18
    1946:	a3 54       	subi	r26, 0x43	; 67
    1948:	b6 4f       	sbci	r27, 0xF6	; 246
    194a:	11 96       	adiw	r26, 0x01	; 1
    194c:	ed 91       	ld	r30, X+
    194e:	fc 91       	ld	r31, X
    1950:	12 97       	sbiw	r26, 0x02	; 2
    1952:	02 80       	ldd	r0, Z+2	; 0x02
    1954:	f3 81       	ldd	r31, Z+3	; 0x03
    1956:	e0 2d       	mov	r30, r0
    1958:	12 96       	adiw	r26, 0x02	; 2
    195a:	fc 93       	st	X, r31
    195c:	ee 93       	st	-X, r30
    195e:	11 97       	sbiw	r26, 0x01	; 1
    1960:	20 54       	subi	r18, 0x40	; 64
    1962:	36 4f       	sbci	r19, 0xF6	; 246
    1964:	e2 17       	cp	r30, r18
    1966:	f3 07       	cpc	r31, r19
    1968:	29 f4       	brne	.+10     	; 0x1974 <vTaskSwitchContext+0xac>
    196a:	22 81       	ldd	r18, Z+2	; 0x02
    196c:	33 81       	ldd	r19, Z+3	; 0x03
    196e:	fd 01       	movw	r30, r26
    1970:	32 83       	std	Z+2, r19	; 0x02
    1972:	21 83       	std	Z+1, r18	; 0x01
    1974:	fc 01       	movw	r30, r24
    1976:	ee 0f       	add	r30, r30
    1978:	ff 1f       	adc	r31, r31
    197a:	ee 0f       	add	r30, r30
    197c:	ff 1f       	adc	r31, r31
    197e:	ee 0f       	add	r30, r30
    1980:	ff 1f       	adc	r31, r31
    1982:	8e 0f       	add	r24, r30
    1984:	9f 1f       	adc	r25, r31
    1986:	fc 01       	movw	r30, r24
    1988:	e3 54       	subi	r30, 0x43	; 67
    198a:	f6 4f       	sbci	r31, 0xF6	; 246
    198c:	01 80       	ldd	r0, Z+1	; 0x01
    198e:	f2 81       	ldd	r31, Z+2	; 0x02
    1990:	e0 2d       	mov	r30, r0
    1992:	86 81       	ldd	r24, Z+6	; 0x06
    1994:	97 81       	ldd	r25, Z+7	; 0x07
    1996:	90 93 e2 09 	sts	0x09E2, r25	; 0x8009e2 <pxCurrentTCB+0x1>
    199a:	80 93 e1 09 	sts	0x09E1, r24	; 0x8009e1 <pxCurrentTCB>
    199e:	08 95       	ret

000019a0 <__udivmodqi4>:
    19a0:	99 1b       	sub	r25, r25
    19a2:	79 e0       	ldi	r23, 0x09	; 9
    19a4:	04 c0       	rjmp	.+8      	; 0x19ae <__udivmodqi4_ep>

000019a6 <__udivmodqi4_loop>:
    19a6:	99 1f       	adc	r25, r25
    19a8:	96 17       	cp	r25, r22
    19aa:	08 f0       	brcs	.+2      	; 0x19ae <__udivmodqi4_ep>
    19ac:	96 1b       	sub	r25, r22

000019ae <__udivmodqi4_ep>:
    19ae:	88 1f       	adc	r24, r24
    19b0:	7a 95       	dec	r23
    19b2:	c9 f7       	brne	.-14     	; 0x19a6 <__udivmodqi4_loop>
    19b4:	80 95       	com	r24
    19b6:	08 95       	ret

000019b8 <__tablejump2__>:
    19b8:	ee 0f       	add	r30, r30
    19ba:	ff 1f       	adc	r31, r31
    19bc:	00 24       	eor	r0, r0
    19be:	00 1c       	adc	r0, r0
    19c0:	0b be       	out	0x3b, r0	; 59
    19c2:	07 90       	elpm	r0, Z+
    19c4:	f6 91       	elpm	r31, Z
    19c6:	e0 2d       	mov	r30, r0
    19c8:	09 94       	ijmp

000019ca <memset>:
    19ca:	dc 01       	movw	r26, r24
    19cc:	01 c0       	rjmp	.+2      	; 0x19d0 <memset+0x6>
    19ce:	6d 93       	st	X+, r22
    19d0:	41 50       	subi	r20, 0x01	; 1
    19d2:	50 40       	sbci	r21, 0x00	; 0
    19d4:	e0 f7       	brcc	.-8      	; 0x19ce <memset+0x4>
    19d6:	08 95       	ret

000019d8 <strncpy>:
    19d8:	fb 01       	movw	r30, r22
    19da:	dc 01       	movw	r26, r24
    19dc:	41 50       	subi	r20, 0x01	; 1
    19de:	50 40       	sbci	r21, 0x00	; 0
    19e0:	48 f0       	brcs	.+18     	; 0x19f4 <strncpy+0x1c>
    19e2:	01 90       	ld	r0, Z+
    19e4:	0d 92       	st	X+, r0
    19e6:	00 20       	and	r0, r0
    19e8:	c9 f7       	brne	.-14     	; 0x19dc <strncpy+0x4>
    19ea:	01 c0       	rjmp	.+2      	; 0x19ee <strncpy+0x16>
    19ec:	1d 92       	st	X+, r1
    19ee:	41 50       	subi	r20, 0x01	; 1
    19f0:	50 40       	sbci	r21, 0x00	; 0
    19f2:	e0 f7       	brcc	.-8      	; 0x19ec <strncpy+0x14>
    19f4:	08 95       	ret

000019f6 <_exit>:
    19f6:	f8 94       	cli

000019f8 <__stop_program>:
    19f8:	ff cf       	rjmp	.-2      	; 0x19f8 <__stop_program>
